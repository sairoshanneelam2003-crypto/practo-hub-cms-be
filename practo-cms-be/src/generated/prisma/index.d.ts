
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Topic
 * 
 */
export type Topic = $Result.DefaultSelection<Prisma.$TopicPayload>
/**
 * Model DoctorPointer
 * 
 */
export type DoctorPointer = $Result.DefaultSelection<Prisma.$DoctorPointerPayload>
/**
 * Model Script
 * 
 */
export type Script = $Result.DefaultSelection<Prisma.$ScriptPayload>
/**
 * Model ScriptReview
 * 
 */
export type ScriptReview = $Result.DefaultSelection<Prisma.$ScriptReviewPayload>
/**
 * Model Video
 * 
 */
export type Video = $Result.DefaultSelection<Prisma.$VideoPayload>
/**
 * Model VideoReview
 * 
 */
export type VideoReview = $Result.DefaultSelection<Prisma.$VideoReviewPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model VideoAnalytics
 * 
 */
export type VideoAnalytics = $Result.DefaultSelection<Prisma.$VideoAnalyticsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  MEDICAL_AFFAIRS: 'MEDICAL_AFFAIRS',
  BRAND_REVIEWER: 'BRAND_REVIEWER',
  DOCTOR: 'DOCTOR',
  AGENCY_POC: 'AGENCY_POC',
  CONTENT_APPROVER: 'CONTENT_APPROVER',
  PUBLISHER: 'PUBLISHER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SUSPENDED: 'SUSPENDED'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const TopicStatus: {
  ASSIGNED: 'ASSIGNED',
  DOCTOR_INPUT_PENDING: 'DOCTOR_INPUT_PENDING',
  DOCTOR_INPUT_RECEIVED: 'DOCTOR_INPUT_RECEIVED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED'
};

export type TopicStatus = (typeof TopicStatus)[keyof typeof TopicStatus]


export const ScriptStatus: {
  DRAFT: 'DRAFT',
  MEDICAL_REVIEW: 'MEDICAL_REVIEW',
  BRAND_REVIEW: 'BRAND_REVIEW',
  DOCTOR_REVIEW: 'DOCTOR_REVIEW',
  APPROVED: 'APPROVED',
  LOCKED: 'LOCKED',
  REJECTED: 'REJECTED'
};

export type ScriptStatus = (typeof ScriptStatus)[keyof typeof ScriptStatus]


export const ReviewDecision: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type ReviewDecision = (typeof ReviewDecision)[keyof typeof ReviewDecision]


export const CTAType: {
  QUIZ: 'QUIZ',
  CONSULT: 'CONSULT',
  VAULT: 'VAULT'
};

export type CTAType = (typeof CTAType)[keyof typeof CTAType]


export const VideoStatus: {
  DRAFT: 'DRAFT',
  BRAND_REVIEW: 'BRAND_REVIEW',
  MEDICAL_REVIEW: 'MEDICAL_REVIEW',
  DOCTOR_REVIEW: 'DOCTOR_REVIEW',
  APPROVED: 'APPROVED',
  LOCKED: 'LOCKED',
  PUBLISHED: 'PUBLISHED',
  ARCHIVED: 'ARCHIVED',
  REJECTED: 'REJECTED'
};

export type VideoStatus = (typeof VideoStatus)[keyof typeof VideoStatus]


export const NotificationType: {
  EMAIL: 'EMAIL',
  IN_APP: 'IN_APP'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type TopicStatus = $Enums.TopicStatus

export const TopicStatus: typeof $Enums.TopicStatus

export type ScriptStatus = $Enums.ScriptStatus

export const ScriptStatus: typeof $Enums.ScriptStatus

export type ReviewDecision = $Enums.ReviewDecision

export const ReviewDecision: typeof $Enums.ReviewDecision

export type CTAType = $Enums.CTAType

export const CTAType: typeof $Enums.CTAType

export type VideoStatus = $Enums.VideoStatus

export const VideoStatus: typeof $Enums.VideoStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.topic`: Exposes CRUD operations for the **Topic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Topics
    * const topics = await prisma.topic.findMany()
    * ```
    */
  get topic(): Prisma.TopicDelegate<ExtArgs>;

  /**
   * `prisma.doctorPointer`: Exposes CRUD operations for the **DoctorPointer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DoctorPointers
    * const doctorPointers = await prisma.doctorPointer.findMany()
    * ```
    */
  get doctorPointer(): Prisma.DoctorPointerDelegate<ExtArgs>;

  /**
   * `prisma.script`: Exposes CRUD operations for the **Script** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Scripts
    * const scripts = await prisma.script.findMany()
    * ```
    */
  get script(): Prisma.ScriptDelegate<ExtArgs>;

  /**
   * `prisma.scriptReview`: Exposes CRUD operations for the **ScriptReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScriptReviews
    * const scriptReviews = await prisma.scriptReview.findMany()
    * ```
    */
  get scriptReview(): Prisma.ScriptReviewDelegate<ExtArgs>;

  /**
   * `prisma.video`: Exposes CRUD operations for the **Video** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Videos
    * const videos = await prisma.video.findMany()
    * ```
    */
  get video(): Prisma.VideoDelegate<ExtArgs>;

  /**
   * `prisma.videoReview`: Exposes CRUD operations for the **VideoReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VideoReviews
    * const videoReviews = await prisma.videoReview.findMany()
    * ```
    */
  get videoReview(): Prisma.VideoReviewDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.videoAnalytics`: Exposes CRUD operations for the **VideoAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VideoAnalytics
    * const videoAnalytics = await prisma.videoAnalytics.findMany()
    * ```
    */
  get videoAnalytics(): Prisma.VideoAnalyticsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Topic: 'Topic',
    DoctorPointer: 'DoctorPointer',
    Script: 'Script',
    ScriptReview: 'ScriptReview',
    Video: 'Video',
    VideoReview: 'VideoReview',
    Comment: 'Comment',
    Notification: 'Notification',
    AuditLog: 'AuditLog',
    VideoAnalytics: 'VideoAnalytics'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "topic" | "doctorPointer" | "script" | "scriptReview" | "video" | "videoReview" | "comment" | "notification" | "auditLog" | "videoAnalytics"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Topic: {
        payload: Prisma.$TopicPayload<ExtArgs>
        fields: Prisma.TopicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TopicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TopicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          findFirst: {
            args: Prisma.TopicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TopicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          findMany: {
            args: Prisma.TopicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[]
          }
          create: {
            args: Prisma.TopicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          createMany: {
            args: Prisma.TopicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TopicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[]
          }
          delete: {
            args: Prisma.TopicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          update: {
            args: Prisma.TopicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          deleteMany: {
            args: Prisma.TopicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TopicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TopicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          aggregate: {
            args: Prisma.TopicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTopic>
          }
          groupBy: {
            args: Prisma.TopicGroupByArgs<ExtArgs>
            result: $Utils.Optional<TopicGroupByOutputType>[]
          }
          count: {
            args: Prisma.TopicCountArgs<ExtArgs>
            result: $Utils.Optional<TopicCountAggregateOutputType> | number
          }
        }
      }
      DoctorPointer: {
        payload: Prisma.$DoctorPointerPayload<ExtArgs>
        fields: Prisma.DoctorPointerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DoctorPointerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPointerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DoctorPointerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPointerPayload>
          }
          findFirst: {
            args: Prisma.DoctorPointerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPointerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DoctorPointerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPointerPayload>
          }
          findMany: {
            args: Prisma.DoctorPointerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPointerPayload>[]
          }
          create: {
            args: Prisma.DoctorPointerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPointerPayload>
          }
          createMany: {
            args: Prisma.DoctorPointerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DoctorPointerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPointerPayload>[]
          }
          delete: {
            args: Prisma.DoctorPointerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPointerPayload>
          }
          update: {
            args: Prisma.DoctorPointerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPointerPayload>
          }
          deleteMany: {
            args: Prisma.DoctorPointerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DoctorPointerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DoctorPointerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPointerPayload>
          }
          aggregate: {
            args: Prisma.DoctorPointerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDoctorPointer>
          }
          groupBy: {
            args: Prisma.DoctorPointerGroupByArgs<ExtArgs>
            result: $Utils.Optional<DoctorPointerGroupByOutputType>[]
          }
          count: {
            args: Prisma.DoctorPointerCountArgs<ExtArgs>
            result: $Utils.Optional<DoctorPointerCountAggregateOutputType> | number
          }
        }
      }
      Script: {
        payload: Prisma.$ScriptPayload<ExtArgs>
        fields: Prisma.ScriptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScriptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScriptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScriptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScriptPayload>
          }
          findFirst: {
            args: Prisma.ScriptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScriptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScriptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScriptPayload>
          }
          findMany: {
            args: Prisma.ScriptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScriptPayload>[]
          }
          create: {
            args: Prisma.ScriptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScriptPayload>
          }
          createMany: {
            args: Prisma.ScriptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScriptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScriptPayload>[]
          }
          delete: {
            args: Prisma.ScriptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScriptPayload>
          }
          update: {
            args: Prisma.ScriptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScriptPayload>
          }
          deleteMany: {
            args: Prisma.ScriptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScriptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScriptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScriptPayload>
          }
          aggregate: {
            args: Prisma.ScriptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScript>
          }
          groupBy: {
            args: Prisma.ScriptGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScriptGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScriptCountArgs<ExtArgs>
            result: $Utils.Optional<ScriptCountAggregateOutputType> | number
          }
        }
      }
      ScriptReview: {
        payload: Prisma.$ScriptReviewPayload<ExtArgs>
        fields: Prisma.ScriptReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScriptReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScriptReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScriptReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScriptReviewPayload>
          }
          findFirst: {
            args: Prisma.ScriptReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScriptReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScriptReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScriptReviewPayload>
          }
          findMany: {
            args: Prisma.ScriptReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScriptReviewPayload>[]
          }
          create: {
            args: Prisma.ScriptReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScriptReviewPayload>
          }
          createMany: {
            args: Prisma.ScriptReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScriptReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScriptReviewPayload>[]
          }
          delete: {
            args: Prisma.ScriptReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScriptReviewPayload>
          }
          update: {
            args: Prisma.ScriptReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScriptReviewPayload>
          }
          deleteMany: {
            args: Prisma.ScriptReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScriptReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScriptReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScriptReviewPayload>
          }
          aggregate: {
            args: Prisma.ScriptReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScriptReview>
          }
          groupBy: {
            args: Prisma.ScriptReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScriptReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScriptReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ScriptReviewCountAggregateOutputType> | number
          }
        }
      }
      Video: {
        payload: Prisma.$VideoPayload<ExtArgs>
        fields: Prisma.VideoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          findFirst: {
            args: Prisma.VideoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          findMany: {
            args: Prisma.VideoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>[]
          }
          create: {
            args: Prisma.VideoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          createMany: {
            args: Prisma.VideoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>[]
          }
          delete: {
            args: Prisma.VideoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          update: {
            args: Prisma.VideoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          deleteMany: {
            args: Prisma.VideoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VideoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          aggregate: {
            args: Prisma.VideoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideo>
          }
          groupBy: {
            args: Prisma.VideoGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoCountArgs<ExtArgs>
            result: $Utils.Optional<VideoCountAggregateOutputType> | number
          }
        }
      }
      VideoReview: {
        payload: Prisma.$VideoReviewPayload<ExtArgs>
        fields: Prisma.VideoReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoReviewPayload>
          }
          findFirst: {
            args: Prisma.VideoReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoReviewPayload>
          }
          findMany: {
            args: Prisma.VideoReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoReviewPayload>[]
          }
          create: {
            args: Prisma.VideoReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoReviewPayload>
          }
          createMany: {
            args: Prisma.VideoReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideoReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoReviewPayload>[]
          }
          delete: {
            args: Prisma.VideoReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoReviewPayload>
          }
          update: {
            args: Prisma.VideoReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoReviewPayload>
          }
          deleteMany: {
            args: Prisma.VideoReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VideoReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoReviewPayload>
          }
          aggregate: {
            args: Prisma.VideoReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideoReview>
          }
          groupBy: {
            args: Prisma.VideoReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoReviewCountArgs<ExtArgs>
            result: $Utils.Optional<VideoReviewCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      VideoAnalytics: {
        payload: Prisma.$VideoAnalyticsPayload<ExtArgs>
        fields: Prisma.VideoAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.VideoAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoAnalyticsPayload>
          }
          findMany: {
            args: Prisma.VideoAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoAnalyticsPayload>[]
          }
          create: {
            args: Prisma.VideoAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoAnalyticsPayload>
          }
          createMany: {
            args: Prisma.VideoAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideoAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.VideoAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoAnalyticsPayload>
          }
          update: {
            args: Prisma.VideoAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.VideoAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VideoAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.VideoAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideoAnalytics>
          }
          groupBy: {
            args: Prisma.VideoAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<VideoAnalyticsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    assignedTopics: number
    createdTopics: number
    doctorPointers: number
    uploadedScripts: number
    lockedScripts: number
    assignedScripts: number
    scriptReviews: number
    uploadedVideos: number
    lockedVideos: number
    publishedVideos: number
    assignedVideos: number
    videoReviews: number
    comments: number
    notifications: number
    auditLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTopics?: boolean | UserCountOutputTypeCountAssignedTopicsArgs
    createdTopics?: boolean | UserCountOutputTypeCountCreatedTopicsArgs
    doctorPointers?: boolean | UserCountOutputTypeCountDoctorPointersArgs
    uploadedScripts?: boolean | UserCountOutputTypeCountUploadedScriptsArgs
    lockedScripts?: boolean | UserCountOutputTypeCountLockedScriptsArgs
    assignedScripts?: boolean | UserCountOutputTypeCountAssignedScriptsArgs
    scriptReviews?: boolean | UserCountOutputTypeCountScriptReviewsArgs
    uploadedVideos?: boolean | UserCountOutputTypeCountUploadedVideosArgs
    lockedVideos?: boolean | UserCountOutputTypeCountLockedVideosArgs
    publishedVideos?: boolean | UserCountOutputTypeCountPublishedVideosArgs
    assignedVideos?: boolean | UserCountOutputTypeCountAssignedVideosArgs
    videoReviews?: boolean | UserCountOutputTypeCountVideoReviewsArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDoctorPointersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorPointerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedScriptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScriptWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLockedScriptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScriptWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedScriptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScriptWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountScriptReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScriptReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLockedVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPublishedVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVideoReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type TopicCountOutputType
   */

  export type TopicCountOutputType = {
    doctorPointers: number
    scripts: number
    videos: number
  }

  export type TopicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctorPointers?: boolean | TopicCountOutputTypeCountDoctorPointersArgs
    scripts?: boolean | TopicCountOutputTypeCountScriptsArgs
    videos?: boolean | TopicCountOutputTypeCountVideosArgs
  }

  // Custom InputTypes
  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicCountOutputType
     */
    select?: TopicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountDoctorPointersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorPointerWhereInput
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountScriptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScriptWhereInput
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoWhereInput
  }


  /**
   * Count Type ScriptCountOutputType
   */

  export type ScriptCountOutputType = {
    reviews: number
    comments: number
    videos: number
  }

  export type ScriptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | ScriptCountOutputTypeCountReviewsArgs
    comments?: boolean | ScriptCountOutputTypeCountCommentsArgs
    videos?: boolean | ScriptCountOutputTypeCountVideosArgs
  }

  // Custom InputTypes
  /**
   * ScriptCountOutputType without action
   */
  export type ScriptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScriptCountOutputType
     */
    select?: ScriptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ScriptCountOutputType without action
   */
  export type ScriptCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScriptReviewWhereInput
  }

  /**
   * ScriptCountOutputType without action
   */
  export type ScriptCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * ScriptCountOutputType without action
   */
  export type ScriptCountOutputTypeCountVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoWhereInput
  }


  /**
   * Count Type VideoCountOutputType
   */

  export type VideoCountOutputType = {
    reviews: number
    comments: number
  }

  export type VideoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | VideoCountOutputTypeCountReviewsArgs
    comments?: boolean | VideoCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * VideoCountOutputType without action
   */
  export type VideoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCountOutputType
     */
    select?: VideoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VideoCountOutputType without action
   */
  export type VideoCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoReviewWhereInput
  }

  /**
   * VideoCountOutputType without action
   */
  export type VideoCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    status: $Enums.UserStatus | null
    specialty: string | null
    city: string | null
    googleId: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    status: $Enums.UserStatus | null
    specialty: string | null
    city: string | null
    googleId: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    firstName: number
    lastName: number
    role: number
    status: number
    specialty: number
    city: number
    googleId: number
    resetToken: number
    resetTokenExpiry: number
    createdAt: number
    updatedAt: number
    lastLoginAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    role?: true
    status?: true
    specialty?: true
    city?: true
    googleId?: true
    resetToken?: true
    resetTokenExpiry?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    role?: true
    status?: true
    specialty?: true
    city?: true
    googleId?: true
    resetToken?: true
    resetTokenExpiry?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    role?: true
    status?: true
    specialty?: true
    city?: true
    googleId?: true
    resetToken?: true
    resetTokenExpiry?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status: $Enums.UserStatus
    specialty: string | null
    city: string | null
    googleId: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    createdAt: Date
    updatedAt: Date
    lastLoginAt: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    status?: boolean
    specialty?: boolean
    city?: boolean
    googleId?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    assignedTopics?: boolean | User$assignedTopicsArgs<ExtArgs>
    createdTopics?: boolean | User$createdTopicsArgs<ExtArgs>
    doctorPointers?: boolean | User$doctorPointersArgs<ExtArgs>
    uploadedScripts?: boolean | User$uploadedScriptsArgs<ExtArgs>
    lockedScripts?: boolean | User$lockedScriptsArgs<ExtArgs>
    assignedScripts?: boolean | User$assignedScriptsArgs<ExtArgs>
    scriptReviews?: boolean | User$scriptReviewsArgs<ExtArgs>
    uploadedVideos?: boolean | User$uploadedVideosArgs<ExtArgs>
    lockedVideos?: boolean | User$lockedVideosArgs<ExtArgs>
    publishedVideos?: boolean | User$publishedVideosArgs<ExtArgs>
    assignedVideos?: boolean | User$assignedVideosArgs<ExtArgs>
    videoReviews?: boolean | User$videoReviewsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    status?: boolean
    specialty?: boolean
    city?: boolean
    googleId?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    status?: boolean
    specialty?: boolean
    city?: boolean
    googleId?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTopics?: boolean | User$assignedTopicsArgs<ExtArgs>
    createdTopics?: boolean | User$createdTopicsArgs<ExtArgs>
    doctorPointers?: boolean | User$doctorPointersArgs<ExtArgs>
    uploadedScripts?: boolean | User$uploadedScriptsArgs<ExtArgs>
    lockedScripts?: boolean | User$lockedScriptsArgs<ExtArgs>
    assignedScripts?: boolean | User$assignedScriptsArgs<ExtArgs>
    scriptReviews?: boolean | User$scriptReviewsArgs<ExtArgs>
    uploadedVideos?: boolean | User$uploadedVideosArgs<ExtArgs>
    lockedVideos?: boolean | User$lockedVideosArgs<ExtArgs>
    publishedVideos?: boolean | User$publishedVideosArgs<ExtArgs>
    assignedVideos?: boolean | User$assignedVideosArgs<ExtArgs>
    videoReviews?: boolean | User$videoReviewsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      assignedTopics: Prisma.$TopicPayload<ExtArgs>[]
      createdTopics: Prisma.$TopicPayload<ExtArgs>[]
      doctorPointers: Prisma.$DoctorPointerPayload<ExtArgs>[]
      uploadedScripts: Prisma.$ScriptPayload<ExtArgs>[]
      lockedScripts: Prisma.$ScriptPayload<ExtArgs>[]
      assignedScripts: Prisma.$ScriptPayload<ExtArgs>[]
      scriptReviews: Prisma.$ScriptReviewPayload<ExtArgs>[]
      uploadedVideos: Prisma.$VideoPayload<ExtArgs>[]
      lockedVideos: Prisma.$VideoPayload<ExtArgs>[]
      publishedVideos: Prisma.$VideoPayload<ExtArgs>[]
      assignedVideos: Prisma.$VideoPayload<ExtArgs>[]
      videoReviews: Prisma.$VideoReviewPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      firstName: string
      lastName: string
      role: $Enums.UserRole
      status: $Enums.UserStatus
      specialty: string | null
      city: string | null
      googleId: string | null
      resetToken: string | null
      resetTokenExpiry: Date | null
      createdAt: Date
      updatedAt: Date
      lastLoginAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignedTopics<T extends User$assignedTopicsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedTopicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany"> | Null>
    createdTopics<T extends User$createdTopicsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdTopicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany"> | Null>
    doctorPointers<T extends User$doctorPointersArgs<ExtArgs> = {}>(args?: Subset<T, User$doctorPointersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorPointerPayload<ExtArgs>, T, "findMany"> | Null>
    uploadedScripts<T extends User$uploadedScriptsArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedScriptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScriptPayload<ExtArgs>, T, "findMany"> | Null>
    lockedScripts<T extends User$lockedScriptsArgs<ExtArgs> = {}>(args?: Subset<T, User$lockedScriptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScriptPayload<ExtArgs>, T, "findMany"> | Null>
    assignedScripts<T extends User$assignedScriptsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedScriptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScriptPayload<ExtArgs>, T, "findMany"> | Null>
    scriptReviews<T extends User$scriptReviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$scriptReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScriptReviewPayload<ExtArgs>, T, "findMany"> | Null>
    uploadedVideos<T extends User$uploadedVideosArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedVideosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findMany"> | Null>
    lockedVideos<T extends User$lockedVideosArgs<ExtArgs> = {}>(args?: Subset<T, User$lockedVideosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findMany"> | Null>
    publishedVideos<T extends User$publishedVideosArgs<ExtArgs> = {}>(args?: Subset<T, User$publishedVideosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findMany"> | Null>
    assignedVideos<T extends User$assignedVideosArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedVideosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findMany"> | Null>
    videoReviews<T extends User$videoReviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$videoReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoReviewPayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly specialty: FieldRef<"User", 'String'>
    readonly city: FieldRef<"User", 'String'>
    readonly googleId: FieldRef<"User", 'String'>
    readonly resetToken: FieldRef<"User", 'String'>
    readonly resetTokenExpiry: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.assignedTopics
   */
  export type User$assignedTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    cursor?: TopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * User.createdTopics
   */
  export type User$createdTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    cursor?: TopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * User.doctorPointers
   */
  export type User$doctorPointersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPointer
     */
    select?: DoctorPointerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorPointerInclude<ExtArgs> | null
    where?: DoctorPointerWhereInput
    orderBy?: DoctorPointerOrderByWithRelationInput | DoctorPointerOrderByWithRelationInput[]
    cursor?: DoctorPointerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DoctorPointerScalarFieldEnum | DoctorPointerScalarFieldEnum[]
  }

  /**
   * User.uploadedScripts
   */
  export type User$uploadedScriptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Script
     */
    select?: ScriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScriptInclude<ExtArgs> | null
    where?: ScriptWhereInput
    orderBy?: ScriptOrderByWithRelationInput | ScriptOrderByWithRelationInput[]
    cursor?: ScriptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScriptScalarFieldEnum | ScriptScalarFieldEnum[]
  }

  /**
   * User.lockedScripts
   */
  export type User$lockedScriptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Script
     */
    select?: ScriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScriptInclude<ExtArgs> | null
    where?: ScriptWhereInput
    orderBy?: ScriptOrderByWithRelationInput | ScriptOrderByWithRelationInput[]
    cursor?: ScriptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScriptScalarFieldEnum | ScriptScalarFieldEnum[]
  }

  /**
   * User.assignedScripts
   */
  export type User$assignedScriptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Script
     */
    select?: ScriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScriptInclude<ExtArgs> | null
    where?: ScriptWhereInput
    orderBy?: ScriptOrderByWithRelationInput | ScriptOrderByWithRelationInput[]
    cursor?: ScriptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScriptScalarFieldEnum | ScriptScalarFieldEnum[]
  }

  /**
   * User.scriptReviews
   */
  export type User$scriptReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScriptReview
     */
    select?: ScriptReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScriptReviewInclude<ExtArgs> | null
    where?: ScriptReviewWhereInput
    orderBy?: ScriptReviewOrderByWithRelationInput | ScriptReviewOrderByWithRelationInput[]
    cursor?: ScriptReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScriptReviewScalarFieldEnum | ScriptReviewScalarFieldEnum[]
  }

  /**
   * User.uploadedVideos
   */
  export type User$uploadedVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    where?: VideoWhereInput
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    cursor?: VideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * User.lockedVideos
   */
  export type User$lockedVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    where?: VideoWhereInput
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    cursor?: VideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * User.publishedVideos
   */
  export type User$publishedVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    where?: VideoWhereInput
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    cursor?: VideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * User.assignedVideos
   */
  export type User$assignedVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    where?: VideoWhereInput
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    cursor?: VideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * User.videoReviews
   */
  export type User$videoReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoReview
     */
    select?: VideoReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoReviewInclude<ExtArgs> | null
    where?: VideoReviewWhereInput
    orderBy?: VideoReviewOrderByWithRelationInput | VideoReviewOrderByWithRelationInput[]
    cursor?: VideoReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoReviewScalarFieldEnum | VideoReviewScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Topic
   */

  export type AggregateTopic = {
    _count: TopicCountAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  export type TopicMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.TopicStatus | null
    assignedDoctorId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TopicMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.TopicStatus | null
    assignedDoctorId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TopicCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    assignedDoctorId: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TopicMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    assignedDoctorId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TopicMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    assignedDoctorId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TopicCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    assignedDoctorId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TopicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Topic to aggregate.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Topics
    **/
    _count?: true | TopicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TopicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TopicMaxAggregateInputType
  }

  export type GetTopicAggregateType<T extends TopicAggregateArgs> = {
        [P in keyof T & keyof AggregateTopic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopic[P]>
      : GetScalarType<T[P], AggregateTopic[P]>
  }




  export type TopicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithAggregationInput | TopicOrderByWithAggregationInput[]
    by: TopicScalarFieldEnum[] | TopicScalarFieldEnum
    having?: TopicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TopicCountAggregateInputType | true
    _min?: TopicMinAggregateInputType
    _max?: TopicMaxAggregateInputType
  }

  export type TopicGroupByOutputType = {
    id: string
    title: string
    description: string
    status: $Enums.TopicStatus
    assignedDoctorId: string
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: TopicCountAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  type GetTopicGroupByPayload<T extends TopicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TopicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TopicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopicGroupByOutputType[P]>
            : GetScalarType<T[P], TopicGroupByOutputType[P]>
        }
      >
    >


  export type TopicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    assignedDoctorId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedDoctor?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    doctorPointers?: boolean | Topic$doctorPointersArgs<ExtArgs>
    scripts?: boolean | Topic$scriptsArgs<ExtArgs>
    videos?: boolean | Topic$videosArgs<ExtArgs>
    _count?: boolean | TopicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topic"]>

  export type TopicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    assignedDoctorId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedDoctor?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topic"]>

  export type TopicSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    assignedDoctorId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TopicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedDoctor?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    doctorPointers?: boolean | Topic$doctorPointersArgs<ExtArgs>
    scripts?: boolean | Topic$scriptsArgs<ExtArgs>
    videos?: boolean | Topic$videosArgs<ExtArgs>
    _count?: boolean | TopicCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TopicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedDoctor?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TopicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Topic"
    objects: {
      assignedDoctor: Prisma.$UserPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
      doctorPointers: Prisma.$DoctorPointerPayload<ExtArgs>[]
      scripts: Prisma.$ScriptPayload<ExtArgs>[]
      videos: Prisma.$VideoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      status: $Enums.TopicStatus
      assignedDoctorId: string
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["topic"]>
    composites: {}
  }

  type TopicGetPayload<S extends boolean | null | undefined | TopicDefaultArgs> = $Result.GetResult<Prisma.$TopicPayload, S>

  type TopicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TopicFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TopicCountAggregateInputType | true
    }

  export interface TopicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Topic'], meta: { name: 'Topic' } }
    /**
     * Find zero or one Topic that matches the filter.
     * @param {TopicFindUniqueArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TopicFindUniqueArgs>(args: SelectSubset<T, TopicFindUniqueArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Topic that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TopicFindUniqueOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TopicFindUniqueOrThrowArgs>(args: SelectSubset<T, TopicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Topic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindFirstArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TopicFindFirstArgs>(args?: SelectSubset<T, TopicFindFirstArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Topic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindFirstOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TopicFindFirstOrThrowArgs>(args?: SelectSubset<T, TopicFindFirstOrThrowArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Topics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Topics
     * const topics = await prisma.topic.findMany()
     * 
     * // Get first 10 Topics
     * const topics = await prisma.topic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const topicWithIdOnly = await prisma.topic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TopicFindManyArgs>(args?: SelectSubset<T, TopicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Topic.
     * @param {TopicCreateArgs} args - Arguments to create a Topic.
     * @example
     * // Create one Topic
     * const Topic = await prisma.topic.create({
     *   data: {
     *     // ... data to create a Topic
     *   }
     * })
     * 
     */
    create<T extends TopicCreateArgs>(args: SelectSubset<T, TopicCreateArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Topics.
     * @param {TopicCreateManyArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topic = await prisma.topic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TopicCreateManyArgs>(args?: SelectSubset<T, TopicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Topics and returns the data saved in the database.
     * @param {TopicCreateManyAndReturnArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topic = await prisma.topic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Topics and only return the `id`
     * const topicWithIdOnly = await prisma.topic.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TopicCreateManyAndReturnArgs>(args?: SelectSubset<T, TopicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Topic.
     * @param {TopicDeleteArgs} args - Arguments to delete one Topic.
     * @example
     * // Delete one Topic
     * const Topic = await prisma.topic.delete({
     *   where: {
     *     // ... filter to delete one Topic
     *   }
     * })
     * 
     */
    delete<T extends TopicDeleteArgs>(args: SelectSubset<T, TopicDeleteArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Topic.
     * @param {TopicUpdateArgs} args - Arguments to update one Topic.
     * @example
     * // Update one Topic
     * const topic = await prisma.topic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TopicUpdateArgs>(args: SelectSubset<T, TopicUpdateArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Topics.
     * @param {TopicDeleteManyArgs} args - Arguments to filter Topics to delete.
     * @example
     * // Delete a few Topics
     * const { count } = await prisma.topic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TopicDeleteManyArgs>(args?: SelectSubset<T, TopicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Topics
     * const topic = await prisma.topic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TopicUpdateManyArgs>(args: SelectSubset<T, TopicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Topic.
     * @param {TopicUpsertArgs} args - Arguments to update or create a Topic.
     * @example
     * // Update or create a Topic
     * const topic = await prisma.topic.upsert({
     *   create: {
     *     // ... data to create a Topic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Topic we want to update
     *   }
     * })
     */
    upsert<T extends TopicUpsertArgs>(args: SelectSubset<T, TopicUpsertArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicCountArgs} args - Arguments to filter Topics to count.
     * @example
     * // Count the number of Topics
     * const count = await prisma.topic.count({
     *   where: {
     *     // ... the filter for the Topics we want to count
     *   }
     * })
    **/
    count<T extends TopicCountArgs>(
      args?: Subset<T, TopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TopicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TopicAggregateArgs>(args: Subset<T, TopicAggregateArgs>): Prisma.PrismaPromise<GetTopicAggregateType<T>>

    /**
     * Group by Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TopicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopicGroupByArgs['orderBy'] }
        : { orderBy?: TopicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TopicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTopicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Topic model
   */
  readonly fields: TopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Topic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TopicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignedDoctor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    doctorPointers<T extends Topic$doctorPointersArgs<ExtArgs> = {}>(args?: Subset<T, Topic$doctorPointersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorPointerPayload<ExtArgs>, T, "findMany"> | Null>
    scripts<T extends Topic$scriptsArgs<ExtArgs> = {}>(args?: Subset<T, Topic$scriptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScriptPayload<ExtArgs>, T, "findMany"> | Null>
    videos<T extends Topic$videosArgs<ExtArgs> = {}>(args?: Subset<T, Topic$videosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Topic model
   */ 
  interface TopicFieldRefs {
    readonly id: FieldRef<"Topic", 'String'>
    readonly title: FieldRef<"Topic", 'String'>
    readonly description: FieldRef<"Topic", 'String'>
    readonly status: FieldRef<"Topic", 'TopicStatus'>
    readonly assignedDoctorId: FieldRef<"Topic", 'String'>
    readonly createdById: FieldRef<"Topic", 'String'>
    readonly createdAt: FieldRef<"Topic", 'DateTime'>
    readonly updatedAt: FieldRef<"Topic", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Topic findUnique
   */
  export type TopicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic findUniqueOrThrow
   */
  export type TopicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic findFirst
   */
  export type TopicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic findFirstOrThrow
   */
  export type TopicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic findMany
   */
  export type TopicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topics to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic create
   */
  export type TopicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The data needed to create a Topic.
     */
    data: XOR<TopicCreateInput, TopicUncheckedCreateInput>
  }

  /**
   * Topic createMany
   */
  export type TopicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Topics.
     */
    data: TopicCreateManyInput | TopicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Topic createManyAndReturn
   */
  export type TopicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Topics.
     */
    data: TopicCreateManyInput | TopicCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Topic update
   */
  export type TopicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The data needed to update a Topic.
     */
    data: XOR<TopicUpdateInput, TopicUncheckedUpdateInput>
    /**
     * Choose, which Topic to update.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic updateMany
   */
  export type TopicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Topics.
     */
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyInput>
    /**
     * Filter which Topics to update
     */
    where?: TopicWhereInput
  }

  /**
   * Topic upsert
   */
  export type TopicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The filter to search for the Topic to update in case it exists.
     */
    where: TopicWhereUniqueInput
    /**
     * In case the Topic found by the `where` argument doesn't exist, create a new Topic with this data.
     */
    create: XOR<TopicCreateInput, TopicUncheckedCreateInput>
    /**
     * In case the Topic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TopicUpdateInput, TopicUncheckedUpdateInput>
  }

  /**
   * Topic delete
   */
  export type TopicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter which Topic to delete.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic deleteMany
   */
  export type TopicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Topics to delete
     */
    where?: TopicWhereInput
  }

  /**
   * Topic.doctorPointers
   */
  export type Topic$doctorPointersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPointer
     */
    select?: DoctorPointerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorPointerInclude<ExtArgs> | null
    where?: DoctorPointerWhereInput
    orderBy?: DoctorPointerOrderByWithRelationInput | DoctorPointerOrderByWithRelationInput[]
    cursor?: DoctorPointerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DoctorPointerScalarFieldEnum | DoctorPointerScalarFieldEnum[]
  }

  /**
   * Topic.scripts
   */
  export type Topic$scriptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Script
     */
    select?: ScriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScriptInclude<ExtArgs> | null
    where?: ScriptWhereInput
    orderBy?: ScriptOrderByWithRelationInput | ScriptOrderByWithRelationInput[]
    cursor?: ScriptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScriptScalarFieldEnum | ScriptScalarFieldEnum[]
  }

  /**
   * Topic.videos
   */
  export type Topic$videosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    where?: VideoWhereInput
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    cursor?: VideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Topic without action
   */
  export type TopicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
  }


  /**
   * Model DoctorPointer
   */

  export type AggregateDoctorPointer = {
    _count: DoctorPointerCountAggregateOutputType | null
    _min: DoctorPointerMinAggregateOutputType | null
    _max: DoctorPointerMaxAggregateOutputType | null
  }

  export type DoctorPointerMinAggregateOutputType = {
    id: string | null
    topicId: string | null
    doctorId: string | null
    notes: string | null
    fileUrl: string | null
    fileType: string | null
    createdAt: Date | null
  }

  export type DoctorPointerMaxAggregateOutputType = {
    id: string | null
    topicId: string | null
    doctorId: string | null
    notes: string | null
    fileUrl: string | null
    fileType: string | null
    createdAt: Date | null
  }

  export type DoctorPointerCountAggregateOutputType = {
    id: number
    topicId: number
    doctorId: number
    notes: number
    fileUrl: number
    fileType: number
    createdAt: number
    _all: number
  }


  export type DoctorPointerMinAggregateInputType = {
    id?: true
    topicId?: true
    doctorId?: true
    notes?: true
    fileUrl?: true
    fileType?: true
    createdAt?: true
  }

  export type DoctorPointerMaxAggregateInputType = {
    id?: true
    topicId?: true
    doctorId?: true
    notes?: true
    fileUrl?: true
    fileType?: true
    createdAt?: true
  }

  export type DoctorPointerCountAggregateInputType = {
    id?: true
    topicId?: true
    doctorId?: true
    notes?: true
    fileUrl?: true
    fileType?: true
    createdAt?: true
    _all?: true
  }

  export type DoctorPointerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoctorPointer to aggregate.
     */
    where?: DoctorPointerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorPointers to fetch.
     */
    orderBy?: DoctorPointerOrderByWithRelationInput | DoctorPointerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DoctorPointerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorPointers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorPointers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DoctorPointers
    **/
    _count?: true | DoctorPointerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DoctorPointerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DoctorPointerMaxAggregateInputType
  }

  export type GetDoctorPointerAggregateType<T extends DoctorPointerAggregateArgs> = {
        [P in keyof T & keyof AggregateDoctorPointer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoctorPointer[P]>
      : GetScalarType<T[P], AggregateDoctorPointer[P]>
  }




  export type DoctorPointerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorPointerWhereInput
    orderBy?: DoctorPointerOrderByWithAggregationInput | DoctorPointerOrderByWithAggregationInput[]
    by: DoctorPointerScalarFieldEnum[] | DoctorPointerScalarFieldEnum
    having?: DoctorPointerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DoctorPointerCountAggregateInputType | true
    _min?: DoctorPointerMinAggregateInputType
    _max?: DoctorPointerMaxAggregateInputType
  }

  export type DoctorPointerGroupByOutputType = {
    id: string
    topicId: string
    doctorId: string
    notes: string | null
    fileUrl: string | null
    fileType: string | null
    createdAt: Date
    _count: DoctorPointerCountAggregateOutputType | null
    _min: DoctorPointerMinAggregateOutputType | null
    _max: DoctorPointerMaxAggregateOutputType | null
  }

  type GetDoctorPointerGroupByPayload<T extends DoctorPointerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DoctorPointerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DoctorPointerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DoctorPointerGroupByOutputType[P]>
            : GetScalarType<T[P], DoctorPointerGroupByOutputType[P]>
        }
      >
    >


  export type DoctorPointerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topicId?: boolean
    doctorId?: boolean
    notes?: boolean
    fileUrl?: boolean
    fileType?: boolean
    createdAt?: boolean
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctorPointer"]>

  export type DoctorPointerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topicId?: boolean
    doctorId?: boolean
    notes?: boolean
    fileUrl?: boolean
    fileType?: boolean
    createdAt?: boolean
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctorPointer"]>

  export type DoctorPointerSelectScalar = {
    id?: boolean
    topicId?: boolean
    doctorId?: boolean
    notes?: boolean
    fileUrl?: boolean
    fileType?: boolean
    createdAt?: boolean
  }

  export type DoctorPointerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DoctorPointerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DoctorPointerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DoctorPointer"
    objects: {
      topic: Prisma.$TopicPayload<ExtArgs>
      doctor: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      topicId: string
      doctorId: string
      notes: string | null
      fileUrl: string | null
      fileType: string | null
      createdAt: Date
    }, ExtArgs["result"]["doctorPointer"]>
    composites: {}
  }

  type DoctorPointerGetPayload<S extends boolean | null | undefined | DoctorPointerDefaultArgs> = $Result.GetResult<Prisma.$DoctorPointerPayload, S>

  type DoctorPointerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DoctorPointerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DoctorPointerCountAggregateInputType | true
    }

  export interface DoctorPointerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DoctorPointer'], meta: { name: 'DoctorPointer' } }
    /**
     * Find zero or one DoctorPointer that matches the filter.
     * @param {DoctorPointerFindUniqueArgs} args - Arguments to find a DoctorPointer
     * @example
     * // Get one DoctorPointer
     * const doctorPointer = await prisma.doctorPointer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DoctorPointerFindUniqueArgs>(args: SelectSubset<T, DoctorPointerFindUniqueArgs<ExtArgs>>): Prisma__DoctorPointerClient<$Result.GetResult<Prisma.$DoctorPointerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DoctorPointer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DoctorPointerFindUniqueOrThrowArgs} args - Arguments to find a DoctorPointer
     * @example
     * // Get one DoctorPointer
     * const doctorPointer = await prisma.doctorPointer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DoctorPointerFindUniqueOrThrowArgs>(args: SelectSubset<T, DoctorPointerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DoctorPointerClient<$Result.GetResult<Prisma.$DoctorPointerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DoctorPointer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorPointerFindFirstArgs} args - Arguments to find a DoctorPointer
     * @example
     * // Get one DoctorPointer
     * const doctorPointer = await prisma.doctorPointer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DoctorPointerFindFirstArgs>(args?: SelectSubset<T, DoctorPointerFindFirstArgs<ExtArgs>>): Prisma__DoctorPointerClient<$Result.GetResult<Prisma.$DoctorPointerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DoctorPointer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorPointerFindFirstOrThrowArgs} args - Arguments to find a DoctorPointer
     * @example
     * // Get one DoctorPointer
     * const doctorPointer = await prisma.doctorPointer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DoctorPointerFindFirstOrThrowArgs>(args?: SelectSubset<T, DoctorPointerFindFirstOrThrowArgs<ExtArgs>>): Prisma__DoctorPointerClient<$Result.GetResult<Prisma.$DoctorPointerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DoctorPointers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorPointerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DoctorPointers
     * const doctorPointers = await prisma.doctorPointer.findMany()
     * 
     * // Get first 10 DoctorPointers
     * const doctorPointers = await prisma.doctorPointer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const doctorPointerWithIdOnly = await prisma.doctorPointer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DoctorPointerFindManyArgs>(args?: SelectSubset<T, DoctorPointerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorPointerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DoctorPointer.
     * @param {DoctorPointerCreateArgs} args - Arguments to create a DoctorPointer.
     * @example
     * // Create one DoctorPointer
     * const DoctorPointer = await prisma.doctorPointer.create({
     *   data: {
     *     // ... data to create a DoctorPointer
     *   }
     * })
     * 
     */
    create<T extends DoctorPointerCreateArgs>(args: SelectSubset<T, DoctorPointerCreateArgs<ExtArgs>>): Prisma__DoctorPointerClient<$Result.GetResult<Prisma.$DoctorPointerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DoctorPointers.
     * @param {DoctorPointerCreateManyArgs} args - Arguments to create many DoctorPointers.
     * @example
     * // Create many DoctorPointers
     * const doctorPointer = await prisma.doctorPointer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DoctorPointerCreateManyArgs>(args?: SelectSubset<T, DoctorPointerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DoctorPointers and returns the data saved in the database.
     * @param {DoctorPointerCreateManyAndReturnArgs} args - Arguments to create many DoctorPointers.
     * @example
     * // Create many DoctorPointers
     * const doctorPointer = await prisma.doctorPointer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DoctorPointers and only return the `id`
     * const doctorPointerWithIdOnly = await prisma.doctorPointer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DoctorPointerCreateManyAndReturnArgs>(args?: SelectSubset<T, DoctorPointerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorPointerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DoctorPointer.
     * @param {DoctorPointerDeleteArgs} args - Arguments to delete one DoctorPointer.
     * @example
     * // Delete one DoctorPointer
     * const DoctorPointer = await prisma.doctorPointer.delete({
     *   where: {
     *     // ... filter to delete one DoctorPointer
     *   }
     * })
     * 
     */
    delete<T extends DoctorPointerDeleteArgs>(args: SelectSubset<T, DoctorPointerDeleteArgs<ExtArgs>>): Prisma__DoctorPointerClient<$Result.GetResult<Prisma.$DoctorPointerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DoctorPointer.
     * @param {DoctorPointerUpdateArgs} args - Arguments to update one DoctorPointer.
     * @example
     * // Update one DoctorPointer
     * const doctorPointer = await prisma.doctorPointer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DoctorPointerUpdateArgs>(args: SelectSubset<T, DoctorPointerUpdateArgs<ExtArgs>>): Prisma__DoctorPointerClient<$Result.GetResult<Prisma.$DoctorPointerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DoctorPointers.
     * @param {DoctorPointerDeleteManyArgs} args - Arguments to filter DoctorPointers to delete.
     * @example
     * // Delete a few DoctorPointers
     * const { count } = await prisma.doctorPointer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DoctorPointerDeleteManyArgs>(args?: SelectSubset<T, DoctorPointerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DoctorPointers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorPointerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DoctorPointers
     * const doctorPointer = await prisma.doctorPointer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DoctorPointerUpdateManyArgs>(args: SelectSubset<T, DoctorPointerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DoctorPointer.
     * @param {DoctorPointerUpsertArgs} args - Arguments to update or create a DoctorPointer.
     * @example
     * // Update or create a DoctorPointer
     * const doctorPointer = await prisma.doctorPointer.upsert({
     *   create: {
     *     // ... data to create a DoctorPointer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DoctorPointer we want to update
     *   }
     * })
     */
    upsert<T extends DoctorPointerUpsertArgs>(args: SelectSubset<T, DoctorPointerUpsertArgs<ExtArgs>>): Prisma__DoctorPointerClient<$Result.GetResult<Prisma.$DoctorPointerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DoctorPointers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorPointerCountArgs} args - Arguments to filter DoctorPointers to count.
     * @example
     * // Count the number of DoctorPointers
     * const count = await prisma.doctorPointer.count({
     *   where: {
     *     // ... the filter for the DoctorPointers we want to count
     *   }
     * })
    **/
    count<T extends DoctorPointerCountArgs>(
      args?: Subset<T, DoctorPointerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DoctorPointerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DoctorPointer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorPointerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoctorPointerAggregateArgs>(args: Subset<T, DoctorPointerAggregateArgs>): Prisma.PrismaPromise<GetDoctorPointerAggregateType<T>>

    /**
     * Group by DoctorPointer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorPointerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DoctorPointerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DoctorPointerGroupByArgs['orderBy'] }
        : { orderBy?: DoctorPointerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DoctorPointerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoctorPointerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DoctorPointer model
   */
  readonly fields: DoctorPointerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DoctorPointer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DoctorPointerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    topic<T extends TopicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TopicDefaultArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    doctor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DoctorPointer model
   */ 
  interface DoctorPointerFieldRefs {
    readonly id: FieldRef<"DoctorPointer", 'String'>
    readonly topicId: FieldRef<"DoctorPointer", 'String'>
    readonly doctorId: FieldRef<"DoctorPointer", 'String'>
    readonly notes: FieldRef<"DoctorPointer", 'String'>
    readonly fileUrl: FieldRef<"DoctorPointer", 'String'>
    readonly fileType: FieldRef<"DoctorPointer", 'String'>
    readonly createdAt: FieldRef<"DoctorPointer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DoctorPointer findUnique
   */
  export type DoctorPointerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPointer
     */
    select?: DoctorPointerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorPointerInclude<ExtArgs> | null
    /**
     * Filter, which DoctorPointer to fetch.
     */
    where: DoctorPointerWhereUniqueInput
  }

  /**
   * DoctorPointer findUniqueOrThrow
   */
  export type DoctorPointerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPointer
     */
    select?: DoctorPointerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorPointerInclude<ExtArgs> | null
    /**
     * Filter, which DoctorPointer to fetch.
     */
    where: DoctorPointerWhereUniqueInput
  }

  /**
   * DoctorPointer findFirst
   */
  export type DoctorPointerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPointer
     */
    select?: DoctorPointerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorPointerInclude<ExtArgs> | null
    /**
     * Filter, which DoctorPointer to fetch.
     */
    where?: DoctorPointerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorPointers to fetch.
     */
    orderBy?: DoctorPointerOrderByWithRelationInput | DoctorPointerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoctorPointers.
     */
    cursor?: DoctorPointerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorPointers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorPointers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoctorPointers.
     */
    distinct?: DoctorPointerScalarFieldEnum | DoctorPointerScalarFieldEnum[]
  }

  /**
   * DoctorPointer findFirstOrThrow
   */
  export type DoctorPointerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPointer
     */
    select?: DoctorPointerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorPointerInclude<ExtArgs> | null
    /**
     * Filter, which DoctorPointer to fetch.
     */
    where?: DoctorPointerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorPointers to fetch.
     */
    orderBy?: DoctorPointerOrderByWithRelationInput | DoctorPointerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoctorPointers.
     */
    cursor?: DoctorPointerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorPointers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorPointers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoctorPointers.
     */
    distinct?: DoctorPointerScalarFieldEnum | DoctorPointerScalarFieldEnum[]
  }

  /**
   * DoctorPointer findMany
   */
  export type DoctorPointerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPointer
     */
    select?: DoctorPointerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorPointerInclude<ExtArgs> | null
    /**
     * Filter, which DoctorPointers to fetch.
     */
    where?: DoctorPointerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorPointers to fetch.
     */
    orderBy?: DoctorPointerOrderByWithRelationInput | DoctorPointerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DoctorPointers.
     */
    cursor?: DoctorPointerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorPointers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorPointers.
     */
    skip?: number
    distinct?: DoctorPointerScalarFieldEnum | DoctorPointerScalarFieldEnum[]
  }

  /**
   * DoctorPointer create
   */
  export type DoctorPointerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPointer
     */
    select?: DoctorPointerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorPointerInclude<ExtArgs> | null
    /**
     * The data needed to create a DoctorPointer.
     */
    data: XOR<DoctorPointerCreateInput, DoctorPointerUncheckedCreateInput>
  }

  /**
   * DoctorPointer createMany
   */
  export type DoctorPointerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DoctorPointers.
     */
    data: DoctorPointerCreateManyInput | DoctorPointerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DoctorPointer createManyAndReturn
   */
  export type DoctorPointerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPointer
     */
    select?: DoctorPointerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DoctorPointers.
     */
    data: DoctorPointerCreateManyInput | DoctorPointerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorPointerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DoctorPointer update
   */
  export type DoctorPointerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPointer
     */
    select?: DoctorPointerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorPointerInclude<ExtArgs> | null
    /**
     * The data needed to update a DoctorPointer.
     */
    data: XOR<DoctorPointerUpdateInput, DoctorPointerUncheckedUpdateInput>
    /**
     * Choose, which DoctorPointer to update.
     */
    where: DoctorPointerWhereUniqueInput
  }

  /**
   * DoctorPointer updateMany
   */
  export type DoctorPointerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DoctorPointers.
     */
    data: XOR<DoctorPointerUpdateManyMutationInput, DoctorPointerUncheckedUpdateManyInput>
    /**
     * Filter which DoctorPointers to update
     */
    where?: DoctorPointerWhereInput
  }

  /**
   * DoctorPointer upsert
   */
  export type DoctorPointerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPointer
     */
    select?: DoctorPointerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorPointerInclude<ExtArgs> | null
    /**
     * The filter to search for the DoctorPointer to update in case it exists.
     */
    where: DoctorPointerWhereUniqueInput
    /**
     * In case the DoctorPointer found by the `where` argument doesn't exist, create a new DoctorPointer with this data.
     */
    create: XOR<DoctorPointerCreateInput, DoctorPointerUncheckedCreateInput>
    /**
     * In case the DoctorPointer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoctorPointerUpdateInput, DoctorPointerUncheckedUpdateInput>
  }

  /**
   * DoctorPointer delete
   */
  export type DoctorPointerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPointer
     */
    select?: DoctorPointerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorPointerInclude<ExtArgs> | null
    /**
     * Filter which DoctorPointer to delete.
     */
    where: DoctorPointerWhereUniqueInput
  }

  /**
   * DoctorPointer deleteMany
   */
  export type DoctorPointerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoctorPointers to delete
     */
    where?: DoctorPointerWhereInput
  }

  /**
   * DoctorPointer without action
   */
  export type DoctorPointerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPointer
     */
    select?: DoctorPointerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorPointerInclude<ExtArgs> | null
  }


  /**
   * Model Script
   */

  export type AggregateScript = {
    _count: ScriptCountAggregateOutputType | null
    _avg: ScriptAvgAggregateOutputType | null
    _sum: ScriptSumAggregateOutputType | null
    _min: ScriptMinAggregateOutputType | null
    _max: ScriptMaxAggregateOutputType | null
  }

  export type ScriptAvgAggregateOutputType = {
    version: number | null
    qualityScore: number | null
  }

  export type ScriptSumAggregateOutputType = {
    version: number | null
    qualityScore: number | null
  }

  export type ScriptMinAggregateOutputType = {
    id: string | null
    topicId: string | null
    version: number | null
    content: string | null
    status: $Enums.ScriptStatus | null
    summary: string | null
    qualityScore: number | null
    aiProcessedAt: Date | null
    aiProcessingStatus: string | null
    uploadedById: string | null
    lockedById: string | null
    lockedAt: Date | null
    assignedReviewerId: string | null
    assignedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScriptMaxAggregateOutputType = {
    id: string | null
    topicId: string | null
    version: number | null
    content: string | null
    status: $Enums.ScriptStatus | null
    summary: string | null
    qualityScore: number | null
    aiProcessedAt: Date | null
    aiProcessingStatus: string | null
    uploadedById: string | null
    lockedById: string | null
    lockedAt: Date | null
    assignedReviewerId: string | null
    assignedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScriptCountAggregateOutputType = {
    id: number
    topicId: number
    version: number
    content: number
    status: number
    summary: number
    tags: number
    entities: number
    qualityScore: number
    aiProcessedAt: number
    aiProcessingStatus: number
    uploadedById: number
    lockedById: number
    lockedAt: number
    assignedReviewerId: number
    assignedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScriptAvgAggregateInputType = {
    version?: true
    qualityScore?: true
  }

  export type ScriptSumAggregateInputType = {
    version?: true
    qualityScore?: true
  }

  export type ScriptMinAggregateInputType = {
    id?: true
    topicId?: true
    version?: true
    content?: true
    status?: true
    summary?: true
    qualityScore?: true
    aiProcessedAt?: true
    aiProcessingStatus?: true
    uploadedById?: true
    lockedById?: true
    lockedAt?: true
    assignedReviewerId?: true
    assignedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScriptMaxAggregateInputType = {
    id?: true
    topicId?: true
    version?: true
    content?: true
    status?: true
    summary?: true
    qualityScore?: true
    aiProcessedAt?: true
    aiProcessingStatus?: true
    uploadedById?: true
    lockedById?: true
    lockedAt?: true
    assignedReviewerId?: true
    assignedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScriptCountAggregateInputType = {
    id?: true
    topicId?: true
    version?: true
    content?: true
    status?: true
    summary?: true
    tags?: true
    entities?: true
    qualityScore?: true
    aiProcessedAt?: true
    aiProcessingStatus?: true
    uploadedById?: true
    lockedById?: true
    lockedAt?: true
    assignedReviewerId?: true
    assignedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScriptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Script to aggregate.
     */
    where?: ScriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scripts to fetch.
     */
    orderBy?: ScriptOrderByWithRelationInput | ScriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scripts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Scripts
    **/
    _count?: true | ScriptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScriptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScriptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScriptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScriptMaxAggregateInputType
  }

  export type GetScriptAggregateType<T extends ScriptAggregateArgs> = {
        [P in keyof T & keyof AggregateScript]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScript[P]>
      : GetScalarType<T[P], AggregateScript[P]>
  }




  export type ScriptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScriptWhereInput
    orderBy?: ScriptOrderByWithAggregationInput | ScriptOrderByWithAggregationInput[]
    by: ScriptScalarFieldEnum[] | ScriptScalarFieldEnum
    having?: ScriptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScriptCountAggregateInputType | true
    _avg?: ScriptAvgAggregateInputType
    _sum?: ScriptSumAggregateInputType
    _min?: ScriptMinAggregateInputType
    _max?: ScriptMaxAggregateInputType
  }

  export type ScriptGroupByOutputType = {
    id: string
    topicId: string
    version: number
    content: string
    status: $Enums.ScriptStatus
    summary: string | null
    tags: string[]
    entities: JsonValue | null
    qualityScore: number | null
    aiProcessedAt: Date | null
    aiProcessingStatus: string | null
    uploadedById: string | null
    lockedById: string | null
    lockedAt: Date | null
    assignedReviewerId: string | null
    assignedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ScriptCountAggregateOutputType | null
    _avg: ScriptAvgAggregateOutputType | null
    _sum: ScriptSumAggregateOutputType | null
    _min: ScriptMinAggregateOutputType | null
    _max: ScriptMaxAggregateOutputType | null
  }

  type GetScriptGroupByPayload<T extends ScriptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScriptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScriptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScriptGroupByOutputType[P]>
            : GetScalarType<T[P], ScriptGroupByOutputType[P]>
        }
      >
    >


  export type ScriptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topicId?: boolean
    version?: boolean
    content?: boolean
    status?: boolean
    summary?: boolean
    tags?: boolean
    entities?: boolean
    qualityScore?: boolean
    aiProcessedAt?: boolean
    aiProcessingStatus?: boolean
    uploadedById?: boolean
    lockedById?: boolean
    lockedAt?: boolean
    assignedReviewerId?: boolean
    assignedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    uploadedBy?: boolean | Script$uploadedByArgs<ExtArgs>
    lockedBy?: boolean | Script$lockedByArgs<ExtArgs>
    assignedReviewer?: boolean | Script$assignedReviewerArgs<ExtArgs>
    reviews?: boolean | Script$reviewsArgs<ExtArgs>
    comments?: boolean | Script$commentsArgs<ExtArgs>
    videos?: boolean | Script$videosArgs<ExtArgs>
    _count?: boolean | ScriptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["script"]>

  export type ScriptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topicId?: boolean
    version?: boolean
    content?: boolean
    status?: boolean
    summary?: boolean
    tags?: boolean
    entities?: boolean
    qualityScore?: boolean
    aiProcessedAt?: boolean
    aiProcessingStatus?: boolean
    uploadedById?: boolean
    lockedById?: boolean
    lockedAt?: boolean
    assignedReviewerId?: boolean
    assignedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    uploadedBy?: boolean | Script$uploadedByArgs<ExtArgs>
    lockedBy?: boolean | Script$lockedByArgs<ExtArgs>
    assignedReviewer?: boolean | Script$assignedReviewerArgs<ExtArgs>
  }, ExtArgs["result"]["script"]>

  export type ScriptSelectScalar = {
    id?: boolean
    topicId?: boolean
    version?: boolean
    content?: boolean
    status?: boolean
    summary?: boolean
    tags?: boolean
    entities?: boolean
    qualityScore?: boolean
    aiProcessedAt?: boolean
    aiProcessingStatus?: boolean
    uploadedById?: boolean
    lockedById?: boolean
    lockedAt?: boolean
    assignedReviewerId?: boolean
    assignedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScriptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    uploadedBy?: boolean | Script$uploadedByArgs<ExtArgs>
    lockedBy?: boolean | Script$lockedByArgs<ExtArgs>
    assignedReviewer?: boolean | Script$assignedReviewerArgs<ExtArgs>
    reviews?: boolean | Script$reviewsArgs<ExtArgs>
    comments?: boolean | Script$commentsArgs<ExtArgs>
    videos?: boolean | Script$videosArgs<ExtArgs>
    _count?: boolean | ScriptCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ScriptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    uploadedBy?: boolean | Script$uploadedByArgs<ExtArgs>
    lockedBy?: boolean | Script$lockedByArgs<ExtArgs>
    assignedReviewer?: boolean | Script$assignedReviewerArgs<ExtArgs>
  }

  export type $ScriptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Script"
    objects: {
      topic: Prisma.$TopicPayload<ExtArgs>
      uploadedBy: Prisma.$UserPayload<ExtArgs> | null
      lockedBy: Prisma.$UserPayload<ExtArgs> | null
      assignedReviewer: Prisma.$UserPayload<ExtArgs> | null
      reviews: Prisma.$ScriptReviewPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      videos: Prisma.$VideoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      topicId: string
      version: number
      content: string
      status: $Enums.ScriptStatus
      summary: string | null
      tags: string[]
      entities: Prisma.JsonValue | null
      qualityScore: number | null
      aiProcessedAt: Date | null
      aiProcessingStatus: string | null
      uploadedById: string | null
      lockedById: string | null
      lockedAt: Date | null
      assignedReviewerId: string | null
      assignedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["script"]>
    composites: {}
  }

  type ScriptGetPayload<S extends boolean | null | undefined | ScriptDefaultArgs> = $Result.GetResult<Prisma.$ScriptPayload, S>

  type ScriptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ScriptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ScriptCountAggregateInputType | true
    }

  export interface ScriptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Script'], meta: { name: 'Script' } }
    /**
     * Find zero or one Script that matches the filter.
     * @param {ScriptFindUniqueArgs} args - Arguments to find a Script
     * @example
     * // Get one Script
     * const script = await prisma.script.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScriptFindUniqueArgs>(args: SelectSubset<T, ScriptFindUniqueArgs<ExtArgs>>): Prisma__ScriptClient<$Result.GetResult<Prisma.$ScriptPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Script that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ScriptFindUniqueOrThrowArgs} args - Arguments to find a Script
     * @example
     * // Get one Script
     * const script = await prisma.script.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScriptFindUniqueOrThrowArgs>(args: SelectSubset<T, ScriptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScriptClient<$Result.GetResult<Prisma.$ScriptPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Script that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScriptFindFirstArgs} args - Arguments to find a Script
     * @example
     * // Get one Script
     * const script = await prisma.script.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScriptFindFirstArgs>(args?: SelectSubset<T, ScriptFindFirstArgs<ExtArgs>>): Prisma__ScriptClient<$Result.GetResult<Prisma.$ScriptPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Script that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScriptFindFirstOrThrowArgs} args - Arguments to find a Script
     * @example
     * // Get one Script
     * const script = await prisma.script.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScriptFindFirstOrThrowArgs>(args?: SelectSubset<T, ScriptFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScriptClient<$Result.GetResult<Prisma.$ScriptPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Scripts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScriptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Scripts
     * const scripts = await prisma.script.findMany()
     * 
     * // Get first 10 Scripts
     * const scripts = await prisma.script.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scriptWithIdOnly = await prisma.script.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScriptFindManyArgs>(args?: SelectSubset<T, ScriptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScriptPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Script.
     * @param {ScriptCreateArgs} args - Arguments to create a Script.
     * @example
     * // Create one Script
     * const Script = await prisma.script.create({
     *   data: {
     *     // ... data to create a Script
     *   }
     * })
     * 
     */
    create<T extends ScriptCreateArgs>(args: SelectSubset<T, ScriptCreateArgs<ExtArgs>>): Prisma__ScriptClient<$Result.GetResult<Prisma.$ScriptPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Scripts.
     * @param {ScriptCreateManyArgs} args - Arguments to create many Scripts.
     * @example
     * // Create many Scripts
     * const script = await prisma.script.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScriptCreateManyArgs>(args?: SelectSubset<T, ScriptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Scripts and returns the data saved in the database.
     * @param {ScriptCreateManyAndReturnArgs} args - Arguments to create many Scripts.
     * @example
     * // Create many Scripts
     * const script = await prisma.script.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Scripts and only return the `id`
     * const scriptWithIdOnly = await prisma.script.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScriptCreateManyAndReturnArgs>(args?: SelectSubset<T, ScriptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScriptPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Script.
     * @param {ScriptDeleteArgs} args - Arguments to delete one Script.
     * @example
     * // Delete one Script
     * const Script = await prisma.script.delete({
     *   where: {
     *     // ... filter to delete one Script
     *   }
     * })
     * 
     */
    delete<T extends ScriptDeleteArgs>(args: SelectSubset<T, ScriptDeleteArgs<ExtArgs>>): Prisma__ScriptClient<$Result.GetResult<Prisma.$ScriptPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Script.
     * @param {ScriptUpdateArgs} args - Arguments to update one Script.
     * @example
     * // Update one Script
     * const script = await prisma.script.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScriptUpdateArgs>(args: SelectSubset<T, ScriptUpdateArgs<ExtArgs>>): Prisma__ScriptClient<$Result.GetResult<Prisma.$ScriptPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Scripts.
     * @param {ScriptDeleteManyArgs} args - Arguments to filter Scripts to delete.
     * @example
     * // Delete a few Scripts
     * const { count } = await prisma.script.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScriptDeleteManyArgs>(args?: SelectSubset<T, ScriptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Scripts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScriptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Scripts
     * const script = await prisma.script.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScriptUpdateManyArgs>(args: SelectSubset<T, ScriptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Script.
     * @param {ScriptUpsertArgs} args - Arguments to update or create a Script.
     * @example
     * // Update or create a Script
     * const script = await prisma.script.upsert({
     *   create: {
     *     // ... data to create a Script
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Script we want to update
     *   }
     * })
     */
    upsert<T extends ScriptUpsertArgs>(args: SelectSubset<T, ScriptUpsertArgs<ExtArgs>>): Prisma__ScriptClient<$Result.GetResult<Prisma.$ScriptPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Scripts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScriptCountArgs} args - Arguments to filter Scripts to count.
     * @example
     * // Count the number of Scripts
     * const count = await prisma.script.count({
     *   where: {
     *     // ... the filter for the Scripts we want to count
     *   }
     * })
    **/
    count<T extends ScriptCountArgs>(
      args?: Subset<T, ScriptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScriptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Script.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScriptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScriptAggregateArgs>(args: Subset<T, ScriptAggregateArgs>): Prisma.PrismaPromise<GetScriptAggregateType<T>>

    /**
     * Group by Script.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScriptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScriptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScriptGroupByArgs['orderBy'] }
        : { orderBy?: ScriptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScriptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScriptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Script model
   */
  readonly fields: ScriptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Script.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScriptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    topic<T extends TopicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TopicDefaultArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    uploadedBy<T extends Script$uploadedByArgs<ExtArgs> = {}>(args?: Subset<T, Script$uploadedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    lockedBy<T extends Script$lockedByArgs<ExtArgs> = {}>(args?: Subset<T, Script$lockedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    assignedReviewer<T extends Script$assignedReviewerArgs<ExtArgs> = {}>(args?: Subset<T, Script$assignedReviewerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    reviews<T extends Script$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Script$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScriptReviewPayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends Script$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Script$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    videos<T extends Script$videosArgs<ExtArgs> = {}>(args?: Subset<T, Script$videosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Script model
   */ 
  interface ScriptFieldRefs {
    readonly id: FieldRef<"Script", 'String'>
    readonly topicId: FieldRef<"Script", 'String'>
    readonly version: FieldRef<"Script", 'Int'>
    readonly content: FieldRef<"Script", 'String'>
    readonly status: FieldRef<"Script", 'ScriptStatus'>
    readonly summary: FieldRef<"Script", 'String'>
    readonly tags: FieldRef<"Script", 'String[]'>
    readonly entities: FieldRef<"Script", 'Json'>
    readonly qualityScore: FieldRef<"Script", 'Int'>
    readonly aiProcessedAt: FieldRef<"Script", 'DateTime'>
    readonly aiProcessingStatus: FieldRef<"Script", 'String'>
    readonly uploadedById: FieldRef<"Script", 'String'>
    readonly lockedById: FieldRef<"Script", 'String'>
    readonly lockedAt: FieldRef<"Script", 'DateTime'>
    readonly assignedReviewerId: FieldRef<"Script", 'String'>
    readonly assignedAt: FieldRef<"Script", 'DateTime'>
    readonly createdAt: FieldRef<"Script", 'DateTime'>
    readonly updatedAt: FieldRef<"Script", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Script findUnique
   */
  export type ScriptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Script
     */
    select?: ScriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScriptInclude<ExtArgs> | null
    /**
     * Filter, which Script to fetch.
     */
    where: ScriptWhereUniqueInput
  }

  /**
   * Script findUniqueOrThrow
   */
  export type ScriptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Script
     */
    select?: ScriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScriptInclude<ExtArgs> | null
    /**
     * Filter, which Script to fetch.
     */
    where: ScriptWhereUniqueInput
  }

  /**
   * Script findFirst
   */
  export type ScriptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Script
     */
    select?: ScriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScriptInclude<ExtArgs> | null
    /**
     * Filter, which Script to fetch.
     */
    where?: ScriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scripts to fetch.
     */
    orderBy?: ScriptOrderByWithRelationInput | ScriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Scripts.
     */
    cursor?: ScriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scripts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Scripts.
     */
    distinct?: ScriptScalarFieldEnum | ScriptScalarFieldEnum[]
  }

  /**
   * Script findFirstOrThrow
   */
  export type ScriptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Script
     */
    select?: ScriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScriptInclude<ExtArgs> | null
    /**
     * Filter, which Script to fetch.
     */
    where?: ScriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scripts to fetch.
     */
    orderBy?: ScriptOrderByWithRelationInput | ScriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Scripts.
     */
    cursor?: ScriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scripts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Scripts.
     */
    distinct?: ScriptScalarFieldEnum | ScriptScalarFieldEnum[]
  }

  /**
   * Script findMany
   */
  export type ScriptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Script
     */
    select?: ScriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScriptInclude<ExtArgs> | null
    /**
     * Filter, which Scripts to fetch.
     */
    where?: ScriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scripts to fetch.
     */
    orderBy?: ScriptOrderByWithRelationInput | ScriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Scripts.
     */
    cursor?: ScriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scripts.
     */
    skip?: number
    distinct?: ScriptScalarFieldEnum | ScriptScalarFieldEnum[]
  }

  /**
   * Script create
   */
  export type ScriptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Script
     */
    select?: ScriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScriptInclude<ExtArgs> | null
    /**
     * The data needed to create a Script.
     */
    data: XOR<ScriptCreateInput, ScriptUncheckedCreateInput>
  }

  /**
   * Script createMany
   */
  export type ScriptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Scripts.
     */
    data: ScriptCreateManyInput | ScriptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Script createManyAndReturn
   */
  export type ScriptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Script
     */
    select?: ScriptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Scripts.
     */
    data: ScriptCreateManyInput | ScriptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScriptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Script update
   */
  export type ScriptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Script
     */
    select?: ScriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScriptInclude<ExtArgs> | null
    /**
     * The data needed to update a Script.
     */
    data: XOR<ScriptUpdateInput, ScriptUncheckedUpdateInput>
    /**
     * Choose, which Script to update.
     */
    where: ScriptWhereUniqueInput
  }

  /**
   * Script updateMany
   */
  export type ScriptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Scripts.
     */
    data: XOR<ScriptUpdateManyMutationInput, ScriptUncheckedUpdateManyInput>
    /**
     * Filter which Scripts to update
     */
    where?: ScriptWhereInput
  }

  /**
   * Script upsert
   */
  export type ScriptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Script
     */
    select?: ScriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScriptInclude<ExtArgs> | null
    /**
     * The filter to search for the Script to update in case it exists.
     */
    where: ScriptWhereUniqueInput
    /**
     * In case the Script found by the `where` argument doesn't exist, create a new Script with this data.
     */
    create: XOR<ScriptCreateInput, ScriptUncheckedCreateInput>
    /**
     * In case the Script was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScriptUpdateInput, ScriptUncheckedUpdateInput>
  }

  /**
   * Script delete
   */
  export type ScriptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Script
     */
    select?: ScriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScriptInclude<ExtArgs> | null
    /**
     * Filter which Script to delete.
     */
    where: ScriptWhereUniqueInput
  }

  /**
   * Script deleteMany
   */
  export type ScriptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Scripts to delete
     */
    where?: ScriptWhereInput
  }

  /**
   * Script.uploadedBy
   */
  export type Script$uploadedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Script.lockedBy
   */
  export type Script$lockedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Script.assignedReviewer
   */
  export type Script$assignedReviewerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Script.reviews
   */
  export type Script$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScriptReview
     */
    select?: ScriptReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScriptReviewInclude<ExtArgs> | null
    where?: ScriptReviewWhereInput
    orderBy?: ScriptReviewOrderByWithRelationInput | ScriptReviewOrderByWithRelationInput[]
    cursor?: ScriptReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScriptReviewScalarFieldEnum | ScriptReviewScalarFieldEnum[]
  }

  /**
   * Script.comments
   */
  export type Script$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Script.videos
   */
  export type Script$videosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    where?: VideoWhereInput
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    cursor?: VideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Script without action
   */
  export type ScriptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Script
     */
    select?: ScriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScriptInclude<ExtArgs> | null
  }


  /**
   * Model ScriptReview
   */

  export type AggregateScriptReview = {
    _count: ScriptReviewCountAggregateOutputType | null
    _min: ScriptReviewMinAggregateOutputType | null
    _max: ScriptReviewMaxAggregateOutputType | null
  }

  export type ScriptReviewMinAggregateOutputType = {
    id: string | null
    scriptId: string | null
    reviewerId: string | null
    reviewerType: $Enums.UserRole | null
    decision: $Enums.ReviewDecision | null
    comments: string | null
    reviewedAt: Date | null
    createdAt: Date | null
  }

  export type ScriptReviewMaxAggregateOutputType = {
    id: string | null
    scriptId: string | null
    reviewerId: string | null
    reviewerType: $Enums.UserRole | null
    decision: $Enums.ReviewDecision | null
    comments: string | null
    reviewedAt: Date | null
    createdAt: Date | null
  }

  export type ScriptReviewCountAggregateOutputType = {
    id: number
    scriptId: number
    reviewerId: number
    reviewerType: number
    decision: number
    comments: number
    reviewedAt: number
    createdAt: number
    _all: number
  }


  export type ScriptReviewMinAggregateInputType = {
    id?: true
    scriptId?: true
    reviewerId?: true
    reviewerType?: true
    decision?: true
    comments?: true
    reviewedAt?: true
    createdAt?: true
  }

  export type ScriptReviewMaxAggregateInputType = {
    id?: true
    scriptId?: true
    reviewerId?: true
    reviewerType?: true
    decision?: true
    comments?: true
    reviewedAt?: true
    createdAt?: true
  }

  export type ScriptReviewCountAggregateInputType = {
    id?: true
    scriptId?: true
    reviewerId?: true
    reviewerType?: true
    decision?: true
    comments?: true
    reviewedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ScriptReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScriptReview to aggregate.
     */
    where?: ScriptReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScriptReviews to fetch.
     */
    orderBy?: ScriptReviewOrderByWithRelationInput | ScriptReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScriptReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScriptReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScriptReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScriptReviews
    **/
    _count?: true | ScriptReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScriptReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScriptReviewMaxAggregateInputType
  }

  export type GetScriptReviewAggregateType<T extends ScriptReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateScriptReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScriptReview[P]>
      : GetScalarType<T[P], AggregateScriptReview[P]>
  }




  export type ScriptReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScriptReviewWhereInput
    orderBy?: ScriptReviewOrderByWithAggregationInput | ScriptReviewOrderByWithAggregationInput[]
    by: ScriptReviewScalarFieldEnum[] | ScriptReviewScalarFieldEnum
    having?: ScriptReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScriptReviewCountAggregateInputType | true
    _min?: ScriptReviewMinAggregateInputType
    _max?: ScriptReviewMaxAggregateInputType
  }

  export type ScriptReviewGroupByOutputType = {
    id: string
    scriptId: string
    reviewerId: string
    reviewerType: $Enums.UserRole
    decision: $Enums.ReviewDecision
    comments: string | null
    reviewedAt: Date | null
    createdAt: Date
    _count: ScriptReviewCountAggregateOutputType | null
    _min: ScriptReviewMinAggregateOutputType | null
    _max: ScriptReviewMaxAggregateOutputType | null
  }

  type GetScriptReviewGroupByPayload<T extends ScriptReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScriptReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScriptReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScriptReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ScriptReviewGroupByOutputType[P]>
        }
      >
    >


  export type ScriptReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scriptId?: boolean
    reviewerId?: boolean
    reviewerType?: boolean
    decision?: boolean
    comments?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    script?: boolean | ScriptDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scriptReview"]>

  export type ScriptReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scriptId?: boolean
    reviewerId?: boolean
    reviewerType?: boolean
    decision?: boolean
    comments?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    script?: boolean | ScriptDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scriptReview"]>

  export type ScriptReviewSelectScalar = {
    id?: boolean
    scriptId?: boolean
    reviewerId?: boolean
    reviewerType?: boolean
    decision?: boolean
    comments?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
  }

  export type ScriptReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    script?: boolean | ScriptDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ScriptReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    script?: boolean | ScriptDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ScriptReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScriptReview"
    objects: {
      script: Prisma.$ScriptPayload<ExtArgs>
      reviewer: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      scriptId: string
      reviewerId: string
      reviewerType: $Enums.UserRole
      decision: $Enums.ReviewDecision
      comments: string | null
      reviewedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["scriptReview"]>
    composites: {}
  }

  type ScriptReviewGetPayload<S extends boolean | null | undefined | ScriptReviewDefaultArgs> = $Result.GetResult<Prisma.$ScriptReviewPayload, S>

  type ScriptReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ScriptReviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ScriptReviewCountAggregateInputType | true
    }

  export interface ScriptReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScriptReview'], meta: { name: 'ScriptReview' } }
    /**
     * Find zero or one ScriptReview that matches the filter.
     * @param {ScriptReviewFindUniqueArgs} args - Arguments to find a ScriptReview
     * @example
     * // Get one ScriptReview
     * const scriptReview = await prisma.scriptReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScriptReviewFindUniqueArgs>(args: SelectSubset<T, ScriptReviewFindUniqueArgs<ExtArgs>>): Prisma__ScriptReviewClient<$Result.GetResult<Prisma.$ScriptReviewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ScriptReview that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ScriptReviewFindUniqueOrThrowArgs} args - Arguments to find a ScriptReview
     * @example
     * // Get one ScriptReview
     * const scriptReview = await prisma.scriptReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScriptReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ScriptReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScriptReviewClient<$Result.GetResult<Prisma.$ScriptReviewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ScriptReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScriptReviewFindFirstArgs} args - Arguments to find a ScriptReview
     * @example
     * // Get one ScriptReview
     * const scriptReview = await prisma.scriptReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScriptReviewFindFirstArgs>(args?: SelectSubset<T, ScriptReviewFindFirstArgs<ExtArgs>>): Prisma__ScriptReviewClient<$Result.GetResult<Prisma.$ScriptReviewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ScriptReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScriptReviewFindFirstOrThrowArgs} args - Arguments to find a ScriptReview
     * @example
     * // Get one ScriptReview
     * const scriptReview = await prisma.scriptReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScriptReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ScriptReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScriptReviewClient<$Result.GetResult<Prisma.$ScriptReviewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ScriptReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScriptReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScriptReviews
     * const scriptReviews = await prisma.scriptReview.findMany()
     * 
     * // Get first 10 ScriptReviews
     * const scriptReviews = await prisma.scriptReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scriptReviewWithIdOnly = await prisma.scriptReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScriptReviewFindManyArgs>(args?: SelectSubset<T, ScriptReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScriptReviewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ScriptReview.
     * @param {ScriptReviewCreateArgs} args - Arguments to create a ScriptReview.
     * @example
     * // Create one ScriptReview
     * const ScriptReview = await prisma.scriptReview.create({
     *   data: {
     *     // ... data to create a ScriptReview
     *   }
     * })
     * 
     */
    create<T extends ScriptReviewCreateArgs>(args: SelectSubset<T, ScriptReviewCreateArgs<ExtArgs>>): Prisma__ScriptReviewClient<$Result.GetResult<Prisma.$ScriptReviewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ScriptReviews.
     * @param {ScriptReviewCreateManyArgs} args - Arguments to create many ScriptReviews.
     * @example
     * // Create many ScriptReviews
     * const scriptReview = await prisma.scriptReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScriptReviewCreateManyArgs>(args?: SelectSubset<T, ScriptReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScriptReviews and returns the data saved in the database.
     * @param {ScriptReviewCreateManyAndReturnArgs} args - Arguments to create many ScriptReviews.
     * @example
     * // Create many ScriptReviews
     * const scriptReview = await prisma.scriptReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScriptReviews and only return the `id`
     * const scriptReviewWithIdOnly = await prisma.scriptReview.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScriptReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ScriptReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScriptReviewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ScriptReview.
     * @param {ScriptReviewDeleteArgs} args - Arguments to delete one ScriptReview.
     * @example
     * // Delete one ScriptReview
     * const ScriptReview = await prisma.scriptReview.delete({
     *   where: {
     *     // ... filter to delete one ScriptReview
     *   }
     * })
     * 
     */
    delete<T extends ScriptReviewDeleteArgs>(args: SelectSubset<T, ScriptReviewDeleteArgs<ExtArgs>>): Prisma__ScriptReviewClient<$Result.GetResult<Prisma.$ScriptReviewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ScriptReview.
     * @param {ScriptReviewUpdateArgs} args - Arguments to update one ScriptReview.
     * @example
     * // Update one ScriptReview
     * const scriptReview = await prisma.scriptReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScriptReviewUpdateArgs>(args: SelectSubset<T, ScriptReviewUpdateArgs<ExtArgs>>): Prisma__ScriptReviewClient<$Result.GetResult<Prisma.$ScriptReviewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ScriptReviews.
     * @param {ScriptReviewDeleteManyArgs} args - Arguments to filter ScriptReviews to delete.
     * @example
     * // Delete a few ScriptReviews
     * const { count } = await prisma.scriptReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScriptReviewDeleteManyArgs>(args?: SelectSubset<T, ScriptReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScriptReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScriptReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScriptReviews
     * const scriptReview = await prisma.scriptReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScriptReviewUpdateManyArgs>(args: SelectSubset<T, ScriptReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ScriptReview.
     * @param {ScriptReviewUpsertArgs} args - Arguments to update or create a ScriptReview.
     * @example
     * // Update or create a ScriptReview
     * const scriptReview = await prisma.scriptReview.upsert({
     *   create: {
     *     // ... data to create a ScriptReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScriptReview we want to update
     *   }
     * })
     */
    upsert<T extends ScriptReviewUpsertArgs>(args: SelectSubset<T, ScriptReviewUpsertArgs<ExtArgs>>): Prisma__ScriptReviewClient<$Result.GetResult<Prisma.$ScriptReviewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ScriptReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScriptReviewCountArgs} args - Arguments to filter ScriptReviews to count.
     * @example
     * // Count the number of ScriptReviews
     * const count = await prisma.scriptReview.count({
     *   where: {
     *     // ... the filter for the ScriptReviews we want to count
     *   }
     * })
    **/
    count<T extends ScriptReviewCountArgs>(
      args?: Subset<T, ScriptReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScriptReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScriptReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScriptReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScriptReviewAggregateArgs>(args: Subset<T, ScriptReviewAggregateArgs>): Prisma.PrismaPromise<GetScriptReviewAggregateType<T>>

    /**
     * Group by ScriptReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScriptReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScriptReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScriptReviewGroupByArgs['orderBy'] }
        : { orderBy?: ScriptReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScriptReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScriptReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScriptReview model
   */
  readonly fields: ScriptReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScriptReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScriptReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    script<T extends ScriptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ScriptDefaultArgs<ExtArgs>>): Prisma__ScriptClient<$Result.GetResult<Prisma.$ScriptPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    reviewer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScriptReview model
   */ 
  interface ScriptReviewFieldRefs {
    readonly id: FieldRef<"ScriptReview", 'String'>
    readonly scriptId: FieldRef<"ScriptReview", 'String'>
    readonly reviewerId: FieldRef<"ScriptReview", 'String'>
    readonly reviewerType: FieldRef<"ScriptReview", 'UserRole'>
    readonly decision: FieldRef<"ScriptReview", 'ReviewDecision'>
    readonly comments: FieldRef<"ScriptReview", 'String'>
    readonly reviewedAt: FieldRef<"ScriptReview", 'DateTime'>
    readonly createdAt: FieldRef<"ScriptReview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScriptReview findUnique
   */
  export type ScriptReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScriptReview
     */
    select?: ScriptReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScriptReviewInclude<ExtArgs> | null
    /**
     * Filter, which ScriptReview to fetch.
     */
    where: ScriptReviewWhereUniqueInput
  }

  /**
   * ScriptReview findUniqueOrThrow
   */
  export type ScriptReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScriptReview
     */
    select?: ScriptReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScriptReviewInclude<ExtArgs> | null
    /**
     * Filter, which ScriptReview to fetch.
     */
    where: ScriptReviewWhereUniqueInput
  }

  /**
   * ScriptReview findFirst
   */
  export type ScriptReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScriptReview
     */
    select?: ScriptReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScriptReviewInclude<ExtArgs> | null
    /**
     * Filter, which ScriptReview to fetch.
     */
    where?: ScriptReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScriptReviews to fetch.
     */
    orderBy?: ScriptReviewOrderByWithRelationInput | ScriptReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScriptReviews.
     */
    cursor?: ScriptReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScriptReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScriptReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScriptReviews.
     */
    distinct?: ScriptReviewScalarFieldEnum | ScriptReviewScalarFieldEnum[]
  }

  /**
   * ScriptReview findFirstOrThrow
   */
  export type ScriptReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScriptReview
     */
    select?: ScriptReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScriptReviewInclude<ExtArgs> | null
    /**
     * Filter, which ScriptReview to fetch.
     */
    where?: ScriptReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScriptReviews to fetch.
     */
    orderBy?: ScriptReviewOrderByWithRelationInput | ScriptReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScriptReviews.
     */
    cursor?: ScriptReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScriptReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScriptReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScriptReviews.
     */
    distinct?: ScriptReviewScalarFieldEnum | ScriptReviewScalarFieldEnum[]
  }

  /**
   * ScriptReview findMany
   */
  export type ScriptReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScriptReview
     */
    select?: ScriptReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScriptReviewInclude<ExtArgs> | null
    /**
     * Filter, which ScriptReviews to fetch.
     */
    where?: ScriptReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScriptReviews to fetch.
     */
    orderBy?: ScriptReviewOrderByWithRelationInput | ScriptReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScriptReviews.
     */
    cursor?: ScriptReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScriptReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScriptReviews.
     */
    skip?: number
    distinct?: ScriptReviewScalarFieldEnum | ScriptReviewScalarFieldEnum[]
  }

  /**
   * ScriptReview create
   */
  export type ScriptReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScriptReview
     */
    select?: ScriptReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScriptReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a ScriptReview.
     */
    data: XOR<ScriptReviewCreateInput, ScriptReviewUncheckedCreateInput>
  }

  /**
   * ScriptReview createMany
   */
  export type ScriptReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScriptReviews.
     */
    data: ScriptReviewCreateManyInput | ScriptReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScriptReview createManyAndReturn
   */
  export type ScriptReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScriptReview
     */
    select?: ScriptReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ScriptReviews.
     */
    data: ScriptReviewCreateManyInput | ScriptReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScriptReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScriptReview update
   */
  export type ScriptReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScriptReview
     */
    select?: ScriptReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScriptReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a ScriptReview.
     */
    data: XOR<ScriptReviewUpdateInput, ScriptReviewUncheckedUpdateInput>
    /**
     * Choose, which ScriptReview to update.
     */
    where: ScriptReviewWhereUniqueInput
  }

  /**
   * ScriptReview updateMany
   */
  export type ScriptReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScriptReviews.
     */
    data: XOR<ScriptReviewUpdateManyMutationInput, ScriptReviewUncheckedUpdateManyInput>
    /**
     * Filter which ScriptReviews to update
     */
    where?: ScriptReviewWhereInput
  }

  /**
   * ScriptReview upsert
   */
  export type ScriptReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScriptReview
     */
    select?: ScriptReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScriptReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the ScriptReview to update in case it exists.
     */
    where: ScriptReviewWhereUniqueInput
    /**
     * In case the ScriptReview found by the `where` argument doesn't exist, create a new ScriptReview with this data.
     */
    create: XOR<ScriptReviewCreateInput, ScriptReviewUncheckedCreateInput>
    /**
     * In case the ScriptReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScriptReviewUpdateInput, ScriptReviewUncheckedUpdateInput>
  }

  /**
   * ScriptReview delete
   */
  export type ScriptReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScriptReview
     */
    select?: ScriptReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScriptReviewInclude<ExtArgs> | null
    /**
     * Filter which ScriptReview to delete.
     */
    where: ScriptReviewWhereUniqueInput
  }

  /**
   * ScriptReview deleteMany
   */
  export type ScriptReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScriptReviews to delete
     */
    where?: ScriptReviewWhereInput
  }

  /**
   * ScriptReview without action
   */
  export type ScriptReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScriptReview
     */
    select?: ScriptReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScriptReviewInclude<ExtArgs> | null
  }


  /**
   * Model Video
   */

  export type AggregateVideo = {
    _count: VideoCountAggregateOutputType | null
    _avg: VideoAvgAggregateOutputType | null
    _sum: VideoSumAggregateOutputType | null
    _min: VideoMinAggregateOutputType | null
    _max: VideoMaxAggregateOutputType | null
  }

  export type VideoAvgAggregateOutputType = {
    duration: number | null
    fileSize: number | null
    qualityScore: number | null
    version: number | null
    viewCount: number | null
  }

  export type VideoSumAggregateOutputType = {
    duration: number | null
    fileSize: bigint | null
    qualityScore: number | null
    version: number | null
    viewCount: number | null
  }

  export type VideoMinAggregateOutputType = {
    id: string | null
    topicId: string | null
    scriptId: string | null
    title: string | null
    description: string | null
    videoUrl: string | null
    thumbnailUrl: string | null
    duration: number | null
    fileSize: bigint | null
    doctorName: string | null
    specialty: string | null
    language: string | null
    city: string | null
    ctaType: $Enums.CTAType | null
    transcript: string | null
    transcriptUrl: string | null
    summary: string | null
    shortSummary: string | null
    qualityScore: number | null
    aiProcessedAt: Date | null
    aiProcessingStatus: string | null
    status: $Enums.VideoStatus | null
    version: number | null
    uploadedById: string | null
    lockedById: string | null
    lockedAt: Date | null
    publishedById: string | null
    publishedAt: Date | null
    assignedReviewerId: string | null
    assignedAt: Date | null
    deepLink: string | null
    viewCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoMaxAggregateOutputType = {
    id: string | null
    topicId: string | null
    scriptId: string | null
    title: string | null
    description: string | null
    videoUrl: string | null
    thumbnailUrl: string | null
    duration: number | null
    fileSize: bigint | null
    doctorName: string | null
    specialty: string | null
    language: string | null
    city: string | null
    ctaType: $Enums.CTAType | null
    transcript: string | null
    transcriptUrl: string | null
    summary: string | null
    shortSummary: string | null
    qualityScore: number | null
    aiProcessedAt: Date | null
    aiProcessingStatus: string | null
    status: $Enums.VideoStatus | null
    version: number | null
    uploadedById: string | null
    lockedById: string | null
    lockedAt: Date | null
    publishedById: string | null
    publishedAt: Date | null
    assignedReviewerId: string | null
    assignedAt: Date | null
    deepLink: string | null
    viewCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoCountAggregateOutputType = {
    id: number
    topicId: number
    scriptId: number
    title: number
    description: number
    videoUrl: number
    thumbnailUrl: number
    duration: number
    fileSize: number
    doctorName: number
    specialty: number
    language: number
    city: number
    ctaType: number
    tags: number
    transcript: number
    transcriptUrl: number
    summary: number
    shortSummary: number
    keyTakeaways: number
    entities: number
    qualityScore: number
    relatedVideoIds: number
    aiProcessedAt: number
    aiProcessingStatus: number
    status: number
    version: number
    uploadedById: number
    lockedById: number
    lockedAt: number
    publishedById: number
    publishedAt: number
    assignedReviewerId: number
    assignedAt: number
    deepLink: number
    viewCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VideoAvgAggregateInputType = {
    duration?: true
    fileSize?: true
    qualityScore?: true
    version?: true
    viewCount?: true
  }

  export type VideoSumAggregateInputType = {
    duration?: true
    fileSize?: true
    qualityScore?: true
    version?: true
    viewCount?: true
  }

  export type VideoMinAggregateInputType = {
    id?: true
    topicId?: true
    scriptId?: true
    title?: true
    description?: true
    videoUrl?: true
    thumbnailUrl?: true
    duration?: true
    fileSize?: true
    doctorName?: true
    specialty?: true
    language?: true
    city?: true
    ctaType?: true
    transcript?: true
    transcriptUrl?: true
    summary?: true
    shortSummary?: true
    qualityScore?: true
    aiProcessedAt?: true
    aiProcessingStatus?: true
    status?: true
    version?: true
    uploadedById?: true
    lockedById?: true
    lockedAt?: true
    publishedById?: true
    publishedAt?: true
    assignedReviewerId?: true
    assignedAt?: true
    deepLink?: true
    viewCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoMaxAggregateInputType = {
    id?: true
    topicId?: true
    scriptId?: true
    title?: true
    description?: true
    videoUrl?: true
    thumbnailUrl?: true
    duration?: true
    fileSize?: true
    doctorName?: true
    specialty?: true
    language?: true
    city?: true
    ctaType?: true
    transcript?: true
    transcriptUrl?: true
    summary?: true
    shortSummary?: true
    qualityScore?: true
    aiProcessedAt?: true
    aiProcessingStatus?: true
    status?: true
    version?: true
    uploadedById?: true
    lockedById?: true
    lockedAt?: true
    publishedById?: true
    publishedAt?: true
    assignedReviewerId?: true
    assignedAt?: true
    deepLink?: true
    viewCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoCountAggregateInputType = {
    id?: true
    topicId?: true
    scriptId?: true
    title?: true
    description?: true
    videoUrl?: true
    thumbnailUrl?: true
    duration?: true
    fileSize?: true
    doctorName?: true
    specialty?: true
    language?: true
    city?: true
    ctaType?: true
    tags?: true
    transcript?: true
    transcriptUrl?: true
    summary?: true
    shortSummary?: true
    keyTakeaways?: true
    entities?: true
    qualityScore?: true
    relatedVideoIds?: true
    aiProcessedAt?: true
    aiProcessingStatus?: true
    status?: true
    version?: true
    uploadedById?: true
    lockedById?: true
    lockedAt?: true
    publishedById?: true
    publishedAt?: true
    assignedReviewerId?: true
    assignedAt?: true
    deepLink?: true
    viewCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VideoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Video to aggregate.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Videos
    **/
    _count?: true | VideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoMaxAggregateInputType
  }

  export type GetVideoAggregateType<T extends VideoAggregateArgs> = {
        [P in keyof T & keyof AggregateVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideo[P]>
      : GetScalarType<T[P], AggregateVideo[P]>
  }




  export type VideoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoWhereInput
    orderBy?: VideoOrderByWithAggregationInput | VideoOrderByWithAggregationInput[]
    by: VideoScalarFieldEnum[] | VideoScalarFieldEnum
    having?: VideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoCountAggregateInputType | true
    _avg?: VideoAvgAggregateInputType
    _sum?: VideoSumAggregateInputType
    _min?: VideoMinAggregateInputType
    _max?: VideoMaxAggregateInputType
  }

  export type VideoGroupByOutputType = {
    id: string
    topicId: string
    scriptId: string | null
    title: string
    description: string | null
    videoUrl: string
    thumbnailUrl: string | null
    duration: number | null
    fileSize: bigint | null
    doctorName: string
    specialty: string
    language: string
    city: string
    ctaType: $Enums.CTAType
    tags: string[]
    transcript: string | null
    transcriptUrl: string | null
    summary: string | null
    shortSummary: string | null
    keyTakeaways: string[]
    entities: JsonValue | null
    qualityScore: number | null
    relatedVideoIds: string[]
    aiProcessedAt: Date | null
    aiProcessingStatus: string | null
    status: $Enums.VideoStatus
    version: number
    uploadedById: string | null
    lockedById: string | null
    lockedAt: Date | null
    publishedById: string | null
    publishedAt: Date | null
    assignedReviewerId: string | null
    assignedAt: Date | null
    deepLink: string | null
    viewCount: number
    createdAt: Date
    updatedAt: Date
    _count: VideoCountAggregateOutputType | null
    _avg: VideoAvgAggregateOutputType | null
    _sum: VideoSumAggregateOutputType | null
    _min: VideoMinAggregateOutputType | null
    _max: VideoMaxAggregateOutputType | null
  }

  type GetVideoGroupByPayload<T extends VideoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoGroupByOutputType[P]>
            : GetScalarType<T[P], VideoGroupByOutputType[P]>
        }
      >
    >


  export type VideoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topicId?: boolean
    scriptId?: boolean
    title?: boolean
    description?: boolean
    videoUrl?: boolean
    thumbnailUrl?: boolean
    duration?: boolean
    fileSize?: boolean
    doctorName?: boolean
    specialty?: boolean
    language?: boolean
    city?: boolean
    ctaType?: boolean
    tags?: boolean
    transcript?: boolean
    transcriptUrl?: boolean
    summary?: boolean
    shortSummary?: boolean
    keyTakeaways?: boolean
    entities?: boolean
    qualityScore?: boolean
    relatedVideoIds?: boolean
    aiProcessedAt?: boolean
    aiProcessingStatus?: boolean
    status?: boolean
    version?: boolean
    uploadedById?: boolean
    lockedById?: boolean
    lockedAt?: boolean
    publishedById?: boolean
    publishedAt?: boolean
    assignedReviewerId?: boolean
    assignedAt?: boolean
    deepLink?: boolean
    viewCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    script?: boolean | Video$scriptArgs<ExtArgs>
    uploadedBy?: boolean | Video$uploadedByArgs<ExtArgs>
    lockedBy?: boolean | Video$lockedByArgs<ExtArgs>
    publishedBy?: boolean | Video$publishedByArgs<ExtArgs>
    assignedReviewer?: boolean | Video$assignedReviewerArgs<ExtArgs>
    reviews?: boolean | Video$reviewsArgs<ExtArgs>
    comments?: boolean | Video$commentsArgs<ExtArgs>
    analytics?: boolean | Video$analyticsArgs<ExtArgs>
    _count?: boolean | VideoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["video"]>

  export type VideoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topicId?: boolean
    scriptId?: boolean
    title?: boolean
    description?: boolean
    videoUrl?: boolean
    thumbnailUrl?: boolean
    duration?: boolean
    fileSize?: boolean
    doctorName?: boolean
    specialty?: boolean
    language?: boolean
    city?: boolean
    ctaType?: boolean
    tags?: boolean
    transcript?: boolean
    transcriptUrl?: boolean
    summary?: boolean
    shortSummary?: boolean
    keyTakeaways?: boolean
    entities?: boolean
    qualityScore?: boolean
    relatedVideoIds?: boolean
    aiProcessedAt?: boolean
    aiProcessingStatus?: boolean
    status?: boolean
    version?: boolean
    uploadedById?: boolean
    lockedById?: boolean
    lockedAt?: boolean
    publishedById?: boolean
    publishedAt?: boolean
    assignedReviewerId?: boolean
    assignedAt?: boolean
    deepLink?: boolean
    viewCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    script?: boolean | Video$scriptArgs<ExtArgs>
    uploadedBy?: boolean | Video$uploadedByArgs<ExtArgs>
    lockedBy?: boolean | Video$lockedByArgs<ExtArgs>
    publishedBy?: boolean | Video$publishedByArgs<ExtArgs>
    assignedReviewer?: boolean | Video$assignedReviewerArgs<ExtArgs>
  }, ExtArgs["result"]["video"]>

  export type VideoSelectScalar = {
    id?: boolean
    topicId?: boolean
    scriptId?: boolean
    title?: boolean
    description?: boolean
    videoUrl?: boolean
    thumbnailUrl?: boolean
    duration?: boolean
    fileSize?: boolean
    doctorName?: boolean
    specialty?: boolean
    language?: boolean
    city?: boolean
    ctaType?: boolean
    tags?: boolean
    transcript?: boolean
    transcriptUrl?: boolean
    summary?: boolean
    shortSummary?: boolean
    keyTakeaways?: boolean
    entities?: boolean
    qualityScore?: boolean
    relatedVideoIds?: boolean
    aiProcessedAt?: boolean
    aiProcessingStatus?: boolean
    status?: boolean
    version?: boolean
    uploadedById?: boolean
    lockedById?: boolean
    lockedAt?: boolean
    publishedById?: boolean
    publishedAt?: boolean
    assignedReviewerId?: boolean
    assignedAt?: boolean
    deepLink?: boolean
    viewCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VideoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    script?: boolean | Video$scriptArgs<ExtArgs>
    uploadedBy?: boolean | Video$uploadedByArgs<ExtArgs>
    lockedBy?: boolean | Video$lockedByArgs<ExtArgs>
    publishedBy?: boolean | Video$publishedByArgs<ExtArgs>
    assignedReviewer?: boolean | Video$assignedReviewerArgs<ExtArgs>
    reviews?: boolean | Video$reviewsArgs<ExtArgs>
    comments?: boolean | Video$commentsArgs<ExtArgs>
    analytics?: boolean | Video$analyticsArgs<ExtArgs>
    _count?: boolean | VideoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VideoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    script?: boolean | Video$scriptArgs<ExtArgs>
    uploadedBy?: boolean | Video$uploadedByArgs<ExtArgs>
    lockedBy?: boolean | Video$lockedByArgs<ExtArgs>
    publishedBy?: boolean | Video$publishedByArgs<ExtArgs>
    assignedReviewer?: boolean | Video$assignedReviewerArgs<ExtArgs>
  }

  export type $VideoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Video"
    objects: {
      topic: Prisma.$TopicPayload<ExtArgs>
      script: Prisma.$ScriptPayload<ExtArgs> | null
      uploadedBy: Prisma.$UserPayload<ExtArgs> | null
      lockedBy: Prisma.$UserPayload<ExtArgs> | null
      publishedBy: Prisma.$UserPayload<ExtArgs> | null
      assignedReviewer: Prisma.$UserPayload<ExtArgs> | null
      reviews: Prisma.$VideoReviewPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      analytics: Prisma.$VideoAnalyticsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      topicId: string
      scriptId: string | null
      title: string
      description: string | null
      videoUrl: string
      thumbnailUrl: string | null
      duration: number | null
      fileSize: bigint | null
      doctorName: string
      specialty: string
      language: string
      city: string
      ctaType: $Enums.CTAType
      tags: string[]
      transcript: string | null
      transcriptUrl: string | null
      summary: string | null
      shortSummary: string | null
      keyTakeaways: string[]
      entities: Prisma.JsonValue | null
      qualityScore: number | null
      relatedVideoIds: string[]
      aiProcessedAt: Date | null
      aiProcessingStatus: string | null
      status: $Enums.VideoStatus
      version: number
      uploadedById: string | null
      lockedById: string | null
      lockedAt: Date | null
      publishedById: string | null
      publishedAt: Date | null
      assignedReviewerId: string | null
      assignedAt: Date | null
      deepLink: string | null
      viewCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["video"]>
    composites: {}
  }

  type VideoGetPayload<S extends boolean | null | undefined | VideoDefaultArgs> = $Result.GetResult<Prisma.$VideoPayload, S>

  type VideoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VideoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VideoCountAggregateInputType | true
    }

  export interface VideoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Video'], meta: { name: 'Video' } }
    /**
     * Find zero or one Video that matches the filter.
     * @param {VideoFindUniqueArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoFindUniqueArgs>(args: SelectSubset<T, VideoFindUniqueArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Video that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VideoFindUniqueOrThrowArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Video that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindFirstArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoFindFirstArgs>(args?: SelectSubset<T, VideoFindFirstArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Video that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindFirstOrThrowArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Videos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Videos
     * const videos = await prisma.video.findMany()
     * 
     * // Get first 10 Videos
     * const videos = await prisma.video.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoWithIdOnly = await prisma.video.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VideoFindManyArgs>(args?: SelectSubset<T, VideoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Video.
     * @param {VideoCreateArgs} args - Arguments to create a Video.
     * @example
     * // Create one Video
     * const Video = await prisma.video.create({
     *   data: {
     *     // ... data to create a Video
     *   }
     * })
     * 
     */
    create<T extends VideoCreateArgs>(args: SelectSubset<T, VideoCreateArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Videos.
     * @param {VideoCreateManyArgs} args - Arguments to create many Videos.
     * @example
     * // Create many Videos
     * const video = await prisma.video.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoCreateManyArgs>(args?: SelectSubset<T, VideoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Videos and returns the data saved in the database.
     * @param {VideoCreateManyAndReturnArgs} args - Arguments to create many Videos.
     * @example
     * // Create many Videos
     * const video = await prisma.video.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Videos and only return the `id`
     * const videoWithIdOnly = await prisma.video.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideoCreateManyAndReturnArgs>(args?: SelectSubset<T, VideoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Video.
     * @param {VideoDeleteArgs} args - Arguments to delete one Video.
     * @example
     * // Delete one Video
     * const Video = await prisma.video.delete({
     *   where: {
     *     // ... filter to delete one Video
     *   }
     * })
     * 
     */
    delete<T extends VideoDeleteArgs>(args: SelectSubset<T, VideoDeleteArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Video.
     * @param {VideoUpdateArgs} args - Arguments to update one Video.
     * @example
     * // Update one Video
     * const video = await prisma.video.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoUpdateArgs>(args: SelectSubset<T, VideoUpdateArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Videos.
     * @param {VideoDeleteManyArgs} args - Arguments to filter Videos to delete.
     * @example
     * // Delete a few Videos
     * const { count } = await prisma.video.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoDeleteManyArgs>(args?: SelectSubset<T, VideoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Videos
     * const video = await prisma.video.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoUpdateManyArgs>(args: SelectSubset<T, VideoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Video.
     * @param {VideoUpsertArgs} args - Arguments to update or create a Video.
     * @example
     * // Update or create a Video
     * const video = await prisma.video.upsert({
     *   create: {
     *     // ... data to create a Video
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Video we want to update
     *   }
     * })
     */
    upsert<T extends VideoUpsertArgs>(args: SelectSubset<T, VideoUpsertArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCountArgs} args - Arguments to filter Videos to count.
     * @example
     * // Count the number of Videos
     * const count = await prisma.video.count({
     *   where: {
     *     // ... the filter for the Videos we want to count
     *   }
     * })
    **/
    count<T extends VideoCountArgs>(
      args?: Subset<T, VideoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoAggregateArgs>(args: Subset<T, VideoAggregateArgs>): Prisma.PrismaPromise<GetVideoAggregateType<T>>

    /**
     * Group by Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoGroupByArgs['orderBy'] }
        : { orderBy?: VideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Video model
   */
  readonly fields: VideoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Video.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    topic<T extends TopicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TopicDefaultArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    script<T extends Video$scriptArgs<ExtArgs> = {}>(args?: Subset<T, Video$scriptArgs<ExtArgs>>): Prisma__ScriptClient<$Result.GetResult<Prisma.$ScriptPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    uploadedBy<T extends Video$uploadedByArgs<ExtArgs> = {}>(args?: Subset<T, Video$uploadedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    lockedBy<T extends Video$lockedByArgs<ExtArgs> = {}>(args?: Subset<T, Video$lockedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    publishedBy<T extends Video$publishedByArgs<ExtArgs> = {}>(args?: Subset<T, Video$publishedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    assignedReviewer<T extends Video$assignedReviewerArgs<ExtArgs> = {}>(args?: Subset<T, Video$assignedReviewerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    reviews<T extends Video$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Video$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoReviewPayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends Video$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Video$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    analytics<T extends Video$analyticsArgs<ExtArgs> = {}>(args?: Subset<T, Video$analyticsArgs<ExtArgs>>): Prisma__VideoAnalyticsClient<$Result.GetResult<Prisma.$VideoAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Video model
   */ 
  interface VideoFieldRefs {
    readonly id: FieldRef<"Video", 'String'>
    readonly topicId: FieldRef<"Video", 'String'>
    readonly scriptId: FieldRef<"Video", 'String'>
    readonly title: FieldRef<"Video", 'String'>
    readonly description: FieldRef<"Video", 'String'>
    readonly videoUrl: FieldRef<"Video", 'String'>
    readonly thumbnailUrl: FieldRef<"Video", 'String'>
    readonly duration: FieldRef<"Video", 'Int'>
    readonly fileSize: FieldRef<"Video", 'BigInt'>
    readonly doctorName: FieldRef<"Video", 'String'>
    readonly specialty: FieldRef<"Video", 'String'>
    readonly language: FieldRef<"Video", 'String'>
    readonly city: FieldRef<"Video", 'String'>
    readonly ctaType: FieldRef<"Video", 'CTAType'>
    readonly tags: FieldRef<"Video", 'String[]'>
    readonly transcript: FieldRef<"Video", 'String'>
    readonly transcriptUrl: FieldRef<"Video", 'String'>
    readonly summary: FieldRef<"Video", 'String'>
    readonly shortSummary: FieldRef<"Video", 'String'>
    readonly keyTakeaways: FieldRef<"Video", 'String[]'>
    readonly entities: FieldRef<"Video", 'Json'>
    readonly qualityScore: FieldRef<"Video", 'Int'>
    readonly relatedVideoIds: FieldRef<"Video", 'String[]'>
    readonly aiProcessedAt: FieldRef<"Video", 'DateTime'>
    readonly aiProcessingStatus: FieldRef<"Video", 'String'>
    readonly status: FieldRef<"Video", 'VideoStatus'>
    readonly version: FieldRef<"Video", 'Int'>
    readonly uploadedById: FieldRef<"Video", 'String'>
    readonly lockedById: FieldRef<"Video", 'String'>
    readonly lockedAt: FieldRef<"Video", 'DateTime'>
    readonly publishedById: FieldRef<"Video", 'String'>
    readonly publishedAt: FieldRef<"Video", 'DateTime'>
    readonly assignedReviewerId: FieldRef<"Video", 'String'>
    readonly assignedAt: FieldRef<"Video", 'DateTime'>
    readonly deepLink: FieldRef<"Video", 'String'>
    readonly viewCount: FieldRef<"Video", 'Int'>
    readonly createdAt: FieldRef<"Video", 'DateTime'>
    readonly updatedAt: FieldRef<"Video", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Video findUnique
   */
  export type VideoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video findUniqueOrThrow
   */
  export type VideoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video findFirst
   */
  export type VideoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videos.
     */
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Video findFirstOrThrow
   */
  export type VideoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videos.
     */
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Video findMany
   */
  export type VideoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Videos to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Video create
   */
  export type VideoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * The data needed to create a Video.
     */
    data: XOR<VideoCreateInput, VideoUncheckedCreateInput>
  }

  /**
   * Video createMany
   */
  export type VideoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Videos.
     */
    data: VideoCreateManyInput | VideoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Video createManyAndReturn
   */
  export type VideoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Videos.
     */
    data: VideoCreateManyInput | VideoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Video update
   */
  export type VideoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * The data needed to update a Video.
     */
    data: XOR<VideoUpdateInput, VideoUncheckedUpdateInput>
    /**
     * Choose, which Video to update.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video updateMany
   */
  export type VideoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Videos.
     */
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyInput>
    /**
     * Filter which Videos to update
     */
    where?: VideoWhereInput
  }

  /**
   * Video upsert
   */
  export type VideoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * The filter to search for the Video to update in case it exists.
     */
    where: VideoWhereUniqueInput
    /**
     * In case the Video found by the `where` argument doesn't exist, create a new Video with this data.
     */
    create: XOR<VideoCreateInput, VideoUncheckedCreateInput>
    /**
     * In case the Video was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoUpdateInput, VideoUncheckedUpdateInput>
  }

  /**
   * Video delete
   */
  export type VideoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter which Video to delete.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video deleteMany
   */
  export type VideoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Videos to delete
     */
    where?: VideoWhereInput
  }

  /**
   * Video.script
   */
  export type Video$scriptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Script
     */
    select?: ScriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScriptInclude<ExtArgs> | null
    where?: ScriptWhereInput
  }

  /**
   * Video.uploadedBy
   */
  export type Video$uploadedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Video.lockedBy
   */
  export type Video$lockedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Video.publishedBy
   */
  export type Video$publishedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Video.assignedReviewer
   */
  export type Video$assignedReviewerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Video.reviews
   */
  export type Video$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoReview
     */
    select?: VideoReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoReviewInclude<ExtArgs> | null
    where?: VideoReviewWhereInput
    orderBy?: VideoReviewOrderByWithRelationInput | VideoReviewOrderByWithRelationInput[]
    cursor?: VideoReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoReviewScalarFieldEnum | VideoReviewScalarFieldEnum[]
  }

  /**
   * Video.comments
   */
  export type Video$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Video.analytics
   */
  export type Video$analyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoAnalytics
     */
    select?: VideoAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoAnalyticsInclude<ExtArgs> | null
    where?: VideoAnalyticsWhereInput
  }

  /**
   * Video without action
   */
  export type VideoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
  }


  /**
   * Model VideoReview
   */

  export type AggregateVideoReview = {
    _count: VideoReviewCountAggregateOutputType | null
    _min: VideoReviewMinAggregateOutputType | null
    _max: VideoReviewMaxAggregateOutputType | null
  }

  export type VideoReviewMinAggregateOutputType = {
    id: string | null
    videoId: string | null
    reviewerId: string | null
    reviewerType: $Enums.UserRole | null
    decision: $Enums.ReviewDecision | null
    comments: string | null
    reviewedAt: Date | null
    createdAt: Date | null
  }

  export type VideoReviewMaxAggregateOutputType = {
    id: string | null
    videoId: string | null
    reviewerId: string | null
    reviewerType: $Enums.UserRole | null
    decision: $Enums.ReviewDecision | null
    comments: string | null
    reviewedAt: Date | null
    createdAt: Date | null
  }

  export type VideoReviewCountAggregateOutputType = {
    id: number
    videoId: number
    reviewerId: number
    reviewerType: number
    decision: number
    comments: number
    reviewedAt: number
    createdAt: number
    _all: number
  }


  export type VideoReviewMinAggregateInputType = {
    id?: true
    videoId?: true
    reviewerId?: true
    reviewerType?: true
    decision?: true
    comments?: true
    reviewedAt?: true
    createdAt?: true
  }

  export type VideoReviewMaxAggregateInputType = {
    id?: true
    videoId?: true
    reviewerId?: true
    reviewerType?: true
    decision?: true
    comments?: true
    reviewedAt?: true
    createdAt?: true
  }

  export type VideoReviewCountAggregateInputType = {
    id?: true
    videoId?: true
    reviewerId?: true
    reviewerType?: true
    decision?: true
    comments?: true
    reviewedAt?: true
    createdAt?: true
    _all?: true
  }

  export type VideoReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoReview to aggregate.
     */
    where?: VideoReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoReviews to fetch.
     */
    orderBy?: VideoReviewOrderByWithRelationInput | VideoReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VideoReviews
    **/
    _count?: true | VideoReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoReviewMaxAggregateInputType
  }

  export type GetVideoReviewAggregateType<T extends VideoReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateVideoReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideoReview[P]>
      : GetScalarType<T[P], AggregateVideoReview[P]>
  }




  export type VideoReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoReviewWhereInput
    orderBy?: VideoReviewOrderByWithAggregationInput | VideoReviewOrderByWithAggregationInput[]
    by: VideoReviewScalarFieldEnum[] | VideoReviewScalarFieldEnum
    having?: VideoReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoReviewCountAggregateInputType | true
    _min?: VideoReviewMinAggregateInputType
    _max?: VideoReviewMaxAggregateInputType
  }

  export type VideoReviewGroupByOutputType = {
    id: string
    videoId: string
    reviewerId: string
    reviewerType: $Enums.UserRole
    decision: $Enums.ReviewDecision
    comments: string | null
    reviewedAt: Date | null
    createdAt: Date
    _count: VideoReviewCountAggregateOutputType | null
    _min: VideoReviewMinAggregateOutputType | null
    _max: VideoReviewMaxAggregateOutputType | null
  }

  type GetVideoReviewGroupByPayload<T extends VideoReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoReviewGroupByOutputType[P]>
            : GetScalarType<T[P], VideoReviewGroupByOutputType[P]>
        }
      >
    >


  export type VideoReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoId?: boolean
    reviewerId?: boolean
    reviewerType?: boolean
    decision?: boolean
    comments?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    video?: boolean | VideoDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoReview"]>

  export type VideoReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoId?: boolean
    reviewerId?: boolean
    reviewerType?: boolean
    decision?: boolean
    comments?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    video?: boolean | VideoDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoReview"]>

  export type VideoReviewSelectScalar = {
    id?: boolean
    videoId?: boolean
    reviewerId?: boolean
    reviewerType?: boolean
    decision?: boolean
    comments?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
  }

  export type VideoReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    video?: boolean | VideoDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VideoReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    video?: boolean | VideoDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VideoReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VideoReview"
    objects: {
      video: Prisma.$VideoPayload<ExtArgs>
      reviewer: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      videoId: string
      reviewerId: string
      reviewerType: $Enums.UserRole
      decision: $Enums.ReviewDecision
      comments: string | null
      reviewedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["videoReview"]>
    composites: {}
  }

  type VideoReviewGetPayload<S extends boolean | null | undefined | VideoReviewDefaultArgs> = $Result.GetResult<Prisma.$VideoReviewPayload, S>

  type VideoReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VideoReviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VideoReviewCountAggregateInputType | true
    }

  export interface VideoReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VideoReview'], meta: { name: 'VideoReview' } }
    /**
     * Find zero or one VideoReview that matches the filter.
     * @param {VideoReviewFindUniqueArgs} args - Arguments to find a VideoReview
     * @example
     * // Get one VideoReview
     * const videoReview = await prisma.videoReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoReviewFindUniqueArgs>(args: SelectSubset<T, VideoReviewFindUniqueArgs<ExtArgs>>): Prisma__VideoReviewClient<$Result.GetResult<Prisma.$VideoReviewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VideoReview that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VideoReviewFindUniqueOrThrowArgs} args - Arguments to find a VideoReview
     * @example
     * // Get one VideoReview
     * const videoReview = await prisma.videoReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoReviewClient<$Result.GetResult<Prisma.$VideoReviewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VideoReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoReviewFindFirstArgs} args - Arguments to find a VideoReview
     * @example
     * // Get one VideoReview
     * const videoReview = await prisma.videoReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoReviewFindFirstArgs>(args?: SelectSubset<T, VideoReviewFindFirstArgs<ExtArgs>>): Prisma__VideoReviewClient<$Result.GetResult<Prisma.$VideoReviewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VideoReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoReviewFindFirstOrThrowArgs} args - Arguments to find a VideoReview
     * @example
     * // Get one VideoReview
     * const videoReview = await prisma.videoReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoReviewClient<$Result.GetResult<Prisma.$VideoReviewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VideoReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VideoReviews
     * const videoReviews = await prisma.videoReview.findMany()
     * 
     * // Get first 10 VideoReviews
     * const videoReviews = await prisma.videoReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoReviewWithIdOnly = await prisma.videoReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VideoReviewFindManyArgs>(args?: SelectSubset<T, VideoReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoReviewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VideoReview.
     * @param {VideoReviewCreateArgs} args - Arguments to create a VideoReview.
     * @example
     * // Create one VideoReview
     * const VideoReview = await prisma.videoReview.create({
     *   data: {
     *     // ... data to create a VideoReview
     *   }
     * })
     * 
     */
    create<T extends VideoReviewCreateArgs>(args: SelectSubset<T, VideoReviewCreateArgs<ExtArgs>>): Prisma__VideoReviewClient<$Result.GetResult<Prisma.$VideoReviewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VideoReviews.
     * @param {VideoReviewCreateManyArgs} args - Arguments to create many VideoReviews.
     * @example
     * // Create many VideoReviews
     * const videoReview = await prisma.videoReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoReviewCreateManyArgs>(args?: SelectSubset<T, VideoReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VideoReviews and returns the data saved in the database.
     * @param {VideoReviewCreateManyAndReturnArgs} args - Arguments to create many VideoReviews.
     * @example
     * // Create many VideoReviews
     * const videoReview = await prisma.videoReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VideoReviews and only return the `id`
     * const videoReviewWithIdOnly = await prisma.videoReview.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideoReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, VideoReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoReviewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VideoReview.
     * @param {VideoReviewDeleteArgs} args - Arguments to delete one VideoReview.
     * @example
     * // Delete one VideoReview
     * const VideoReview = await prisma.videoReview.delete({
     *   where: {
     *     // ... filter to delete one VideoReview
     *   }
     * })
     * 
     */
    delete<T extends VideoReviewDeleteArgs>(args: SelectSubset<T, VideoReviewDeleteArgs<ExtArgs>>): Prisma__VideoReviewClient<$Result.GetResult<Prisma.$VideoReviewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VideoReview.
     * @param {VideoReviewUpdateArgs} args - Arguments to update one VideoReview.
     * @example
     * // Update one VideoReview
     * const videoReview = await prisma.videoReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoReviewUpdateArgs>(args: SelectSubset<T, VideoReviewUpdateArgs<ExtArgs>>): Prisma__VideoReviewClient<$Result.GetResult<Prisma.$VideoReviewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VideoReviews.
     * @param {VideoReviewDeleteManyArgs} args - Arguments to filter VideoReviews to delete.
     * @example
     * // Delete a few VideoReviews
     * const { count } = await prisma.videoReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoReviewDeleteManyArgs>(args?: SelectSubset<T, VideoReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VideoReviews
     * const videoReview = await prisma.videoReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoReviewUpdateManyArgs>(args: SelectSubset<T, VideoReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VideoReview.
     * @param {VideoReviewUpsertArgs} args - Arguments to update or create a VideoReview.
     * @example
     * // Update or create a VideoReview
     * const videoReview = await prisma.videoReview.upsert({
     *   create: {
     *     // ... data to create a VideoReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VideoReview we want to update
     *   }
     * })
     */
    upsert<T extends VideoReviewUpsertArgs>(args: SelectSubset<T, VideoReviewUpsertArgs<ExtArgs>>): Prisma__VideoReviewClient<$Result.GetResult<Prisma.$VideoReviewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VideoReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoReviewCountArgs} args - Arguments to filter VideoReviews to count.
     * @example
     * // Count the number of VideoReviews
     * const count = await prisma.videoReview.count({
     *   where: {
     *     // ... the filter for the VideoReviews we want to count
     *   }
     * })
    **/
    count<T extends VideoReviewCountArgs>(
      args?: Subset<T, VideoReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VideoReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoReviewAggregateArgs>(args: Subset<T, VideoReviewAggregateArgs>): Prisma.PrismaPromise<GetVideoReviewAggregateType<T>>

    /**
     * Group by VideoReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoReviewGroupByArgs['orderBy'] }
        : { orderBy?: VideoReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VideoReview model
   */
  readonly fields: VideoReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VideoReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    video<T extends VideoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoDefaultArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    reviewer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VideoReview model
   */ 
  interface VideoReviewFieldRefs {
    readonly id: FieldRef<"VideoReview", 'String'>
    readonly videoId: FieldRef<"VideoReview", 'String'>
    readonly reviewerId: FieldRef<"VideoReview", 'String'>
    readonly reviewerType: FieldRef<"VideoReview", 'UserRole'>
    readonly decision: FieldRef<"VideoReview", 'ReviewDecision'>
    readonly comments: FieldRef<"VideoReview", 'String'>
    readonly reviewedAt: FieldRef<"VideoReview", 'DateTime'>
    readonly createdAt: FieldRef<"VideoReview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VideoReview findUnique
   */
  export type VideoReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoReview
     */
    select?: VideoReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoReviewInclude<ExtArgs> | null
    /**
     * Filter, which VideoReview to fetch.
     */
    where: VideoReviewWhereUniqueInput
  }

  /**
   * VideoReview findUniqueOrThrow
   */
  export type VideoReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoReview
     */
    select?: VideoReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoReviewInclude<ExtArgs> | null
    /**
     * Filter, which VideoReview to fetch.
     */
    where: VideoReviewWhereUniqueInput
  }

  /**
   * VideoReview findFirst
   */
  export type VideoReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoReview
     */
    select?: VideoReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoReviewInclude<ExtArgs> | null
    /**
     * Filter, which VideoReview to fetch.
     */
    where?: VideoReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoReviews to fetch.
     */
    orderBy?: VideoReviewOrderByWithRelationInput | VideoReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoReviews.
     */
    cursor?: VideoReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoReviews.
     */
    distinct?: VideoReviewScalarFieldEnum | VideoReviewScalarFieldEnum[]
  }

  /**
   * VideoReview findFirstOrThrow
   */
  export type VideoReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoReview
     */
    select?: VideoReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoReviewInclude<ExtArgs> | null
    /**
     * Filter, which VideoReview to fetch.
     */
    where?: VideoReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoReviews to fetch.
     */
    orderBy?: VideoReviewOrderByWithRelationInput | VideoReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoReviews.
     */
    cursor?: VideoReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoReviews.
     */
    distinct?: VideoReviewScalarFieldEnum | VideoReviewScalarFieldEnum[]
  }

  /**
   * VideoReview findMany
   */
  export type VideoReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoReview
     */
    select?: VideoReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoReviewInclude<ExtArgs> | null
    /**
     * Filter, which VideoReviews to fetch.
     */
    where?: VideoReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoReviews to fetch.
     */
    orderBy?: VideoReviewOrderByWithRelationInput | VideoReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VideoReviews.
     */
    cursor?: VideoReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoReviews.
     */
    skip?: number
    distinct?: VideoReviewScalarFieldEnum | VideoReviewScalarFieldEnum[]
  }

  /**
   * VideoReview create
   */
  export type VideoReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoReview
     */
    select?: VideoReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a VideoReview.
     */
    data: XOR<VideoReviewCreateInput, VideoReviewUncheckedCreateInput>
  }

  /**
   * VideoReview createMany
   */
  export type VideoReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VideoReviews.
     */
    data: VideoReviewCreateManyInput | VideoReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideoReview createManyAndReturn
   */
  export type VideoReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoReview
     */
    select?: VideoReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VideoReviews.
     */
    data: VideoReviewCreateManyInput | VideoReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VideoReview update
   */
  export type VideoReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoReview
     */
    select?: VideoReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a VideoReview.
     */
    data: XOR<VideoReviewUpdateInput, VideoReviewUncheckedUpdateInput>
    /**
     * Choose, which VideoReview to update.
     */
    where: VideoReviewWhereUniqueInput
  }

  /**
   * VideoReview updateMany
   */
  export type VideoReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VideoReviews.
     */
    data: XOR<VideoReviewUpdateManyMutationInput, VideoReviewUncheckedUpdateManyInput>
    /**
     * Filter which VideoReviews to update
     */
    where?: VideoReviewWhereInput
  }

  /**
   * VideoReview upsert
   */
  export type VideoReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoReview
     */
    select?: VideoReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the VideoReview to update in case it exists.
     */
    where: VideoReviewWhereUniqueInput
    /**
     * In case the VideoReview found by the `where` argument doesn't exist, create a new VideoReview with this data.
     */
    create: XOR<VideoReviewCreateInput, VideoReviewUncheckedCreateInput>
    /**
     * In case the VideoReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoReviewUpdateInput, VideoReviewUncheckedUpdateInput>
  }

  /**
   * VideoReview delete
   */
  export type VideoReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoReview
     */
    select?: VideoReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoReviewInclude<ExtArgs> | null
    /**
     * Filter which VideoReview to delete.
     */
    where: VideoReviewWhereUniqueInput
  }

  /**
   * VideoReview deleteMany
   */
  export type VideoReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoReviews to delete
     */
    where?: VideoReviewWhereInput
  }

  /**
   * VideoReview without action
   */
  export type VideoReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoReview
     */
    select?: VideoReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoReviewInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    scriptId: string | null
    videoId: string | null
    authorId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    scriptId: string | null
    videoId: string | null
    authorId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    scriptId: number
    videoId: number
    authorId: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    scriptId?: true
    videoId?: true
    authorId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    scriptId?: true
    videoId?: true
    authorId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    scriptId?: true
    videoId?: true
    authorId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    scriptId: string | null
    videoId: string | null
    authorId: string
    content: string
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scriptId?: boolean
    videoId?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    script?: boolean | Comment$scriptArgs<ExtArgs>
    video?: boolean | Comment$videoArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scriptId?: boolean
    videoId?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    script?: boolean | Comment$scriptArgs<ExtArgs>
    video?: boolean | Comment$videoArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    scriptId?: boolean
    videoId?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    script?: boolean | Comment$scriptArgs<ExtArgs>
    video?: boolean | Comment$videoArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    script?: boolean | Comment$scriptArgs<ExtArgs>
    video?: boolean | Comment$videoArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      script: Prisma.$ScriptPayload<ExtArgs> | null
      video: Prisma.$VideoPayload<ExtArgs> | null
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      scriptId: string | null
      videoId: string | null
      authorId: string
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    script<T extends Comment$scriptArgs<ExtArgs> = {}>(args?: Subset<T, Comment$scriptArgs<ExtArgs>>): Prisma__ScriptClient<$Result.GetResult<Prisma.$ScriptPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    video<T extends Comment$videoArgs<ExtArgs> = {}>(args?: Subset<T, Comment$videoArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly scriptId: FieldRef<"Comment", 'String'>
    readonly videoId: FieldRef<"Comment", 'String'>
    readonly authorId: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }

  /**
   * Comment.script
   */
  export type Comment$scriptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Script
     */
    select?: ScriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScriptInclude<ExtArgs> | null
    where?: ScriptWhereInput
  }

  /**
   * Comment.video
   */
  export type Comment$videoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    where?: VideoWhereInput
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    message: number
    isRead: number
    readAt: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    readAt?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    readAt?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    readAt?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead: boolean
    readAt: Date | null
    metadata: JsonValue | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    readAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    readAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    readAt?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.NotificationType
      title: string
      message: string
      isRead: boolean
      readAt: Date | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entityType: number
    entityId: number
    oldValue: number
    newValue: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    oldValue?: true
    newValue?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string
    action: string
    entityType: string
    entityId: string
    oldValue: JsonValue | null
    newValue: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValue?: boolean
    newValue?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValue?: boolean
    newValue?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValue?: boolean
    newValue?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: string
      entityType: string
      entityId: string
      oldValue: Prisma.JsonValue | null
      newValue: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly oldValue: FieldRef<"AuditLog", 'Json'>
    readonly newValue: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model VideoAnalytics
   */

  export type AggregateVideoAnalytics = {
    _count: VideoAnalyticsCountAggregateOutputType | null
    _avg: VideoAnalyticsAvgAggregateOutputType | null
    _sum: VideoAnalyticsSumAggregateOutputType | null
    _min: VideoAnalyticsMinAggregateOutputType | null
    _max: VideoAnalyticsMaxAggregateOutputType | null
  }

  export type VideoAnalyticsAvgAggregateOutputType = {
    views: number | null
    uniqueViews: number | null
    avgWatchTime: number | null
    ctr: number | null
    quizStarted: number | null
    quizCompleted: number | null
    consultClicked: number | null
    consultCompleted: number | null
    hookRate3s: number | null
    hookRate5s: number | null
  }

  export type VideoAnalyticsSumAggregateOutputType = {
    views: number | null
    uniqueViews: number | null
    avgWatchTime: number | null
    ctr: number | null
    quizStarted: number | null
    quizCompleted: number | null
    consultClicked: number | null
    consultCompleted: number | null
    hookRate3s: number | null
    hookRate5s: number | null
  }

  export type VideoAnalyticsMinAggregateOutputType = {
    id: string | null
    videoId: string | null
    views: number | null
    uniqueViews: number | null
    avgWatchTime: number | null
    ctr: number | null
    quizStarted: number | null
    quizCompleted: number | null
    consultClicked: number | null
    consultCompleted: number | null
    hookRate3s: number | null
    hookRate5s: number | null
    updatedAt: Date | null
  }

  export type VideoAnalyticsMaxAggregateOutputType = {
    id: string | null
    videoId: string | null
    views: number | null
    uniqueViews: number | null
    avgWatchTime: number | null
    ctr: number | null
    quizStarted: number | null
    quizCompleted: number | null
    consultClicked: number | null
    consultCompleted: number | null
    hookRate3s: number | null
    hookRate5s: number | null
    updatedAt: Date | null
  }

  export type VideoAnalyticsCountAggregateOutputType = {
    id: number
    videoId: number
    views: number
    uniqueViews: number
    avgWatchTime: number
    ctr: number
    quizStarted: number
    quizCompleted: number
    consultClicked: number
    consultCompleted: number
    hookRate3s: number
    hookRate5s: number
    updatedAt: number
    _all: number
  }


  export type VideoAnalyticsAvgAggregateInputType = {
    views?: true
    uniqueViews?: true
    avgWatchTime?: true
    ctr?: true
    quizStarted?: true
    quizCompleted?: true
    consultClicked?: true
    consultCompleted?: true
    hookRate3s?: true
    hookRate5s?: true
  }

  export type VideoAnalyticsSumAggregateInputType = {
    views?: true
    uniqueViews?: true
    avgWatchTime?: true
    ctr?: true
    quizStarted?: true
    quizCompleted?: true
    consultClicked?: true
    consultCompleted?: true
    hookRate3s?: true
    hookRate5s?: true
  }

  export type VideoAnalyticsMinAggregateInputType = {
    id?: true
    videoId?: true
    views?: true
    uniqueViews?: true
    avgWatchTime?: true
    ctr?: true
    quizStarted?: true
    quizCompleted?: true
    consultClicked?: true
    consultCompleted?: true
    hookRate3s?: true
    hookRate5s?: true
    updatedAt?: true
  }

  export type VideoAnalyticsMaxAggregateInputType = {
    id?: true
    videoId?: true
    views?: true
    uniqueViews?: true
    avgWatchTime?: true
    ctr?: true
    quizStarted?: true
    quizCompleted?: true
    consultClicked?: true
    consultCompleted?: true
    hookRate3s?: true
    hookRate5s?: true
    updatedAt?: true
  }

  export type VideoAnalyticsCountAggregateInputType = {
    id?: true
    videoId?: true
    views?: true
    uniqueViews?: true
    avgWatchTime?: true
    ctr?: true
    quizStarted?: true
    quizCompleted?: true
    consultClicked?: true
    consultCompleted?: true
    hookRate3s?: true
    hookRate5s?: true
    updatedAt?: true
    _all?: true
  }

  export type VideoAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoAnalytics to aggregate.
     */
    where?: VideoAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoAnalytics to fetch.
     */
    orderBy?: VideoAnalyticsOrderByWithRelationInput | VideoAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VideoAnalytics
    **/
    _count?: true | VideoAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideoAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideoAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoAnalyticsMaxAggregateInputType
  }

  export type GetVideoAnalyticsAggregateType<T extends VideoAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateVideoAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideoAnalytics[P]>
      : GetScalarType<T[P], AggregateVideoAnalytics[P]>
  }




  export type VideoAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoAnalyticsWhereInput
    orderBy?: VideoAnalyticsOrderByWithAggregationInput | VideoAnalyticsOrderByWithAggregationInput[]
    by: VideoAnalyticsScalarFieldEnum[] | VideoAnalyticsScalarFieldEnum
    having?: VideoAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoAnalyticsCountAggregateInputType | true
    _avg?: VideoAnalyticsAvgAggregateInputType
    _sum?: VideoAnalyticsSumAggregateInputType
    _min?: VideoAnalyticsMinAggregateInputType
    _max?: VideoAnalyticsMaxAggregateInputType
  }

  export type VideoAnalyticsGroupByOutputType = {
    id: string
    videoId: string
    views: number
    uniqueViews: number
    avgWatchTime: number
    ctr: number
    quizStarted: number
    quizCompleted: number
    consultClicked: number
    consultCompleted: number
    hookRate3s: number
    hookRate5s: number
    updatedAt: Date
    _count: VideoAnalyticsCountAggregateOutputType | null
    _avg: VideoAnalyticsAvgAggregateOutputType | null
    _sum: VideoAnalyticsSumAggregateOutputType | null
    _min: VideoAnalyticsMinAggregateOutputType | null
    _max: VideoAnalyticsMaxAggregateOutputType | null
  }

  type GetVideoAnalyticsGroupByPayload<T extends VideoAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], VideoAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type VideoAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoId?: boolean
    views?: boolean
    uniqueViews?: boolean
    avgWatchTime?: boolean
    ctr?: boolean
    quizStarted?: boolean
    quizCompleted?: boolean
    consultClicked?: boolean
    consultCompleted?: boolean
    hookRate3s?: boolean
    hookRate5s?: boolean
    updatedAt?: boolean
    video?: boolean | VideoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoAnalytics"]>

  export type VideoAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoId?: boolean
    views?: boolean
    uniqueViews?: boolean
    avgWatchTime?: boolean
    ctr?: boolean
    quizStarted?: boolean
    quizCompleted?: boolean
    consultClicked?: boolean
    consultCompleted?: boolean
    hookRate3s?: boolean
    hookRate5s?: boolean
    updatedAt?: boolean
    video?: boolean | VideoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoAnalytics"]>

  export type VideoAnalyticsSelectScalar = {
    id?: boolean
    videoId?: boolean
    views?: boolean
    uniqueViews?: boolean
    avgWatchTime?: boolean
    ctr?: boolean
    quizStarted?: boolean
    quizCompleted?: boolean
    consultClicked?: boolean
    consultCompleted?: boolean
    hookRate3s?: boolean
    hookRate5s?: boolean
    updatedAt?: boolean
  }

  export type VideoAnalyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    video?: boolean | VideoDefaultArgs<ExtArgs>
  }
  export type VideoAnalyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    video?: boolean | VideoDefaultArgs<ExtArgs>
  }

  export type $VideoAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VideoAnalytics"
    objects: {
      video: Prisma.$VideoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      videoId: string
      views: number
      uniqueViews: number
      avgWatchTime: number
      ctr: number
      quizStarted: number
      quizCompleted: number
      consultClicked: number
      consultCompleted: number
      hookRate3s: number
      hookRate5s: number
      updatedAt: Date
    }, ExtArgs["result"]["videoAnalytics"]>
    composites: {}
  }

  type VideoAnalyticsGetPayload<S extends boolean | null | undefined | VideoAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$VideoAnalyticsPayload, S>

  type VideoAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VideoAnalyticsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VideoAnalyticsCountAggregateInputType | true
    }

  export interface VideoAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VideoAnalytics'], meta: { name: 'VideoAnalytics' } }
    /**
     * Find zero or one VideoAnalytics that matches the filter.
     * @param {VideoAnalyticsFindUniqueArgs} args - Arguments to find a VideoAnalytics
     * @example
     * // Get one VideoAnalytics
     * const videoAnalytics = await prisma.videoAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoAnalyticsFindUniqueArgs>(args: SelectSubset<T, VideoAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__VideoAnalyticsClient<$Result.GetResult<Prisma.$VideoAnalyticsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VideoAnalytics that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VideoAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a VideoAnalytics
     * @example
     * // Get one VideoAnalytics
     * const videoAnalytics = await prisma.videoAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoAnalyticsClient<$Result.GetResult<Prisma.$VideoAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VideoAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoAnalyticsFindFirstArgs} args - Arguments to find a VideoAnalytics
     * @example
     * // Get one VideoAnalytics
     * const videoAnalytics = await prisma.videoAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoAnalyticsFindFirstArgs>(args?: SelectSubset<T, VideoAnalyticsFindFirstArgs<ExtArgs>>): Prisma__VideoAnalyticsClient<$Result.GetResult<Prisma.$VideoAnalyticsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VideoAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoAnalyticsFindFirstOrThrowArgs} args - Arguments to find a VideoAnalytics
     * @example
     * // Get one VideoAnalytics
     * const videoAnalytics = await prisma.videoAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoAnalyticsClient<$Result.GetResult<Prisma.$VideoAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VideoAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VideoAnalytics
     * const videoAnalytics = await prisma.videoAnalytics.findMany()
     * 
     * // Get first 10 VideoAnalytics
     * const videoAnalytics = await prisma.videoAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoAnalyticsWithIdOnly = await prisma.videoAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VideoAnalyticsFindManyArgs>(args?: SelectSubset<T, VideoAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoAnalyticsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VideoAnalytics.
     * @param {VideoAnalyticsCreateArgs} args - Arguments to create a VideoAnalytics.
     * @example
     * // Create one VideoAnalytics
     * const VideoAnalytics = await prisma.videoAnalytics.create({
     *   data: {
     *     // ... data to create a VideoAnalytics
     *   }
     * })
     * 
     */
    create<T extends VideoAnalyticsCreateArgs>(args: SelectSubset<T, VideoAnalyticsCreateArgs<ExtArgs>>): Prisma__VideoAnalyticsClient<$Result.GetResult<Prisma.$VideoAnalyticsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VideoAnalytics.
     * @param {VideoAnalyticsCreateManyArgs} args - Arguments to create many VideoAnalytics.
     * @example
     * // Create many VideoAnalytics
     * const videoAnalytics = await prisma.videoAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoAnalyticsCreateManyArgs>(args?: SelectSubset<T, VideoAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VideoAnalytics and returns the data saved in the database.
     * @param {VideoAnalyticsCreateManyAndReturnArgs} args - Arguments to create many VideoAnalytics.
     * @example
     * // Create many VideoAnalytics
     * const videoAnalytics = await prisma.videoAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VideoAnalytics and only return the `id`
     * const videoAnalyticsWithIdOnly = await prisma.videoAnalytics.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideoAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, VideoAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoAnalyticsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VideoAnalytics.
     * @param {VideoAnalyticsDeleteArgs} args - Arguments to delete one VideoAnalytics.
     * @example
     * // Delete one VideoAnalytics
     * const VideoAnalytics = await prisma.videoAnalytics.delete({
     *   where: {
     *     // ... filter to delete one VideoAnalytics
     *   }
     * })
     * 
     */
    delete<T extends VideoAnalyticsDeleteArgs>(args: SelectSubset<T, VideoAnalyticsDeleteArgs<ExtArgs>>): Prisma__VideoAnalyticsClient<$Result.GetResult<Prisma.$VideoAnalyticsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VideoAnalytics.
     * @param {VideoAnalyticsUpdateArgs} args - Arguments to update one VideoAnalytics.
     * @example
     * // Update one VideoAnalytics
     * const videoAnalytics = await prisma.videoAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoAnalyticsUpdateArgs>(args: SelectSubset<T, VideoAnalyticsUpdateArgs<ExtArgs>>): Prisma__VideoAnalyticsClient<$Result.GetResult<Prisma.$VideoAnalyticsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VideoAnalytics.
     * @param {VideoAnalyticsDeleteManyArgs} args - Arguments to filter VideoAnalytics to delete.
     * @example
     * // Delete a few VideoAnalytics
     * const { count } = await prisma.videoAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoAnalyticsDeleteManyArgs>(args?: SelectSubset<T, VideoAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VideoAnalytics
     * const videoAnalytics = await prisma.videoAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoAnalyticsUpdateManyArgs>(args: SelectSubset<T, VideoAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VideoAnalytics.
     * @param {VideoAnalyticsUpsertArgs} args - Arguments to update or create a VideoAnalytics.
     * @example
     * // Update or create a VideoAnalytics
     * const videoAnalytics = await prisma.videoAnalytics.upsert({
     *   create: {
     *     // ... data to create a VideoAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VideoAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends VideoAnalyticsUpsertArgs>(args: SelectSubset<T, VideoAnalyticsUpsertArgs<ExtArgs>>): Prisma__VideoAnalyticsClient<$Result.GetResult<Prisma.$VideoAnalyticsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VideoAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoAnalyticsCountArgs} args - Arguments to filter VideoAnalytics to count.
     * @example
     * // Count the number of VideoAnalytics
     * const count = await prisma.videoAnalytics.count({
     *   where: {
     *     // ... the filter for the VideoAnalytics we want to count
     *   }
     * })
    **/
    count<T extends VideoAnalyticsCountArgs>(
      args?: Subset<T, VideoAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VideoAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoAnalyticsAggregateArgs>(args: Subset<T, VideoAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetVideoAnalyticsAggregateType<T>>

    /**
     * Group by VideoAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: VideoAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VideoAnalytics model
   */
  readonly fields: VideoAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VideoAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    video<T extends VideoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoDefaultArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VideoAnalytics model
   */ 
  interface VideoAnalyticsFieldRefs {
    readonly id: FieldRef<"VideoAnalytics", 'String'>
    readonly videoId: FieldRef<"VideoAnalytics", 'String'>
    readonly views: FieldRef<"VideoAnalytics", 'Int'>
    readonly uniqueViews: FieldRef<"VideoAnalytics", 'Int'>
    readonly avgWatchTime: FieldRef<"VideoAnalytics", 'Float'>
    readonly ctr: FieldRef<"VideoAnalytics", 'Float'>
    readonly quizStarted: FieldRef<"VideoAnalytics", 'Int'>
    readonly quizCompleted: FieldRef<"VideoAnalytics", 'Int'>
    readonly consultClicked: FieldRef<"VideoAnalytics", 'Int'>
    readonly consultCompleted: FieldRef<"VideoAnalytics", 'Int'>
    readonly hookRate3s: FieldRef<"VideoAnalytics", 'Float'>
    readonly hookRate5s: FieldRef<"VideoAnalytics", 'Float'>
    readonly updatedAt: FieldRef<"VideoAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VideoAnalytics findUnique
   */
  export type VideoAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoAnalytics
     */
    select?: VideoAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which VideoAnalytics to fetch.
     */
    where: VideoAnalyticsWhereUniqueInput
  }

  /**
   * VideoAnalytics findUniqueOrThrow
   */
  export type VideoAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoAnalytics
     */
    select?: VideoAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which VideoAnalytics to fetch.
     */
    where: VideoAnalyticsWhereUniqueInput
  }

  /**
   * VideoAnalytics findFirst
   */
  export type VideoAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoAnalytics
     */
    select?: VideoAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which VideoAnalytics to fetch.
     */
    where?: VideoAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoAnalytics to fetch.
     */
    orderBy?: VideoAnalyticsOrderByWithRelationInput | VideoAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoAnalytics.
     */
    cursor?: VideoAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoAnalytics.
     */
    distinct?: VideoAnalyticsScalarFieldEnum | VideoAnalyticsScalarFieldEnum[]
  }

  /**
   * VideoAnalytics findFirstOrThrow
   */
  export type VideoAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoAnalytics
     */
    select?: VideoAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which VideoAnalytics to fetch.
     */
    where?: VideoAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoAnalytics to fetch.
     */
    orderBy?: VideoAnalyticsOrderByWithRelationInput | VideoAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoAnalytics.
     */
    cursor?: VideoAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoAnalytics.
     */
    distinct?: VideoAnalyticsScalarFieldEnum | VideoAnalyticsScalarFieldEnum[]
  }

  /**
   * VideoAnalytics findMany
   */
  export type VideoAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoAnalytics
     */
    select?: VideoAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which VideoAnalytics to fetch.
     */
    where?: VideoAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoAnalytics to fetch.
     */
    orderBy?: VideoAnalyticsOrderByWithRelationInput | VideoAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VideoAnalytics.
     */
    cursor?: VideoAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoAnalytics.
     */
    skip?: number
    distinct?: VideoAnalyticsScalarFieldEnum | VideoAnalyticsScalarFieldEnum[]
  }

  /**
   * VideoAnalytics create
   */
  export type VideoAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoAnalytics
     */
    select?: VideoAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a VideoAnalytics.
     */
    data: XOR<VideoAnalyticsCreateInput, VideoAnalyticsUncheckedCreateInput>
  }

  /**
   * VideoAnalytics createMany
   */
  export type VideoAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VideoAnalytics.
     */
    data: VideoAnalyticsCreateManyInput | VideoAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideoAnalytics createManyAndReturn
   */
  export type VideoAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoAnalytics
     */
    select?: VideoAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VideoAnalytics.
     */
    data: VideoAnalyticsCreateManyInput | VideoAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoAnalyticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VideoAnalytics update
   */
  export type VideoAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoAnalytics
     */
    select?: VideoAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a VideoAnalytics.
     */
    data: XOR<VideoAnalyticsUpdateInput, VideoAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which VideoAnalytics to update.
     */
    where: VideoAnalyticsWhereUniqueInput
  }

  /**
   * VideoAnalytics updateMany
   */
  export type VideoAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VideoAnalytics.
     */
    data: XOR<VideoAnalyticsUpdateManyMutationInput, VideoAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which VideoAnalytics to update
     */
    where?: VideoAnalyticsWhereInput
  }

  /**
   * VideoAnalytics upsert
   */
  export type VideoAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoAnalytics
     */
    select?: VideoAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoAnalyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the VideoAnalytics to update in case it exists.
     */
    where: VideoAnalyticsWhereUniqueInput
    /**
     * In case the VideoAnalytics found by the `where` argument doesn't exist, create a new VideoAnalytics with this data.
     */
    create: XOR<VideoAnalyticsCreateInput, VideoAnalyticsUncheckedCreateInput>
    /**
     * In case the VideoAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoAnalyticsUpdateInput, VideoAnalyticsUncheckedUpdateInput>
  }

  /**
   * VideoAnalytics delete
   */
  export type VideoAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoAnalytics
     */
    select?: VideoAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoAnalyticsInclude<ExtArgs> | null
    /**
     * Filter which VideoAnalytics to delete.
     */
    where: VideoAnalyticsWhereUniqueInput
  }

  /**
   * VideoAnalytics deleteMany
   */
  export type VideoAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoAnalytics to delete
     */
    where?: VideoAnalyticsWhereInput
  }

  /**
   * VideoAnalytics without action
   */
  export type VideoAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoAnalytics
     */
    select?: VideoAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoAnalyticsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    role: 'role',
    status: 'status',
    specialty: 'specialty',
    city: 'city',
    googleId: 'googleId',
    resetToken: 'resetToken',
    resetTokenExpiry: 'resetTokenExpiry',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastLoginAt: 'lastLoginAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const TopicScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    assignedDoctorId: 'assignedDoctorId',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TopicScalarFieldEnum = (typeof TopicScalarFieldEnum)[keyof typeof TopicScalarFieldEnum]


  export const DoctorPointerScalarFieldEnum: {
    id: 'id',
    topicId: 'topicId',
    doctorId: 'doctorId',
    notes: 'notes',
    fileUrl: 'fileUrl',
    fileType: 'fileType',
    createdAt: 'createdAt'
  };

  export type DoctorPointerScalarFieldEnum = (typeof DoctorPointerScalarFieldEnum)[keyof typeof DoctorPointerScalarFieldEnum]


  export const ScriptScalarFieldEnum: {
    id: 'id',
    topicId: 'topicId',
    version: 'version',
    content: 'content',
    status: 'status',
    summary: 'summary',
    tags: 'tags',
    entities: 'entities',
    qualityScore: 'qualityScore',
    aiProcessedAt: 'aiProcessedAt',
    aiProcessingStatus: 'aiProcessingStatus',
    uploadedById: 'uploadedById',
    lockedById: 'lockedById',
    lockedAt: 'lockedAt',
    assignedReviewerId: 'assignedReviewerId',
    assignedAt: 'assignedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScriptScalarFieldEnum = (typeof ScriptScalarFieldEnum)[keyof typeof ScriptScalarFieldEnum]


  export const ScriptReviewScalarFieldEnum: {
    id: 'id',
    scriptId: 'scriptId',
    reviewerId: 'reviewerId',
    reviewerType: 'reviewerType',
    decision: 'decision',
    comments: 'comments',
    reviewedAt: 'reviewedAt',
    createdAt: 'createdAt'
  };

  export type ScriptReviewScalarFieldEnum = (typeof ScriptReviewScalarFieldEnum)[keyof typeof ScriptReviewScalarFieldEnum]


  export const VideoScalarFieldEnum: {
    id: 'id',
    topicId: 'topicId',
    scriptId: 'scriptId',
    title: 'title',
    description: 'description',
    videoUrl: 'videoUrl',
    thumbnailUrl: 'thumbnailUrl',
    duration: 'duration',
    fileSize: 'fileSize',
    doctorName: 'doctorName',
    specialty: 'specialty',
    language: 'language',
    city: 'city',
    ctaType: 'ctaType',
    tags: 'tags',
    transcript: 'transcript',
    transcriptUrl: 'transcriptUrl',
    summary: 'summary',
    shortSummary: 'shortSummary',
    keyTakeaways: 'keyTakeaways',
    entities: 'entities',
    qualityScore: 'qualityScore',
    relatedVideoIds: 'relatedVideoIds',
    aiProcessedAt: 'aiProcessedAt',
    aiProcessingStatus: 'aiProcessingStatus',
    status: 'status',
    version: 'version',
    uploadedById: 'uploadedById',
    lockedById: 'lockedById',
    lockedAt: 'lockedAt',
    publishedById: 'publishedById',
    publishedAt: 'publishedAt',
    assignedReviewerId: 'assignedReviewerId',
    assignedAt: 'assignedAt',
    deepLink: 'deepLink',
    viewCount: 'viewCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VideoScalarFieldEnum = (typeof VideoScalarFieldEnum)[keyof typeof VideoScalarFieldEnum]


  export const VideoReviewScalarFieldEnum: {
    id: 'id',
    videoId: 'videoId',
    reviewerId: 'reviewerId',
    reviewerType: 'reviewerType',
    decision: 'decision',
    comments: 'comments',
    reviewedAt: 'reviewedAt',
    createdAt: 'createdAt'
  };

  export type VideoReviewScalarFieldEnum = (typeof VideoReviewScalarFieldEnum)[keyof typeof VideoReviewScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    scriptId: 'scriptId',
    videoId: 'videoId',
    authorId: 'authorId',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    isRead: 'isRead',
    readAt: 'readAt',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    oldValue: 'oldValue',
    newValue: 'newValue',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const VideoAnalyticsScalarFieldEnum: {
    id: 'id',
    videoId: 'videoId',
    views: 'views',
    uniqueViews: 'uniqueViews',
    avgWatchTime: 'avgWatchTime',
    ctr: 'ctr',
    quizStarted: 'quizStarted',
    quizCompleted: 'quizCompleted',
    consultClicked: 'consultClicked',
    consultCompleted: 'consultCompleted',
    hookRate3s: 'hookRate3s',
    hookRate5s: 'hookRate5s',
    updatedAt: 'updatedAt'
  };

  export type VideoAnalyticsScalarFieldEnum = (typeof VideoAnalyticsScalarFieldEnum)[keyof typeof VideoAnalyticsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'TopicStatus'
   */
  export type EnumTopicStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TopicStatus'>
    


  /**
   * Reference to a field of type 'TopicStatus[]'
   */
  export type ListEnumTopicStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TopicStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ScriptStatus'
   */
  export type EnumScriptStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScriptStatus'>
    


  /**
   * Reference to a field of type 'ScriptStatus[]'
   */
  export type ListEnumScriptStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScriptStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'ReviewDecision'
   */
  export type EnumReviewDecisionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewDecision'>
    


  /**
   * Reference to a field of type 'ReviewDecision[]'
   */
  export type ListEnumReviewDecisionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewDecision[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'CTAType'
   */
  export type EnumCTATypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CTAType'>
    


  /**
   * Reference to a field of type 'CTAType[]'
   */
  export type ListEnumCTATypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CTAType[]'>
    


  /**
   * Reference to a field of type 'VideoStatus'
   */
  export type EnumVideoStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VideoStatus'>
    


  /**
   * Reference to a field of type 'VideoStatus[]'
   */
  export type ListEnumVideoStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VideoStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    specialty?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    googleId?: StringNullableFilter<"User"> | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    assignedTopics?: TopicListRelationFilter
    createdTopics?: TopicListRelationFilter
    doctorPointers?: DoctorPointerListRelationFilter
    uploadedScripts?: ScriptListRelationFilter
    lockedScripts?: ScriptListRelationFilter
    assignedScripts?: ScriptListRelationFilter
    scriptReviews?: ScriptReviewListRelationFilter
    uploadedVideos?: VideoListRelationFilter
    lockedVideos?: VideoListRelationFilter
    publishedVideos?: VideoListRelationFilter
    assignedVideos?: VideoListRelationFilter
    videoReviews?: VideoReviewListRelationFilter
    comments?: CommentListRelationFilter
    notifications?: NotificationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    specialty?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    googleId?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    assignedTopics?: TopicOrderByRelationAggregateInput
    createdTopics?: TopicOrderByRelationAggregateInput
    doctorPointers?: DoctorPointerOrderByRelationAggregateInput
    uploadedScripts?: ScriptOrderByRelationAggregateInput
    lockedScripts?: ScriptOrderByRelationAggregateInput
    assignedScripts?: ScriptOrderByRelationAggregateInput
    scriptReviews?: ScriptReviewOrderByRelationAggregateInput
    uploadedVideos?: VideoOrderByRelationAggregateInput
    lockedVideos?: VideoOrderByRelationAggregateInput
    publishedVideos?: VideoOrderByRelationAggregateInput
    assignedVideos?: VideoOrderByRelationAggregateInput
    videoReviews?: VideoReviewOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    googleId?: string
    resetToken?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    specialty?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    assignedTopics?: TopicListRelationFilter
    createdTopics?: TopicListRelationFilter
    doctorPointers?: DoctorPointerListRelationFilter
    uploadedScripts?: ScriptListRelationFilter
    lockedScripts?: ScriptListRelationFilter
    assignedScripts?: ScriptListRelationFilter
    scriptReviews?: ScriptReviewListRelationFilter
    uploadedVideos?: VideoListRelationFilter
    lockedVideos?: VideoListRelationFilter
    publishedVideos?: VideoListRelationFilter
    assignedVideos?: VideoListRelationFilter
    videoReviews?: VideoReviewListRelationFilter
    comments?: CommentListRelationFilter
    notifications?: NotificationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }, "id" | "email" | "googleId" | "resetToken">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    specialty?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    googleId?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    specialty?: StringNullableWithAggregatesFilter<"User"> | string | null
    city?: StringNullableWithAggregatesFilter<"User"> | string | null
    googleId?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type TopicWhereInput = {
    AND?: TopicWhereInput | TopicWhereInput[]
    OR?: TopicWhereInput[]
    NOT?: TopicWhereInput | TopicWhereInput[]
    id?: StringFilter<"Topic"> | string
    title?: StringFilter<"Topic"> | string
    description?: StringFilter<"Topic"> | string
    status?: EnumTopicStatusFilter<"Topic"> | $Enums.TopicStatus
    assignedDoctorId?: StringFilter<"Topic"> | string
    createdById?: StringFilter<"Topic"> | string
    createdAt?: DateTimeFilter<"Topic"> | Date | string
    updatedAt?: DateTimeFilter<"Topic"> | Date | string
    assignedDoctor?: XOR<UserRelationFilter, UserWhereInput>
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    doctorPointers?: DoctorPointerListRelationFilter
    scripts?: ScriptListRelationFilter
    videos?: VideoListRelationFilter
  }

  export type TopicOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    assignedDoctorId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedDoctor?: UserOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    doctorPointers?: DoctorPointerOrderByRelationAggregateInput
    scripts?: ScriptOrderByRelationAggregateInput
    videos?: VideoOrderByRelationAggregateInput
  }

  export type TopicWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TopicWhereInput | TopicWhereInput[]
    OR?: TopicWhereInput[]
    NOT?: TopicWhereInput | TopicWhereInput[]
    title?: StringFilter<"Topic"> | string
    description?: StringFilter<"Topic"> | string
    status?: EnumTopicStatusFilter<"Topic"> | $Enums.TopicStatus
    assignedDoctorId?: StringFilter<"Topic"> | string
    createdById?: StringFilter<"Topic"> | string
    createdAt?: DateTimeFilter<"Topic"> | Date | string
    updatedAt?: DateTimeFilter<"Topic"> | Date | string
    assignedDoctor?: XOR<UserRelationFilter, UserWhereInput>
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    doctorPointers?: DoctorPointerListRelationFilter
    scripts?: ScriptListRelationFilter
    videos?: VideoListRelationFilter
  }, "id">

  export type TopicOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    assignedDoctorId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TopicCountOrderByAggregateInput
    _max?: TopicMaxOrderByAggregateInput
    _min?: TopicMinOrderByAggregateInput
  }

  export type TopicScalarWhereWithAggregatesInput = {
    AND?: TopicScalarWhereWithAggregatesInput | TopicScalarWhereWithAggregatesInput[]
    OR?: TopicScalarWhereWithAggregatesInput[]
    NOT?: TopicScalarWhereWithAggregatesInput | TopicScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Topic"> | string
    title?: StringWithAggregatesFilter<"Topic"> | string
    description?: StringWithAggregatesFilter<"Topic"> | string
    status?: EnumTopicStatusWithAggregatesFilter<"Topic"> | $Enums.TopicStatus
    assignedDoctorId?: StringWithAggregatesFilter<"Topic"> | string
    createdById?: StringWithAggregatesFilter<"Topic"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Topic"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Topic"> | Date | string
  }

  export type DoctorPointerWhereInput = {
    AND?: DoctorPointerWhereInput | DoctorPointerWhereInput[]
    OR?: DoctorPointerWhereInput[]
    NOT?: DoctorPointerWhereInput | DoctorPointerWhereInput[]
    id?: StringFilter<"DoctorPointer"> | string
    topicId?: StringFilter<"DoctorPointer"> | string
    doctorId?: StringFilter<"DoctorPointer"> | string
    notes?: StringNullableFilter<"DoctorPointer"> | string | null
    fileUrl?: StringNullableFilter<"DoctorPointer"> | string | null
    fileType?: StringNullableFilter<"DoctorPointer"> | string | null
    createdAt?: DateTimeFilter<"DoctorPointer"> | Date | string
    topic?: XOR<TopicRelationFilter, TopicWhereInput>
    doctor?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DoctorPointerOrderByWithRelationInput = {
    id?: SortOrder
    topicId?: SortOrder
    doctorId?: SortOrder
    notes?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    fileType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    topic?: TopicOrderByWithRelationInput
    doctor?: UserOrderByWithRelationInput
  }

  export type DoctorPointerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DoctorPointerWhereInput | DoctorPointerWhereInput[]
    OR?: DoctorPointerWhereInput[]
    NOT?: DoctorPointerWhereInput | DoctorPointerWhereInput[]
    topicId?: StringFilter<"DoctorPointer"> | string
    doctorId?: StringFilter<"DoctorPointer"> | string
    notes?: StringNullableFilter<"DoctorPointer"> | string | null
    fileUrl?: StringNullableFilter<"DoctorPointer"> | string | null
    fileType?: StringNullableFilter<"DoctorPointer"> | string | null
    createdAt?: DateTimeFilter<"DoctorPointer"> | Date | string
    topic?: XOR<TopicRelationFilter, TopicWhereInput>
    doctor?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type DoctorPointerOrderByWithAggregationInput = {
    id?: SortOrder
    topicId?: SortOrder
    doctorId?: SortOrder
    notes?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    fileType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DoctorPointerCountOrderByAggregateInput
    _max?: DoctorPointerMaxOrderByAggregateInput
    _min?: DoctorPointerMinOrderByAggregateInput
  }

  export type DoctorPointerScalarWhereWithAggregatesInput = {
    AND?: DoctorPointerScalarWhereWithAggregatesInput | DoctorPointerScalarWhereWithAggregatesInput[]
    OR?: DoctorPointerScalarWhereWithAggregatesInput[]
    NOT?: DoctorPointerScalarWhereWithAggregatesInput | DoctorPointerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DoctorPointer"> | string
    topicId?: StringWithAggregatesFilter<"DoctorPointer"> | string
    doctorId?: StringWithAggregatesFilter<"DoctorPointer"> | string
    notes?: StringNullableWithAggregatesFilter<"DoctorPointer"> | string | null
    fileUrl?: StringNullableWithAggregatesFilter<"DoctorPointer"> | string | null
    fileType?: StringNullableWithAggregatesFilter<"DoctorPointer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DoctorPointer"> | Date | string
  }

  export type ScriptWhereInput = {
    AND?: ScriptWhereInput | ScriptWhereInput[]
    OR?: ScriptWhereInput[]
    NOT?: ScriptWhereInput | ScriptWhereInput[]
    id?: StringFilter<"Script"> | string
    topicId?: StringFilter<"Script"> | string
    version?: IntFilter<"Script"> | number
    content?: StringFilter<"Script"> | string
    status?: EnumScriptStatusFilter<"Script"> | $Enums.ScriptStatus
    summary?: StringNullableFilter<"Script"> | string | null
    tags?: StringNullableListFilter<"Script">
    entities?: JsonNullableFilter<"Script">
    qualityScore?: IntNullableFilter<"Script"> | number | null
    aiProcessedAt?: DateTimeNullableFilter<"Script"> | Date | string | null
    aiProcessingStatus?: StringNullableFilter<"Script"> | string | null
    uploadedById?: StringNullableFilter<"Script"> | string | null
    lockedById?: StringNullableFilter<"Script"> | string | null
    lockedAt?: DateTimeNullableFilter<"Script"> | Date | string | null
    assignedReviewerId?: StringNullableFilter<"Script"> | string | null
    assignedAt?: DateTimeNullableFilter<"Script"> | Date | string | null
    createdAt?: DateTimeFilter<"Script"> | Date | string
    updatedAt?: DateTimeFilter<"Script"> | Date | string
    topic?: XOR<TopicRelationFilter, TopicWhereInput>
    uploadedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    lockedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    assignedReviewer?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    reviews?: ScriptReviewListRelationFilter
    comments?: CommentListRelationFilter
    videos?: VideoListRelationFilter
  }

  export type ScriptOrderByWithRelationInput = {
    id?: SortOrder
    topicId?: SortOrder
    version?: SortOrder
    content?: SortOrder
    status?: SortOrder
    summary?: SortOrderInput | SortOrder
    tags?: SortOrder
    entities?: SortOrderInput | SortOrder
    qualityScore?: SortOrderInput | SortOrder
    aiProcessedAt?: SortOrderInput | SortOrder
    aiProcessingStatus?: SortOrderInput | SortOrder
    uploadedById?: SortOrderInput | SortOrder
    lockedById?: SortOrderInput | SortOrder
    lockedAt?: SortOrderInput | SortOrder
    assignedReviewerId?: SortOrderInput | SortOrder
    assignedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    topic?: TopicOrderByWithRelationInput
    uploadedBy?: UserOrderByWithRelationInput
    lockedBy?: UserOrderByWithRelationInput
    assignedReviewer?: UserOrderByWithRelationInput
    reviews?: ScriptReviewOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    videos?: VideoOrderByRelationAggregateInput
  }

  export type ScriptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    topicId_version?: ScriptTopicIdVersionCompoundUniqueInput
    AND?: ScriptWhereInput | ScriptWhereInput[]
    OR?: ScriptWhereInput[]
    NOT?: ScriptWhereInput | ScriptWhereInput[]
    topicId?: StringFilter<"Script"> | string
    version?: IntFilter<"Script"> | number
    content?: StringFilter<"Script"> | string
    status?: EnumScriptStatusFilter<"Script"> | $Enums.ScriptStatus
    summary?: StringNullableFilter<"Script"> | string | null
    tags?: StringNullableListFilter<"Script">
    entities?: JsonNullableFilter<"Script">
    qualityScore?: IntNullableFilter<"Script"> | number | null
    aiProcessedAt?: DateTimeNullableFilter<"Script"> | Date | string | null
    aiProcessingStatus?: StringNullableFilter<"Script"> | string | null
    uploadedById?: StringNullableFilter<"Script"> | string | null
    lockedById?: StringNullableFilter<"Script"> | string | null
    lockedAt?: DateTimeNullableFilter<"Script"> | Date | string | null
    assignedReviewerId?: StringNullableFilter<"Script"> | string | null
    assignedAt?: DateTimeNullableFilter<"Script"> | Date | string | null
    createdAt?: DateTimeFilter<"Script"> | Date | string
    updatedAt?: DateTimeFilter<"Script"> | Date | string
    topic?: XOR<TopicRelationFilter, TopicWhereInput>
    uploadedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    lockedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    assignedReviewer?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    reviews?: ScriptReviewListRelationFilter
    comments?: CommentListRelationFilter
    videos?: VideoListRelationFilter
  }, "id" | "topicId_version">

  export type ScriptOrderByWithAggregationInput = {
    id?: SortOrder
    topicId?: SortOrder
    version?: SortOrder
    content?: SortOrder
    status?: SortOrder
    summary?: SortOrderInput | SortOrder
    tags?: SortOrder
    entities?: SortOrderInput | SortOrder
    qualityScore?: SortOrderInput | SortOrder
    aiProcessedAt?: SortOrderInput | SortOrder
    aiProcessingStatus?: SortOrderInput | SortOrder
    uploadedById?: SortOrderInput | SortOrder
    lockedById?: SortOrderInput | SortOrder
    lockedAt?: SortOrderInput | SortOrder
    assignedReviewerId?: SortOrderInput | SortOrder
    assignedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScriptCountOrderByAggregateInput
    _avg?: ScriptAvgOrderByAggregateInput
    _max?: ScriptMaxOrderByAggregateInput
    _min?: ScriptMinOrderByAggregateInput
    _sum?: ScriptSumOrderByAggregateInput
  }

  export type ScriptScalarWhereWithAggregatesInput = {
    AND?: ScriptScalarWhereWithAggregatesInput | ScriptScalarWhereWithAggregatesInput[]
    OR?: ScriptScalarWhereWithAggregatesInput[]
    NOT?: ScriptScalarWhereWithAggregatesInput | ScriptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Script"> | string
    topicId?: StringWithAggregatesFilter<"Script"> | string
    version?: IntWithAggregatesFilter<"Script"> | number
    content?: StringWithAggregatesFilter<"Script"> | string
    status?: EnumScriptStatusWithAggregatesFilter<"Script"> | $Enums.ScriptStatus
    summary?: StringNullableWithAggregatesFilter<"Script"> | string | null
    tags?: StringNullableListFilter<"Script">
    entities?: JsonNullableWithAggregatesFilter<"Script">
    qualityScore?: IntNullableWithAggregatesFilter<"Script"> | number | null
    aiProcessedAt?: DateTimeNullableWithAggregatesFilter<"Script"> | Date | string | null
    aiProcessingStatus?: StringNullableWithAggregatesFilter<"Script"> | string | null
    uploadedById?: StringNullableWithAggregatesFilter<"Script"> | string | null
    lockedById?: StringNullableWithAggregatesFilter<"Script"> | string | null
    lockedAt?: DateTimeNullableWithAggregatesFilter<"Script"> | Date | string | null
    assignedReviewerId?: StringNullableWithAggregatesFilter<"Script"> | string | null
    assignedAt?: DateTimeNullableWithAggregatesFilter<"Script"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Script"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Script"> | Date | string
  }

  export type ScriptReviewWhereInput = {
    AND?: ScriptReviewWhereInput | ScriptReviewWhereInput[]
    OR?: ScriptReviewWhereInput[]
    NOT?: ScriptReviewWhereInput | ScriptReviewWhereInput[]
    id?: StringFilter<"ScriptReview"> | string
    scriptId?: StringFilter<"ScriptReview"> | string
    reviewerId?: StringFilter<"ScriptReview"> | string
    reviewerType?: EnumUserRoleFilter<"ScriptReview"> | $Enums.UserRole
    decision?: EnumReviewDecisionFilter<"ScriptReview"> | $Enums.ReviewDecision
    comments?: StringNullableFilter<"ScriptReview"> | string | null
    reviewedAt?: DateTimeNullableFilter<"ScriptReview"> | Date | string | null
    createdAt?: DateTimeFilter<"ScriptReview"> | Date | string
    script?: XOR<ScriptRelationFilter, ScriptWhereInput>
    reviewer?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ScriptReviewOrderByWithRelationInput = {
    id?: SortOrder
    scriptId?: SortOrder
    reviewerId?: SortOrder
    reviewerType?: SortOrder
    decision?: SortOrder
    comments?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    script?: ScriptOrderByWithRelationInput
    reviewer?: UserOrderByWithRelationInput
  }

  export type ScriptReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScriptReviewWhereInput | ScriptReviewWhereInput[]
    OR?: ScriptReviewWhereInput[]
    NOT?: ScriptReviewWhereInput | ScriptReviewWhereInput[]
    scriptId?: StringFilter<"ScriptReview"> | string
    reviewerId?: StringFilter<"ScriptReview"> | string
    reviewerType?: EnumUserRoleFilter<"ScriptReview"> | $Enums.UserRole
    decision?: EnumReviewDecisionFilter<"ScriptReview"> | $Enums.ReviewDecision
    comments?: StringNullableFilter<"ScriptReview"> | string | null
    reviewedAt?: DateTimeNullableFilter<"ScriptReview"> | Date | string | null
    createdAt?: DateTimeFilter<"ScriptReview"> | Date | string
    script?: XOR<ScriptRelationFilter, ScriptWhereInput>
    reviewer?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ScriptReviewOrderByWithAggregationInput = {
    id?: SortOrder
    scriptId?: SortOrder
    reviewerId?: SortOrder
    reviewerType?: SortOrder
    decision?: SortOrder
    comments?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ScriptReviewCountOrderByAggregateInput
    _max?: ScriptReviewMaxOrderByAggregateInput
    _min?: ScriptReviewMinOrderByAggregateInput
  }

  export type ScriptReviewScalarWhereWithAggregatesInput = {
    AND?: ScriptReviewScalarWhereWithAggregatesInput | ScriptReviewScalarWhereWithAggregatesInput[]
    OR?: ScriptReviewScalarWhereWithAggregatesInput[]
    NOT?: ScriptReviewScalarWhereWithAggregatesInput | ScriptReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScriptReview"> | string
    scriptId?: StringWithAggregatesFilter<"ScriptReview"> | string
    reviewerId?: StringWithAggregatesFilter<"ScriptReview"> | string
    reviewerType?: EnumUserRoleWithAggregatesFilter<"ScriptReview"> | $Enums.UserRole
    decision?: EnumReviewDecisionWithAggregatesFilter<"ScriptReview"> | $Enums.ReviewDecision
    comments?: StringNullableWithAggregatesFilter<"ScriptReview"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"ScriptReview"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ScriptReview"> | Date | string
  }

  export type VideoWhereInput = {
    AND?: VideoWhereInput | VideoWhereInput[]
    OR?: VideoWhereInput[]
    NOT?: VideoWhereInput | VideoWhereInput[]
    id?: StringFilter<"Video"> | string
    topicId?: StringFilter<"Video"> | string
    scriptId?: StringNullableFilter<"Video"> | string | null
    title?: StringFilter<"Video"> | string
    description?: StringNullableFilter<"Video"> | string | null
    videoUrl?: StringFilter<"Video"> | string
    thumbnailUrl?: StringNullableFilter<"Video"> | string | null
    duration?: IntNullableFilter<"Video"> | number | null
    fileSize?: BigIntNullableFilter<"Video"> | bigint | number | null
    doctorName?: StringFilter<"Video"> | string
    specialty?: StringFilter<"Video"> | string
    language?: StringFilter<"Video"> | string
    city?: StringFilter<"Video"> | string
    ctaType?: EnumCTATypeFilter<"Video"> | $Enums.CTAType
    tags?: StringNullableListFilter<"Video">
    transcript?: StringNullableFilter<"Video"> | string | null
    transcriptUrl?: StringNullableFilter<"Video"> | string | null
    summary?: StringNullableFilter<"Video"> | string | null
    shortSummary?: StringNullableFilter<"Video"> | string | null
    keyTakeaways?: StringNullableListFilter<"Video">
    entities?: JsonNullableFilter<"Video">
    qualityScore?: IntNullableFilter<"Video"> | number | null
    relatedVideoIds?: StringNullableListFilter<"Video">
    aiProcessedAt?: DateTimeNullableFilter<"Video"> | Date | string | null
    aiProcessingStatus?: StringNullableFilter<"Video"> | string | null
    status?: EnumVideoStatusFilter<"Video"> | $Enums.VideoStatus
    version?: IntFilter<"Video"> | number
    uploadedById?: StringNullableFilter<"Video"> | string | null
    lockedById?: StringNullableFilter<"Video"> | string | null
    lockedAt?: DateTimeNullableFilter<"Video"> | Date | string | null
    publishedById?: StringNullableFilter<"Video"> | string | null
    publishedAt?: DateTimeNullableFilter<"Video"> | Date | string | null
    assignedReviewerId?: StringNullableFilter<"Video"> | string | null
    assignedAt?: DateTimeNullableFilter<"Video"> | Date | string | null
    deepLink?: StringNullableFilter<"Video"> | string | null
    viewCount?: IntFilter<"Video"> | number
    createdAt?: DateTimeFilter<"Video"> | Date | string
    updatedAt?: DateTimeFilter<"Video"> | Date | string
    topic?: XOR<TopicRelationFilter, TopicWhereInput>
    script?: XOR<ScriptNullableRelationFilter, ScriptWhereInput> | null
    uploadedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    lockedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    publishedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    assignedReviewer?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    reviews?: VideoReviewListRelationFilter
    comments?: CommentListRelationFilter
    analytics?: XOR<VideoAnalyticsNullableRelationFilter, VideoAnalyticsWhereInput> | null
  }

  export type VideoOrderByWithRelationInput = {
    id?: SortOrder
    topicId?: SortOrder
    scriptId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    videoUrl?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    doctorName?: SortOrder
    specialty?: SortOrder
    language?: SortOrder
    city?: SortOrder
    ctaType?: SortOrder
    tags?: SortOrder
    transcript?: SortOrderInput | SortOrder
    transcriptUrl?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    shortSummary?: SortOrderInput | SortOrder
    keyTakeaways?: SortOrder
    entities?: SortOrderInput | SortOrder
    qualityScore?: SortOrderInput | SortOrder
    relatedVideoIds?: SortOrder
    aiProcessedAt?: SortOrderInput | SortOrder
    aiProcessingStatus?: SortOrderInput | SortOrder
    status?: SortOrder
    version?: SortOrder
    uploadedById?: SortOrderInput | SortOrder
    lockedById?: SortOrderInput | SortOrder
    lockedAt?: SortOrderInput | SortOrder
    publishedById?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    assignedReviewerId?: SortOrderInput | SortOrder
    assignedAt?: SortOrderInput | SortOrder
    deepLink?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    topic?: TopicOrderByWithRelationInput
    script?: ScriptOrderByWithRelationInput
    uploadedBy?: UserOrderByWithRelationInput
    lockedBy?: UserOrderByWithRelationInput
    publishedBy?: UserOrderByWithRelationInput
    assignedReviewer?: UserOrderByWithRelationInput
    reviews?: VideoReviewOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    analytics?: VideoAnalyticsOrderByWithRelationInput
  }

  export type VideoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    topicId_version?: VideoTopicIdVersionCompoundUniqueInput
    AND?: VideoWhereInput | VideoWhereInput[]
    OR?: VideoWhereInput[]
    NOT?: VideoWhereInput | VideoWhereInput[]
    topicId?: StringFilter<"Video"> | string
    scriptId?: StringNullableFilter<"Video"> | string | null
    title?: StringFilter<"Video"> | string
    description?: StringNullableFilter<"Video"> | string | null
    videoUrl?: StringFilter<"Video"> | string
    thumbnailUrl?: StringNullableFilter<"Video"> | string | null
    duration?: IntNullableFilter<"Video"> | number | null
    fileSize?: BigIntNullableFilter<"Video"> | bigint | number | null
    doctorName?: StringFilter<"Video"> | string
    specialty?: StringFilter<"Video"> | string
    language?: StringFilter<"Video"> | string
    city?: StringFilter<"Video"> | string
    ctaType?: EnumCTATypeFilter<"Video"> | $Enums.CTAType
    tags?: StringNullableListFilter<"Video">
    transcript?: StringNullableFilter<"Video"> | string | null
    transcriptUrl?: StringNullableFilter<"Video"> | string | null
    summary?: StringNullableFilter<"Video"> | string | null
    shortSummary?: StringNullableFilter<"Video"> | string | null
    keyTakeaways?: StringNullableListFilter<"Video">
    entities?: JsonNullableFilter<"Video">
    qualityScore?: IntNullableFilter<"Video"> | number | null
    relatedVideoIds?: StringNullableListFilter<"Video">
    aiProcessedAt?: DateTimeNullableFilter<"Video"> | Date | string | null
    aiProcessingStatus?: StringNullableFilter<"Video"> | string | null
    status?: EnumVideoStatusFilter<"Video"> | $Enums.VideoStatus
    version?: IntFilter<"Video"> | number
    uploadedById?: StringNullableFilter<"Video"> | string | null
    lockedById?: StringNullableFilter<"Video"> | string | null
    lockedAt?: DateTimeNullableFilter<"Video"> | Date | string | null
    publishedById?: StringNullableFilter<"Video"> | string | null
    publishedAt?: DateTimeNullableFilter<"Video"> | Date | string | null
    assignedReviewerId?: StringNullableFilter<"Video"> | string | null
    assignedAt?: DateTimeNullableFilter<"Video"> | Date | string | null
    deepLink?: StringNullableFilter<"Video"> | string | null
    viewCount?: IntFilter<"Video"> | number
    createdAt?: DateTimeFilter<"Video"> | Date | string
    updatedAt?: DateTimeFilter<"Video"> | Date | string
    topic?: XOR<TopicRelationFilter, TopicWhereInput>
    script?: XOR<ScriptNullableRelationFilter, ScriptWhereInput> | null
    uploadedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    lockedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    publishedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    assignedReviewer?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    reviews?: VideoReviewListRelationFilter
    comments?: CommentListRelationFilter
    analytics?: XOR<VideoAnalyticsNullableRelationFilter, VideoAnalyticsWhereInput> | null
  }, "id" | "topicId_version">

  export type VideoOrderByWithAggregationInput = {
    id?: SortOrder
    topicId?: SortOrder
    scriptId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    videoUrl?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    doctorName?: SortOrder
    specialty?: SortOrder
    language?: SortOrder
    city?: SortOrder
    ctaType?: SortOrder
    tags?: SortOrder
    transcript?: SortOrderInput | SortOrder
    transcriptUrl?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    shortSummary?: SortOrderInput | SortOrder
    keyTakeaways?: SortOrder
    entities?: SortOrderInput | SortOrder
    qualityScore?: SortOrderInput | SortOrder
    relatedVideoIds?: SortOrder
    aiProcessedAt?: SortOrderInput | SortOrder
    aiProcessingStatus?: SortOrderInput | SortOrder
    status?: SortOrder
    version?: SortOrder
    uploadedById?: SortOrderInput | SortOrder
    lockedById?: SortOrderInput | SortOrder
    lockedAt?: SortOrderInput | SortOrder
    publishedById?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    assignedReviewerId?: SortOrderInput | SortOrder
    assignedAt?: SortOrderInput | SortOrder
    deepLink?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VideoCountOrderByAggregateInput
    _avg?: VideoAvgOrderByAggregateInput
    _max?: VideoMaxOrderByAggregateInput
    _min?: VideoMinOrderByAggregateInput
    _sum?: VideoSumOrderByAggregateInput
  }

  export type VideoScalarWhereWithAggregatesInput = {
    AND?: VideoScalarWhereWithAggregatesInput | VideoScalarWhereWithAggregatesInput[]
    OR?: VideoScalarWhereWithAggregatesInput[]
    NOT?: VideoScalarWhereWithAggregatesInput | VideoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Video"> | string
    topicId?: StringWithAggregatesFilter<"Video"> | string
    scriptId?: StringNullableWithAggregatesFilter<"Video"> | string | null
    title?: StringWithAggregatesFilter<"Video"> | string
    description?: StringNullableWithAggregatesFilter<"Video"> | string | null
    videoUrl?: StringWithAggregatesFilter<"Video"> | string
    thumbnailUrl?: StringNullableWithAggregatesFilter<"Video"> | string | null
    duration?: IntNullableWithAggregatesFilter<"Video"> | number | null
    fileSize?: BigIntNullableWithAggregatesFilter<"Video"> | bigint | number | null
    doctorName?: StringWithAggregatesFilter<"Video"> | string
    specialty?: StringWithAggregatesFilter<"Video"> | string
    language?: StringWithAggregatesFilter<"Video"> | string
    city?: StringWithAggregatesFilter<"Video"> | string
    ctaType?: EnumCTATypeWithAggregatesFilter<"Video"> | $Enums.CTAType
    tags?: StringNullableListFilter<"Video">
    transcript?: StringNullableWithAggregatesFilter<"Video"> | string | null
    transcriptUrl?: StringNullableWithAggregatesFilter<"Video"> | string | null
    summary?: StringNullableWithAggregatesFilter<"Video"> | string | null
    shortSummary?: StringNullableWithAggregatesFilter<"Video"> | string | null
    keyTakeaways?: StringNullableListFilter<"Video">
    entities?: JsonNullableWithAggregatesFilter<"Video">
    qualityScore?: IntNullableWithAggregatesFilter<"Video"> | number | null
    relatedVideoIds?: StringNullableListFilter<"Video">
    aiProcessedAt?: DateTimeNullableWithAggregatesFilter<"Video"> | Date | string | null
    aiProcessingStatus?: StringNullableWithAggregatesFilter<"Video"> | string | null
    status?: EnumVideoStatusWithAggregatesFilter<"Video"> | $Enums.VideoStatus
    version?: IntWithAggregatesFilter<"Video"> | number
    uploadedById?: StringNullableWithAggregatesFilter<"Video"> | string | null
    lockedById?: StringNullableWithAggregatesFilter<"Video"> | string | null
    lockedAt?: DateTimeNullableWithAggregatesFilter<"Video"> | Date | string | null
    publishedById?: StringNullableWithAggregatesFilter<"Video"> | string | null
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Video"> | Date | string | null
    assignedReviewerId?: StringNullableWithAggregatesFilter<"Video"> | string | null
    assignedAt?: DateTimeNullableWithAggregatesFilter<"Video"> | Date | string | null
    deepLink?: StringNullableWithAggregatesFilter<"Video"> | string | null
    viewCount?: IntWithAggregatesFilter<"Video"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Video"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Video"> | Date | string
  }

  export type VideoReviewWhereInput = {
    AND?: VideoReviewWhereInput | VideoReviewWhereInput[]
    OR?: VideoReviewWhereInput[]
    NOT?: VideoReviewWhereInput | VideoReviewWhereInput[]
    id?: StringFilter<"VideoReview"> | string
    videoId?: StringFilter<"VideoReview"> | string
    reviewerId?: StringFilter<"VideoReview"> | string
    reviewerType?: EnumUserRoleFilter<"VideoReview"> | $Enums.UserRole
    decision?: EnumReviewDecisionFilter<"VideoReview"> | $Enums.ReviewDecision
    comments?: StringNullableFilter<"VideoReview"> | string | null
    reviewedAt?: DateTimeNullableFilter<"VideoReview"> | Date | string | null
    createdAt?: DateTimeFilter<"VideoReview"> | Date | string
    video?: XOR<VideoRelationFilter, VideoWhereInput>
    reviewer?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type VideoReviewOrderByWithRelationInput = {
    id?: SortOrder
    videoId?: SortOrder
    reviewerId?: SortOrder
    reviewerType?: SortOrder
    decision?: SortOrder
    comments?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    video?: VideoOrderByWithRelationInput
    reviewer?: UserOrderByWithRelationInput
  }

  export type VideoReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VideoReviewWhereInput | VideoReviewWhereInput[]
    OR?: VideoReviewWhereInput[]
    NOT?: VideoReviewWhereInput | VideoReviewWhereInput[]
    videoId?: StringFilter<"VideoReview"> | string
    reviewerId?: StringFilter<"VideoReview"> | string
    reviewerType?: EnumUserRoleFilter<"VideoReview"> | $Enums.UserRole
    decision?: EnumReviewDecisionFilter<"VideoReview"> | $Enums.ReviewDecision
    comments?: StringNullableFilter<"VideoReview"> | string | null
    reviewedAt?: DateTimeNullableFilter<"VideoReview"> | Date | string | null
    createdAt?: DateTimeFilter<"VideoReview"> | Date | string
    video?: XOR<VideoRelationFilter, VideoWhereInput>
    reviewer?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type VideoReviewOrderByWithAggregationInput = {
    id?: SortOrder
    videoId?: SortOrder
    reviewerId?: SortOrder
    reviewerType?: SortOrder
    decision?: SortOrder
    comments?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: VideoReviewCountOrderByAggregateInput
    _max?: VideoReviewMaxOrderByAggregateInput
    _min?: VideoReviewMinOrderByAggregateInput
  }

  export type VideoReviewScalarWhereWithAggregatesInput = {
    AND?: VideoReviewScalarWhereWithAggregatesInput | VideoReviewScalarWhereWithAggregatesInput[]
    OR?: VideoReviewScalarWhereWithAggregatesInput[]
    NOT?: VideoReviewScalarWhereWithAggregatesInput | VideoReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VideoReview"> | string
    videoId?: StringWithAggregatesFilter<"VideoReview"> | string
    reviewerId?: StringWithAggregatesFilter<"VideoReview"> | string
    reviewerType?: EnumUserRoleWithAggregatesFilter<"VideoReview"> | $Enums.UserRole
    decision?: EnumReviewDecisionWithAggregatesFilter<"VideoReview"> | $Enums.ReviewDecision
    comments?: StringNullableWithAggregatesFilter<"VideoReview"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"VideoReview"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VideoReview"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    scriptId?: StringNullableFilter<"Comment"> | string | null
    videoId?: StringNullableFilter<"Comment"> | string | null
    authorId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    script?: XOR<ScriptNullableRelationFilter, ScriptWhereInput> | null
    video?: XOR<VideoNullableRelationFilter, VideoWhereInput> | null
    author?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    scriptId?: SortOrderInput | SortOrder
    videoId?: SortOrderInput | SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    script?: ScriptOrderByWithRelationInput
    video?: VideoOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    scriptId?: StringNullableFilter<"Comment"> | string | null
    videoId?: StringNullableFilter<"Comment"> | string | null
    authorId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    script?: XOR<ScriptNullableRelationFilter, ScriptWhereInput> | null
    video?: XOR<VideoNullableRelationFilter, VideoWhereInput> | null
    author?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    scriptId?: SortOrderInput | SortOrder
    videoId?: SortOrderInput | SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    scriptId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    videoId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    authorId?: StringWithAggregatesFilter<"Comment"> | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    oldValue?: JsonNullableFilter<"AuditLog">
    newValue?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    oldValue?: JsonNullableFilter<"AuditLog">
    newValue?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    oldValue?: JsonNullableWithAggregatesFilter<"AuditLog">
    newValue?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type VideoAnalyticsWhereInput = {
    AND?: VideoAnalyticsWhereInput | VideoAnalyticsWhereInput[]
    OR?: VideoAnalyticsWhereInput[]
    NOT?: VideoAnalyticsWhereInput | VideoAnalyticsWhereInput[]
    id?: StringFilter<"VideoAnalytics"> | string
    videoId?: StringFilter<"VideoAnalytics"> | string
    views?: IntFilter<"VideoAnalytics"> | number
    uniqueViews?: IntFilter<"VideoAnalytics"> | number
    avgWatchTime?: FloatFilter<"VideoAnalytics"> | number
    ctr?: FloatFilter<"VideoAnalytics"> | number
    quizStarted?: IntFilter<"VideoAnalytics"> | number
    quizCompleted?: IntFilter<"VideoAnalytics"> | number
    consultClicked?: IntFilter<"VideoAnalytics"> | number
    consultCompleted?: IntFilter<"VideoAnalytics"> | number
    hookRate3s?: FloatFilter<"VideoAnalytics"> | number
    hookRate5s?: FloatFilter<"VideoAnalytics"> | number
    updatedAt?: DateTimeFilter<"VideoAnalytics"> | Date | string
    video?: XOR<VideoRelationFilter, VideoWhereInput>
  }

  export type VideoAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    videoId?: SortOrder
    views?: SortOrder
    uniqueViews?: SortOrder
    avgWatchTime?: SortOrder
    ctr?: SortOrder
    quizStarted?: SortOrder
    quizCompleted?: SortOrder
    consultClicked?: SortOrder
    consultCompleted?: SortOrder
    hookRate3s?: SortOrder
    hookRate5s?: SortOrder
    updatedAt?: SortOrder
    video?: VideoOrderByWithRelationInput
  }

  export type VideoAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    videoId?: string
    AND?: VideoAnalyticsWhereInput | VideoAnalyticsWhereInput[]
    OR?: VideoAnalyticsWhereInput[]
    NOT?: VideoAnalyticsWhereInput | VideoAnalyticsWhereInput[]
    views?: IntFilter<"VideoAnalytics"> | number
    uniqueViews?: IntFilter<"VideoAnalytics"> | number
    avgWatchTime?: FloatFilter<"VideoAnalytics"> | number
    ctr?: FloatFilter<"VideoAnalytics"> | number
    quizStarted?: IntFilter<"VideoAnalytics"> | number
    quizCompleted?: IntFilter<"VideoAnalytics"> | number
    consultClicked?: IntFilter<"VideoAnalytics"> | number
    consultCompleted?: IntFilter<"VideoAnalytics"> | number
    hookRate3s?: FloatFilter<"VideoAnalytics"> | number
    hookRate5s?: FloatFilter<"VideoAnalytics"> | number
    updatedAt?: DateTimeFilter<"VideoAnalytics"> | Date | string
    video?: XOR<VideoRelationFilter, VideoWhereInput>
  }, "id" | "videoId">

  export type VideoAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    videoId?: SortOrder
    views?: SortOrder
    uniqueViews?: SortOrder
    avgWatchTime?: SortOrder
    ctr?: SortOrder
    quizStarted?: SortOrder
    quizCompleted?: SortOrder
    consultClicked?: SortOrder
    consultCompleted?: SortOrder
    hookRate3s?: SortOrder
    hookRate5s?: SortOrder
    updatedAt?: SortOrder
    _count?: VideoAnalyticsCountOrderByAggregateInput
    _avg?: VideoAnalyticsAvgOrderByAggregateInput
    _max?: VideoAnalyticsMaxOrderByAggregateInput
    _min?: VideoAnalyticsMinOrderByAggregateInput
    _sum?: VideoAnalyticsSumOrderByAggregateInput
  }

  export type VideoAnalyticsScalarWhereWithAggregatesInput = {
    AND?: VideoAnalyticsScalarWhereWithAggregatesInput | VideoAnalyticsScalarWhereWithAggregatesInput[]
    OR?: VideoAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: VideoAnalyticsScalarWhereWithAggregatesInput | VideoAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VideoAnalytics"> | string
    videoId?: StringWithAggregatesFilter<"VideoAnalytics"> | string
    views?: IntWithAggregatesFilter<"VideoAnalytics"> | number
    uniqueViews?: IntWithAggregatesFilter<"VideoAnalytics"> | number
    avgWatchTime?: FloatWithAggregatesFilter<"VideoAnalytics"> | number
    ctr?: FloatWithAggregatesFilter<"VideoAnalytics"> | number
    quizStarted?: IntWithAggregatesFilter<"VideoAnalytics"> | number
    quizCompleted?: IntWithAggregatesFilter<"VideoAnalytics"> | number
    consultClicked?: IntWithAggregatesFilter<"VideoAnalytics"> | number
    consultCompleted?: IntWithAggregatesFilter<"VideoAnalytics"> | number
    hookRate3s?: FloatWithAggregatesFilter<"VideoAnalytics"> | number
    hookRate5s?: FloatWithAggregatesFilter<"VideoAnalytics"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"VideoAnalytics"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    assignedTopics?: TopicCreateNestedManyWithoutAssignedDoctorInput
    createdTopics?: TopicCreateNestedManyWithoutCreatedByInput
    doctorPointers?: DoctorPointerCreateNestedManyWithoutDoctorInput
    uploadedScripts?: ScriptCreateNestedManyWithoutUploadedByInput
    lockedScripts?: ScriptCreateNestedManyWithoutLockedByInput
    assignedScripts?: ScriptCreateNestedManyWithoutAssignedReviewerInput
    scriptReviews?: ScriptReviewCreateNestedManyWithoutReviewerInput
    uploadedVideos?: VideoCreateNestedManyWithoutUploadedByInput
    lockedVideos?: VideoCreateNestedManyWithoutLockedByInput
    publishedVideos?: VideoCreateNestedManyWithoutPublishedByInput
    assignedVideos?: VideoCreateNestedManyWithoutAssignedReviewerInput
    videoReviews?: VideoReviewCreateNestedManyWithoutReviewerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    assignedTopics?: TopicUncheckedCreateNestedManyWithoutAssignedDoctorInput
    createdTopics?: TopicUncheckedCreateNestedManyWithoutCreatedByInput
    doctorPointers?: DoctorPointerUncheckedCreateNestedManyWithoutDoctorInput
    uploadedScripts?: ScriptUncheckedCreateNestedManyWithoutUploadedByInput
    lockedScripts?: ScriptUncheckedCreateNestedManyWithoutLockedByInput
    assignedScripts?: ScriptUncheckedCreateNestedManyWithoutAssignedReviewerInput
    scriptReviews?: ScriptReviewUncheckedCreateNestedManyWithoutReviewerInput
    uploadedVideos?: VideoUncheckedCreateNestedManyWithoutUploadedByInput
    lockedVideos?: VideoUncheckedCreateNestedManyWithoutLockedByInput
    publishedVideos?: VideoUncheckedCreateNestedManyWithoutPublishedByInput
    assignedVideos?: VideoUncheckedCreateNestedManyWithoutAssignedReviewerInput
    videoReviews?: VideoReviewUncheckedCreateNestedManyWithoutReviewerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTopics?: TopicUpdateManyWithoutAssignedDoctorNestedInput
    createdTopics?: TopicUpdateManyWithoutCreatedByNestedInput
    doctorPointers?: DoctorPointerUpdateManyWithoutDoctorNestedInput
    uploadedScripts?: ScriptUpdateManyWithoutUploadedByNestedInput
    lockedScripts?: ScriptUpdateManyWithoutLockedByNestedInput
    assignedScripts?: ScriptUpdateManyWithoutAssignedReviewerNestedInput
    scriptReviews?: ScriptReviewUpdateManyWithoutReviewerNestedInput
    uploadedVideos?: VideoUpdateManyWithoutUploadedByNestedInput
    lockedVideos?: VideoUpdateManyWithoutLockedByNestedInput
    publishedVideos?: VideoUpdateManyWithoutPublishedByNestedInput
    assignedVideos?: VideoUpdateManyWithoutAssignedReviewerNestedInput
    videoReviews?: VideoReviewUpdateManyWithoutReviewerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTopics?: TopicUncheckedUpdateManyWithoutAssignedDoctorNestedInput
    createdTopics?: TopicUncheckedUpdateManyWithoutCreatedByNestedInput
    doctorPointers?: DoctorPointerUncheckedUpdateManyWithoutDoctorNestedInput
    uploadedScripts?: ScriptUncheckedUpdateManyWithoutUploadedByNestedInput
    lockedScripts?: ScriptUncheckedUpdateManyWithoutLockedByNestedInput
    assignedScripts?: ScriptUncheckedUpdateManyWithoutAssignedReviewerNestedInput
    scriptReviews?: ScriptReviewUncheckedUpdateManyWithoutReviewerNestedInput
    uploadedVideos?: VideoUncheckedUpdateManyWithoutUploadedByNestedInput
    lockedVideos?: VideoUncheckedUpdateManyWithoutLockedByNestedInput
    publishedVideos?: VideoUncheckedUpdateManyWithoutPublishedByNestedInput
    assignedVideos?: VideoUncheckedUpdateManyWithoutAssignedReviewerNestedInput
    videoReviews?: VideoReviewUncheckedUpdateManyWithoutReviewerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TopicCreateInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TopicStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedDoctor: UserCreateNestedOneWithoutAssignedTopicsInput
    createdBy: UserCreateNestedOneWithoutCreatedTopicsInput
    doctorPointers?: DoctorPointerCreateNestedManyWithoutTopicInput
    scripts?: ScriptCreateNestedManyWithoutTopicInput
    videos?: VideoCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TopicStatus
    assignedDoctorId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorPointers?: DoctorPointerUncheckedCreateNestedManyWithoutTopicInput
    scripts?: ScriptUncheckedCreateNestedManyWithoutTopicInput
    videos?: VideoUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedDoctor?: UserUpdateOneRequiredWithoutAssignedTopicsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTopicsNestedInput
    doctorPointers?: DoctorPointerUpdateManyWithoutTopicNestedInput
    scripts?: ScriptUpdateManyWithoutTopicNestedInput
    videos?: VideoUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    assignedDoctorId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorPointers?: DoctorPointerUncheckedUpdateManyWithoutTopicNestedInput
    scripts?: ScriptUncheckedUpdateManyWithoutTopicNestedInput
    videos?: VideoUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type TopicCreateManyInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TopicStatus
    assignedDoctorId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TopicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    assignedDoctorId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorPointerCreateInput = {
    id?: string
    notes?: string | null
    fileUrl?: string | null
    fileType?: string | null
    createdAt?: Date | string
    topic: TopicCreateNestedOneWithoutDoctorPointersInput
    doctor: UserCreateNestedOneWithoutDoctorPointersInput
  }

  export type DoctorPointerUncheckedCreateInput = {
    id?: string
    topicId: string
    doctorId: string
    notes?: string | null
    fileUrl?: string | null
    fileType?: string | null
    createdAt?: Date | string
  }

  export type DoctorPointerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: TopicUpdateOneRequiredWithoutDoctorPointersNestedInput
    doctor?: UserUpdateOneRequiredWithoutDoctorPointersNestedInput
  }

  export type DoctorPointerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorPointerCreateManyInput = {
    id?: string
    topicId: string
    doctorId: string
    notes?: string | null
    fileUrl?: string | null
    fileType?: string | null
    createdAt?: Date | string
  }

  export type DoctorPointerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorPointerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScriptCreateInput = {
    id?: string
    version?: number
    content: string
    status?: $Enums.ScriptStatus
    summary?: string | null
    tags?: ScriptCreatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    lockedAt?: Date | string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    topic: TopicCreateNestedOneWithoutScriptsInput
    uploadedBy?: UserCreateNestedOneWithoutUploadedScriptsInput
    lockedBy?: UserCreateNestedOneWithoutLockedScriptsInput
    assignedReviewer?: UserCreateNestedOneWithoutAssignedScriptsInput
    reviews?: ScriptReviewCreateNestedManyWithoutScriptInput
    comments?: CommentCreateNestedManyWithoutScriptInput
    videos?: VideoCreateNestedManyWithoutScriptInput
  }

  export type ScriptUncheckedCreateInput = {
    id?: string
    topicId: string
    version?: number
    content: string
    status?: $Enums.ScriptStatus
    summary?: string | null
    tags?: ScriptCreatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    uploadedById?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    assignedReviewerId?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ScriptReviewUncheckedCreateNestedManyWithoutScriptInput
    comments?: CommentUncheckedCreateNestedManyWithoutScriptInput
    videos?: VideoUncheckedCreateNestedManyWithoutScriptInput
  }

  export type ScriptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumScriptStatusFieldUpdateOperationsInput | $Enums.ScriptStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ScriptUpdatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: TopicUpdateOneRequiredWithoutScriptsNestedInput
    uploadedBy?: UserUpdateOneWithoutUploadedScriptsNestedInput
    lockedBy?: UserUpdateOneWithoutLockedScriptsNestedInput
    assignedReviewer?: UserUpdateOneWithoutAssignedScriptsNestedInput
    reviews?: ScriptReviewUpdateManyWithoutScriptNestedInput
    comments?: CommentUpdateManyWithoutScriptNestedInput
    videos?: VideoUpdateManyWithoutScriptNestedInput
  }

  export type ScriptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumScriptStatusFieldUpdateOperationsInput | $Enums.ScriptStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ScriptUpdatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedReviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ScriptReviewUncheckedUpdateManyWithoutScriptNestedInput
    comments?: CommentUncheckedUpdateManyWithoutScriptNestedInput
    videos?: VideoUncheckedUpdateManyWithoutScriptNestedInput
  }

  export type ScriptCreateManyInput = {
    id?: string
    topicId: string
    version?: number
    content: string
    status?: $Enums.ScriptStatus
    summary?: string | null
    tags?: ScriptCreatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    uploadedById?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    assignedReviewerId?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScriptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumScriptStatusFieldUpdateOperationsInput | $Enums.ScriptStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ScriptUpdatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScriptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumScriptStatusFieldUpdateOperationsInput | $Enums.ScriptStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ScriptUpdatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedReviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScriptReviewCreateInput = {
    id?: string
    reviewerType: $Enums.UserRole
    decision?: $Enums.ReviewDecision
    comments?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    script: ScriptCreateNestedOneWithoutReviewsInput
    reviewer: UserCreateNestedOneWithoutScriptReviewsInput
  }

  export type ScriptReviewUncheckedCreateInput = {
    id?: string
    scriptId: string
    reviewerId: string
    reviewerType: $Enums.UserRole
    decision?: $Enums.ReviewDecision
    comments?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ScriptReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerType?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    decision?: EnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    script?: ScriptUpdateOneRequiredWithoutReviewsNestedInput
    reviewer?: UserUpdateOneRequiredWithoutScriptReviewsNestedInput
  }

  export type ScriptReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scriptId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    reviewerType?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    decision?: EnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScriptReviewCreateManyInput = {
    id?: string
    scriptId: string
    reviewerId: string
    reviewerType: $Enums.UserRole
    decision?: $Enums.ReviewDecision
    comments?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ScriptReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerType?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    decision?: EnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScriptReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    scriptId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    reviewerType?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    decision?: EnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCreateInput = {
    id?: string
    title: string
    description?: string | null
    videoUrl: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: bigint | number | null
    doctorName: string
    specialty: string
    language: string
    city: string
    ctaType: $Enums.CTAType
    tags?: VideoCreatetagsInput | string[]
    transcript?: string | null
    transcriptUrl?: string | null
    summary?: string | null
    shortSummary?: string | null
    keyTakeaways?: VideoCreatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    relatedVideoIds?: VideoCreaterelatedVideoIdsInput | string[]
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    status?: $Enums.VideoStatus
    version?: number
    lockedAt?: Date | string | null
    publishedAt?: Date | string | null
    assignedAt?: Date | string | null
    deepLink?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    topic: TopicCreateNestedOneWithoutVideosInput
    script?: ScriptCreateNestedOneWithoutVideosInput
    uploadedBy?: UserCreateNestedOneWithoutUploadedVideosInput
    lockedBy?: UserCreateNestedOneWithoutLockedVideosInput
    publishedBy?: UserCreateNestedOneWithoutPublishedVideosInput
    assignedReviewer?: UserCreateNestedOneWithoutAssignedVideosInput
    reviews?: VideoReviewCreateNestedManyWithoutVideoInput
    comments?: CommentCreateNestedManyWithoutVideoInput
    analytics?: VideoAnalyticsCreateNestedOneWithoutVideoInput
  }

  export type VideoUncheckedCreateInput = {
    id?: string
    topicId: string
    scriptId?: string | null
    title: string
    description?: string | null
    videoUrl: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: bigint | number | null
    doctorName: string
    specialty: string
    language: string
    city: string
    ctaType: $Enums.CTAType
    tags?: VideoCreatetagsInput | string[]
    transcript?: string | null
    transcriptUrl?: string | null
    summary?: string | null
    shortSummary?: string | null
    keyTakeaways?: VideoCreatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    relatedVideoIds?: VideoCreaterelatedVideoIdsInput | string[]
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    status?: $Enums.VideoStatus
    version?: number
    uploadedById?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    publishedById?: string | null
    publishedAt?: Date | string | null
    assignedReviewerId?: string | null
    assignedAt?: Date | string | null
    deepLink?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: VideoReviewUncheckedCreateNestedManyWithoutVideoInput
    comments?: CommentUncheckedCreateNestedManyWithoutVideoInput
    analytics?: VideoAnalyticsUncheckedCreateNestedOneWithoutVideoInput
  }

  export type VideoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    doctorName?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    ctaType?: EnumCTATypeFieldUpdateOperationsInput | $Enums.CTAType
    tags?: VideoUpdatetagsInput | string[]
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    shortSummary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: VideoUpdatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relatedVideoIds?: VideoUpdaterelatedVideoIdsInput | string[]
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    version?: IntFieldUpdateOperationsInput | number
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: TopicUpdateOneRequiredWithoutVideosNestedInput
    script?: ScriptUpdateOneWithoutVideosNestedInput
    uploadedBy?: UserUpdateOneWithoutUploadedVideosNestedInput
    lockedBy?: UserUpdateOneWithoutLockedVideosNestedInput
    publishedBy?: UserUpdateOneWithoutPublishedVideosNestedInput
    assignedReviewer?: UserUpdateOneWithoutAssignedVideosNestedInput
    reviews?: VideoReviewUpdateManyWithoutVideoNestedInput
    comments?: CommentUpdateManyWithoutVideoNestedInput
    analytics?: VideoAnalyticsUpdateOneWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    scriptId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    doctorName?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    ctaType?: EnumCTATypeFieldUpdateOperationsInput | $Enums.CTAType
    tags?: VideoUpdatetagsInput | string[]
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    shortSummary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: VideoUpdatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relatedVideoIds?: VideoUpdaterelatedVideoIdsInput | string[]
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    version?: IntFieldUpdateOperationsInput | number
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedById?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedReviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: VideoReviewUncheckedUpdateManyWithoutVideoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutVideoNestedInput
    analytics?: VideoAnalyticsUncheckedUpdateOneWithoutVideoNestedInput
  }

  export type VideoCreateManyInput = {
    id?: string
    topicId: string
    scriptId?: string | null
    title: string
    description?: string | null
    videoUrl: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: bigint | number | null
    doctorName: string
    specialty: string
    language: string
    city: string
    ctaType: $Enums.CTAType
    tags?: VideoCreatetagsInput | string[]
    transcript?: string | null
    transcriptUrl?: string | null
    summary?: string | null
    shortSummary?: string | null
    keyTakeaways?: VideoCreatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    relatedVideoIds?: VideoCreaterelatedVideoIdsInput | string[]
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    status?: $Enums.VideoStatus
    version?: number
    uploadedById?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    publishedById?: string | null
    publishedAt?: Date | string | null
    assignedReviewerId?: string | null
    assignedAt?: Date | string | null
    deepLink?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    doctorName?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    ctaType?: EnumCTATypeFieldUpdateOperationsInput | $Enums.CTAType
    tags?: VideoUpdatetagsInput | string[]
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    shortSummary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: VideoUpdatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relatedVideoIds?: VideoUpdaterelatedVideoIdsInput | string[]
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    version?: IntFieldUpdateOperationsInput | number
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    scriptId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    doctorName?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    ctaType?: EnumCTATypeFieldUpdateOperationsInput | $Enums.CTAType
    tags?: VideoUpdatetagsInput | string[]
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    shortSummary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: VideoUpdatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relatedVideoIds?: VideoUpdaterelatedVideoIdsInput | string[]
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    version?: IntFieldUpdateOperationsInput | number
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedById?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedReviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoReviewCreateInput = {
    id?: string
    reviewerType: $Enums.UserRole
    decision?: $Enums.ReviewDecision
    comments?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    video: VideoCreateNestedOneWithoutReviewsInput
    reviewer: UserCreateNestedOneWithoutVideoReviewsInput
  }

  export type VideoReviewUncheckedCreateInput = {
    id?: string
    videoId: string
    reviewerId: string
    reviewerType: $Enums.UserRole
    decision?: $Enums.ReviewDecision
    comments?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type VideoReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerType?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    decision?: EnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    video?: VideoUpdateOneRequiredWithoutReviewsNestedInput
    reviewer?: UserUpdateOneRequiredWithoutVideoReviewsNestedInput
  }

  export type VideoReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    reviewerType?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    decision?: EnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoReviewCreateManyInput = {
    id?: string
    videoId: string
    reviewerId: string
    reviewerType: $Enums.UserRole
    decision?: $Enums.ReviewDecision
    comments?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type VideoReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerType?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    decision?: EnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    reviewerType?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    decision?: EnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    script?: ScriptCreateNestedOneWithoutCommentsInput
    video?: VideoCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    scriptId?: string | null
    videoId?: string | null
    authorId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    script?: ScriptUpdateOneWithoutCommentsNestedInput
    video?: VideoUpdateOneWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scriptId?: NullableStringFieldUpdateOperationsInput | string | null
    videoId?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyInput = {
    id?: string
    scriptId?: string | null
    videoId?: string | null
    authorId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    scriptId?: NullableStringFieldUpdateOperationsInput | string | null
    videoId?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type?: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type?: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type?: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId: string
    action: string
    entityType: string
    entityId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId: string
    action: string
    entityType: string
    entityId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoAnalyticsCreateInput = {
    id?: string
    views?: number
    uniqueViews?: number
    avgWatchTime?: number
    ctr?: number
    quizStarted?: number
    quizCompleted?: number
    consultClicked?: number
    consultCompleted?: number
    hookRate3s?: number
    hookRate5s?: number
    updatedAt?: Date | string
    video: VideoCreateNestedOneWithoutAnalyticsInput
  }

  export type VideoAnalyticsUncheckedCreateInput = {
    id?: string
    videoId: string
    views?: number
    uniqueViews?: number
    avgWatchTime?: number
    ctr?: number
    quizStarted?: number
    quizCompleted?: number
    consultClicked?: number
    consultCompleted?: number
    hookRate3s?: number
    hookRate5s?: number
    updatedAt?: Date | string
  }

  export type VideoAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    uniqueViews?: IntFieldUpdateOperationsInput | number
    avgWatchTime?: FloatFieldUpdateOperationsInput | number
    ctr?: FloatFieldUpdateOperationsInput | number
    quizStarted?: IntFieldUpdateOperationsInput | number
    quizCompleted?: IntFieldUpdateOperationsInput | number
    consultClicked?: IntFieldUpdateOperationsInput | number
    consultCompleted?: IntFieldUpdateOperationsInput | number
    hookRate3s?: FloatFieldUpdateOperationsInput | number
    hookRate5s?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    video?: VideoUpdateOneRequiredWithoutAnalyticsNestedInput
  }

  export type VideoAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    uniqueViews?: IntFieldUpdateOperationsInput | number
    avgWatchTime?: FloatFieldUpdateOperationsInput | number
    ctr?: FloatFieldUpdateOperationsInput | number
    quizStarted?: IntFieldUpdateOperationsInput | number
    quizCompleted?: IntFieldUpdateOperationsInput | number
    consultClicked?: IntFieldUpdateOperationsInput | number
    consultCompleted?: IntFieldUpdateOperationsInput | number
    hookRate3s?: FloatFieldUpdateOperationsInput | number
    hookRate5s?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoAnalyticsCreateManyInput = {
    id?: string
    videoId: string
    views?: number
    uniqueViews?: number
    avgWatchTime?: number
    ctr?: number
    quizStarted?: number
    quizCompleted?: number
    consultClicked?: number
    consultCompleted?: number
    hookRate3s?: number
    hookRate5s?: number
    updatedAt?: Date | string
  }

  export type VideoAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    uniqueViews?: IntFieldUpdateOperationsInput | number
    avgWatchTime?: FloatFieldUpdateOperationsInput | number
    ctr?: FloatFieldUpdateOperationsInput | number
    quizStarted?: IntFieldUpdateOperationsInput | number
    quizCompleted?: IntFieldUpdateOperationsInput | number
    consultClicked?: IntFieldUpdateOperationsInput | number
    consultCompleted?: IntFieldUpdateOperationsInput | number
    hookRate3s?: FloatFieldUpdateOperationsInput | number
    hookRate5s?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    uniqueViews?: IntFieldUpdateOperationsInput | number
    avgWatchTime?: FloatFieldUpdateOperationsInput | number
    ctr?: FloatFieldUpdateOperationsInput | number
    quizStarted?: IntFieldUpdateOperationsInput | number
    quizCompleted?: IntFieldUpdateOperationsInput | number
    consultClicked?: IntFieldUpdateOperationsInput | number
    consultCompleted?: IntFieldUpdateOperationsInput | number
    hookRate3s?: FloatFieldUpdateOperationsInput | number
    hookRate5s?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type TopicListRelationFilter = {
    every?: TopicWhereInput
    some?: TopicWhereInput
    none?: TopicWhereInput
  }

  export type DoctorPointerListRelationFilter = {
    every?: DoctorPointerWhereInput
    some?: DoctorPointerWhereInput
    none?: DoctorPointerWhereInput
  }

  export type ScriptListRelationFilter = {
    every?: ScriptWhereInput
    some?: ScriptWhereInput
    none?: ScriptWhereInput
  }

  export type ScriptReviewListRelationFilter = {
    every?: ScriptReviewWhereInput
    some?: ScriptReviewWhereInput
    none?: ScriptReviewWhereInput
  }

  export type VideoListRelationFilter = {
    every?: VideoWhereInput
    some?: VideoWhereInput
    none?: VideoWhereInput
  }

  export type VideoReviewListRelationFilter = {
    every?: VideoReviewWhereInput
    some?: VideoReviewWhereInput
    none?: VideoReviewWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TopicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DoctorPointerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScriptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScriptReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VideoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VideoReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    specialty?: SortOrder
    city?: SortOrder
    googleId?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    specialty?: SortOrder
    city?: SortOrder
    googleId?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    specialty?: SortOrder
    city?: SortOrder
    googleId?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumTopicStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TopicStatus | EnumTopicStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TopicStatus[] | ListEnumTopicStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TopicStatus[] | ListEnumTopicStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTopicStatusFilter<$PrismaModel> | $Enums.TopicStatus
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type TopicCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    assignedDoctorId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TopicMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    assignedDoctorId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TopicMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    assignedDoctorId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTopicStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TopicStatus | EnumTopicStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TopicStatus[] | ListEnumTopicStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TopicStatus[] | ListEnumTopicStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTopicStatusWithAggregatesFilter<$PrismaModel> | $Enums.TopicStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTopicStatusFilter<$PrismaModel>
    _max?: NestedEnumTopicStatusFilter<$PrismaModel>
  }

  export type TopicRelationFilter = {
    is?: TopicWhereInput
    isNot?: TopicWhereInput
  }

  export type DoctorPointerCountOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    doctorId?: SortOrder
    notes?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    createdAt?: SortOrder
  }

  export type DoctorPointerMaxOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    doctorId?: SortOrder
    notes?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    createdAt?: SortOrder
  }

  export type DoctorPointerMinOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    doctorId?: SortOrder
    notes?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    createdAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumScriptStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ScriptStatus | EnumScriptStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScriptStatus[] | ListEnumScriptStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScriptStatus[] | ListEnumScriptStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScriptStatusFilter<$PrismaModel> | $Enums.ScriptStatus
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ScriptTopicIdVersionCompoundUniqueInput = {
    topicId: string
    version: number
  }

  export type ScriptCountOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    version?: SortOrder
    content?: SortOrder
    status?: SortOrder
    summary?: SortOrder
    tags?: SortOrder
    entities?: SortOrder
    qualityScore?: SortOrder
    aiProcessedAt?: SortOrder
    aiProcessingStatus?: SortOrder
    uploadedById?: SortOrder
    lockedById?: SortOrder
    lockedAt?: SortOrder
    assignedReviewerId?: SortOrder
    assignedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScriptAvgOrderByAggregateInput = {
    version?: SortOrder
    qualityScore?: SortOrder
  }

  export type ScriptMaxOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    version?: SortOrder
    content?: SortOrder
    status?: SortOrder
    summary?: SortOrder
    qualityScore?: SortOrder
    aiProcessedAt?: SortOrder
    aiProcessingStatus?: SortOrder
    uploadedById?: SortOrder
    lockedById?: SortOrder
    lockedAt?: SortOrder
    assignedReviewerId?: SortOrder
    assignedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScriptMinOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    version?: SortOrder
    content?: SortOrder
    status?: SortOrder
    summary?: SortOrder
    qualityScore?: SortOrder
    aiProcessedAt?: SortOrder
    aiProcessingStatus?: SortOrder
    uploadedById?: SortOrder
    lockedById?: SortOrder
    lockedAt?: SortOrder
    assignedReviewerId?: SortOrder
    assignedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScriptSumOrderByAggregateInput = {
    version?: SortOrder
    qualityScore?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumScriptStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScriptStatus | EnumScriptStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScriptStatus[] | ListEnumScriptStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScriptStatus[] | ListEnumScriptStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScriptStatusWithAggregatesFilter<$PrismaModel> | $Enums.ScriptStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScriptStatusFilter<$PrismaModel>
    _max?: NestedEnumScriptStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumReviewDecisionFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewDecision | EnumReviewDecisionFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewDecision[] | ListEnumReviewDecisionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewDecision[] | ListEnumReviewDecisionFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewDecisionFilter<$PrismaModel> | $Enums.ReviewDecision
  }

  export type ScriptRelationFilter = {
    is?: ScriptWhereInput
    isNot?: ScriptWhereInput
  }

  export type ScriptReviewCountOrderByAggregateInput = {
    id?: SortOrder
    scriptId?: SortOrder
    reviewerId?: SortOrder
    reviewerType?: SortOrder
    decision?: SortOrder
    comments?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ScriptReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    scriptId?: SortOrder
    reviewerId?: SortOrder
    reviewerType?: SortOrder
    decision?: SortOrder
    comments?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ScriptReviewMinOrderByAggregateInput = {
    id?: SortOrder
    scriptId?: SortOrder
    reviewerId?: SortOrder
    reviewerType?: SortOrder
    decision?: SortOrder
    comments?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumReviewDecisionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewDecision | EnumReviewDecisionFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewDecision[] | ListEnumReviewDecisionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewDecision[] | ListEnumReviewDecisionFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewDecisionWithAggregatesFilter<$PrismaModel> | $Enums.ReviewDecision
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewDecisionFilter<$PrismaModel>
    _max?: NestedEnumReviewDecisionFilter<$PrismaModel>
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type EnumCTATypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CTAType | EnumCTATypeFieldRefInput<$PrismaModel>
    in?: $Enums.CTAType[] | ListEnumCTATypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CTAType[] | ListEnumCTATypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCTATypeFilter<$PrismaModel> | $Enums.CTAType
  }

  export type EnumVideoStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoStatus | EnumVideoStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VideoStatus[] | ListEnumVideoStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VideoStatus[] | ListEnumVideoStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVideoStatusFilter<$PrismaModel> | $Enums.VideoStatus
  }

  export type ScriptNullableRelationFilter = {
    is?: ScriptWhereInput | null
    isNot?: ScriptWhereInput | null
  }

  export type VideoAnalyticsNullableRelationFilter = {
    is?: VideoAnalyticsWhereInput | null
    isNot?: VideoAnalyticsWhereInput | null
  }

  export type VideoTopicIdVersionCompoundUniqueInput = {
    topicId: string
    version: number
  }

  export type VideoCountOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    scriptId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    videoUrl?: SortOrder
    thumbnailUrl?: SortOrder
    duration?: SortOrder
    fileSize?: SortOrder
    doctorName?: SortOrder
    specialty?: SortOrder
    language?: SortOrder
    city?: SortOrder
    ctaType?: SortOrder
    tags?: SortOrder
    transcript?: SortOrder
    transcriptUrl?: SortOrder
    summary?: SortOrder
    shortSummary?: SortOrder
    keyTakeaways?: SortOrder
    entities?: SortOrder
    qualityScore?: SortOrder
    relatedVideoIds?: SortOrder
    aiProcessedAt?: SortOrder
    aiProcessingStatus?: SortOrder
    status?: SortOrder
    version?: SortOrder
    uploadedById?: SortOrder
    lockedById?: SortOrder
    lockedAt?: SortOrder
    publishedById?: SortOrder
    publishedAt?: SortOrder
    assignedReviewerId?: SortOrder
    assignedAt?: SortOrder
    deepLink?: SortOrder
    viewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoAvgOrderByAggregateInput = {
    duration?: SortOrder
    fileSize?: SortOrder
    qualityScore?: SortOrder
    version?: SortOrder
    viewCount?: SortOrder
  }

  export type VideoMaxOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    scriptId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    videoUrl?: SortOrder
    thumbnailUrl?: SortOrder
    duration?: SortOrder
    fileSize?: SortOrder
    doctorName?: SortOrder
    specialty?: SortOrder
    language?: SortOrder
    city?: SortOrder
    ctaType?: SortOrder
    transcript?: SortOrder
    transcriptUrl?: SortOrder
    summary?: SortOrder
    shortSummary?: SortOrder
    qualityScore?: SortOrder
    aiProcessedAt?: SortOrder
    aiProcessingStatus?: SortOrder
    status?: SortOrder
    version?: SortOrder
    uploadedById?: SortOrder
    lockedById?: SortOrder
    lockedAt?: SortOrder
    publishedById?: SortOrder
    publishedAt?: SortOrder
    assignedReviewerId?: SortOrder
    assignedAt?: SortOrder
    deepLink?: SortOrder
    viewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoMinOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    scriptId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    videoUrl?: SortOrder
    thumbnailUrl?: SortOrder
    duration?: SortOrder
    fileSize?: SortOrder
    doctorName?: SortOrder
    specialty?: SortOrder
    language?: SortOrder
    city?: SortOrder
    ctaType?: SortOrder
    transcript?: SortOrder
    transcriptUrl?: SortOrder
    summary?: SortOrder
    shortSummary?: SortOrder
    qualityScore?: SortOrder
    aiProcessedAt?: SortOrder
    aiProcessingStatus?: SortOrder
    status?: SortOrder
    version?: SortOrder
    uploadedById?: SortOrder
    lockedById?: SortOrder
    lockedAt?: SortOrder
    publishedById?: SortOrder
    publishedAt?: SortOrder
    assignedReviewerId?: SortOrder
    assignedAt?: SortOrder
    deepLink?: SortOrder
    viewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoSumOrderByAggregateInput = {
    duration?: SortOrder
    fileSize?: SortOrder
    qualityScore?: SortOrder
    version?: SortOrder
    viewCount?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type EnumCTATypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CTAType | EnumCTATypeFieldRefInput<$PrismaModel>
    in?: $Enums.CTAType[] | ListEnumCTATypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CTAType[] | ListEnumCTATypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCTATypeWithAggregatesFilter<$PrismaModel> | $Enums.CTAType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCTATypeFilter<$PrismaModel>
    _max?: NestedEnumCTATypeFilter<$PrismaModel>
  }

  export type EnumVideoStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoStatus | EnumVideoStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VideoStatus[] | ListEnumVideoStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VideoStatus[] | ListEnumVideoStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVideoStatusWithAggregatesFilter<$PrismaModel> | $Enums.VideoStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVideoStatusFilter<$PrismaModel>
    _max?: NestedEnumVideoStatusFilter<$PrismaModel>
  }

  export type VideoRelationFilter = {
    is?: VideoWhereInput
    isNot?: VideoWhereInput
  }

  export type VideoReviewCountOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    reviewerId?: SortOrder
    reviewerType?: SortOrder
    decision?: SortOrder
    comments?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type VideoReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    reviewerId?: SortOrder
    reviewerType?: SortOrder
    decision?: SortOrder
    comments?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type VideoReviewMinOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    reviewerId?: SortOrder
    reviewerType?: SortOrder
    decision?: SortOrder
    comments?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type VideoNullableRelationFilter = {
    is?: VideoWhereInput | null
    isNot?: VideoWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    scriptId?: SortOrder
    videoId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    scriptId?: SortOrder
    videoId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    scriptId?: SortOrder
    videoId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type VideoAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    views?: SortOrder
    uniqueViews?: SortOrder
    avgWatchTime?: SortOrder
    ctr?: SortOrder
    quizStarted?: SortOrder
    quizCompleted?: SortOrder
    consultClicked?: SortOrder
    consultCompleted?: SortOrder
    hookRate3s?: SortOrder
    hookRate5s?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoAnalyticsAvgOrderByAggregateInput = {
    views?: SortOrder
    uniqueViews?: SortOrder
    avgWatchTime?: SortOrder
    ctr?: SortOrder
    quizStarted?: SortOrder
    quizCompleted?: SortOrder
    consultClicked?: SortOrder
    consultCompleted?: SortOrder
    hookRate3s?: SortOrder
    hookRate5s?: SortOrder
  }

  export type VideoAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    views?: SortOrder
    uniqueViews?: SortOrder
    avgWatchTime?: SortOrder
    ctr?: SortOrder
    quizStarted?: SortOrder
    quizCompleted?: SortOrder
    consultClicked?: SortOrder
    consultCompleted?: SortOrder
    hookRate3s?: SortOrder
    hookRate5s?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    views?: SortOrder
    uniqueViews?: SortOrder
    avgWatchTime?: SortOrder
    ctr?: SortOrder
    quizStarted?: SortOrder
    quizCompleted?: SortOrder
    consultClicked?: SortOrder
    consultCompleted?: SortOrder
    hookRate3s?: SortOrder
    hookRate5s?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoAnalyticsSumOrderByAggregateInput = {
    views?: SortOrder
    uniqueViews?: SortOrder
    avgWatchTime?: SortOrder
    ctr?: SortOrder
    quizStarted?: SortOrder
    quizCompleted?: SortOrder
    consultClicked?: SortOrder
    consultCompleted?: SortOrder
    hookRate3s?: SortOrder
    hookRate5s?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type TopicCreateNestedManyWithoutAssignedDoctorInput = {
    create?: XOR<TopicCreateWithoutAssignedDoctorInput, TopicUncheckedCreateWithoutAssignedDoctorInput> | TopicCreateWithoutAssignedDoctorInput[] | TopicUncheckedCreateWithoutAssignedDoctorInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutAssignedDoctorInput | TopicCreateOrConnectWithoutAssignedDoctorInput[]
    createMany?: TopicCreateManyAssignedDoctorInputEnvelope
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type TopicCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TopicCreateWithoutCreatedByInput, TopicUncheckedCreateWithoutCreatedByInput> | TopicCreateWithoutCreatedByInput[] | TopicUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutCreatedByInput | TopicCreateOrConnectWithoutCreatedByInput[]
    createMany?: TopicCreateManyCreatedByInputEnvelope
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type DoctorPointerCreateNestedManyWithoutDoctorInput = {
    create?: XOR<DoctorPointerCreateWithoutDoctorInput, DoctorPointerUncheckedCreateWithoutDoctorInput> | DoctorPointerCreateWithoutDoctorInput[] | DoctorPointerUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorPointerCreateOrConnectWithoutDoctorInput | DoctorPointerCreateOrConnectWithoutDoctorInput[]
    createMany?: DoctorPointerCreateManyDoctorInputEnvelope
    connect?: DoctorPointerWhereUniqueInput | DoctorPointerWhereUniqueInput[]
  }

  export type ScriptCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<ScriptCreateWithoutUploadedByInput, ScriptUncheckedCreateWithoutUploadedByInput> | ScriptCreateWithoutUploadedByInput[] | ScriptUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: ScriptCreateOrConnectWithoutUploadedByInput | ScriptCreateOrConnectWithoutUploadedByInput[]
    createMany?: ScriptCreateManyUploadedByInputEnvelope
    connect?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
  }

  export type ScriptCreateNestedManyWithoutLockedByInput = {
    create?: XOR<ScriptCreateWithoutLockedByInput, ScriptUncheckedCreateWithoutLockedByInput> | ScriptCreateWithoutLockedByInput[] | ScriptUncheckedCreateWithoutLockedByInput[]
    connectOrCreate?: ScriptCreateOrConnectWithoutLockedByInput | ScriptCreateOrConnectWithoutLockedByInput[]
    createMany?: ScriptCreateManyLockedByInputEnvelope
    connect?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
  }

  export type ScriptCreateNestedManyWithoutAssignedReviewerInput = {
    create?: XOR<ScriptCreateWithoutAssignedReviewerInput, ScriptUncheckedCreateWithoutAssignedReviewerInput> | ScriptCreateWithoutAssignedReviewerInput[] | ScriptUncheckedCreateWithoutAssignedReviewerInput[]
    connectOrCreate?: ScriptCreateOrConnectWithoutAssignedReviewerInput | ScriptCreateOrConnectWithoutAssignedReviewerInput[]
    createMany?: ScriptCreateManyAssignedReviewerInputEnvelope
    connect?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
  }

  export type ScriptReviewCreateNestedManyWithoutReviewerInput = {
    create?: XOR<ScriptReviewCreateWithoutReviewerInput, ScriptReviewUncheckedCreateWithoutReviewerInput> | ScriptReviewCreateWithoutReviewerInput[] | ScriptReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: ScriptReviewCreateOrConnectWithoutReviewerInput | ScriptReviewCreateOrConnectWithoutReviewerInput[]
    createMany?: ScriptReviewCreateManyReviewerInputEnvelope
    connect?: ScriptReviewWhereUniqueInput | ScriptReviewWhereUniqueInput[]
  }

  export type VideoCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<VideoCreateWithoutUploadedByInput, VideoUncheckedCreateWithoutUploadedByInput> | VideoCreateWithoutUploadedByInput[] | VideoUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutUploadedByInput | VideoCreateOrConnectWithoutUploadedByInput[]
    createMany?: VideoCreateManyUploadedByInputEnvelope
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
  }

  export type VideoCreateNestedManyWithoutLockedByInput = {
    create?: XOR<VideoCreateWithoutLockedByInput, VideoUncheckedCreateWithoutLockedByInput> | VideoCreateWithoutLockedByInput[] | VideoUncheckedCreateWithoutLockedByInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutLockedByInput | VideoCreateOrConnectWithoutLockedByInput[]
    createMany?: VideoCreateManyLockedByInputEnvelope
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
  }

  export type VideoCreateNestedManyWithoutPublishedByInput = {
    create?: XOR<VideoCreateWithoutPublishedByInput, VideoUncheckedCreateWithoutPublishedByInput> | VideoCreateWithoutPublishedByInput[] | VideoUncheckedCreateWithoutPublishedByInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutPublishedByInput | VideoCreateOrConnectWithoutPublishedByInput[]
    createMany?: VideoCreateManyPublishedByInputEnvelope
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
  }

  export type VideoCreateNestedManyWithoutAssignedReviewerInput = {
    create?: XOR<VideoCreateWithoutAssignedReviewerInput, VideoUncheckedCreateWithoutAssignedReviewerInput> | VideoCreateWithoutAssignedReviewerInput[] | VideoUncheckedCreateWithoutAssignedReviewerInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutAssignedReviewerInput | VideoCreateOrConnectWithoutAssignedReviewerInput[]
    createMany?: VideoCreateManyAssignedReviewerInputEnvelope
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
  }

  export type VideoReviewCreateNestedManyWithoutReviewerInput = {
    create?: XOR<VideoReviewCreateWithoutReviewerInput, VideoReviewUncheckedCreateWithoutReviewerInput> | VideoReviewCreateWithoutReviewerInput[] | VideoReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: VideoReviewCreateOrConnectWithoutReviewerInput | VideoReviewCreateOrConnectWithoutReviewerInput[]
    createMany?: VideoReviewCreateManyReviewerInputEnvelope
    connect?: VideoReviewWhereUniqueInput | VideoReviewWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type TopicUncheckedCreateNestedManyWithoutAssignedDoctorInput = {
    create?: XOR<TopicCreateWithoutAssignedDoctorInput, TopicUncheckedCreateWithoutAssignedDoctorInput> | TopicCreateWithoutAssignedDoctorInput[] | TopicUncheckedCreateWithoutAssignedDoctorInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutAssignedDoctorInput | TopicCreateOrConnectWithoutAssignedDoctorInput[]
    createMany?: TopicCreateManyAssignedDoctorInputEnvelope
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type TopicUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TopicCreateWithoutCreatedByInput, TopicUncheckedCreateWithoutCreatedByInput> | TopicCreateWithoutCreatedByInput[] | TopicUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutCreatedByInput | TopicCreateOrConnectWithoutCreatedByInput[]
    createMany?: TopicCreateManyCreatedByInputEnvelope
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type DoctorPointerUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<DoctorPointerCreateWithoutDoctorInput, DoctorPointerUncheckedCreateWithoutDoctorInput> | DoctorPointerCreateWithoutDoctorInput[] | DoctorPointerUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorPointerCreateOrConnectWithoutDoctorInput | DoctorPointerCreateOrConnectWithoutDoctorInput[]
    createMany?: DoctorPointerCreateManyDoctorInputEnvelope
    connect?: DoctorPointerWhereUniqueInput | DoctorPointerWhereUniqueInput[]
  }

  export type ScriptUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<ScriptCreateWithoutUploadedByInput, ScriptUncheckedCreateWithoutUploadedByInput> | ScriptCreateWithoutUploadedByInput[] | ScriptUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: ScriptCreateOrConnectWithoutUploadedByInput | ScriptCreateOrConnectWithoutUploadedByInput[]
    createMany?: ScriptCreateManyUploadedByInputEnvelope
    connect?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
  }

  export type ScriptUncheckedCreateNestedManyWithoutLockedByInput = {
    create?: XOR<ScriptCreateWithoutLockedByInput, ScriptUncheckedCreateWithoutLockedByInput> | ScriptCreateWithoutLockedByInput[] | ScriptUncheckedCreateWithoutLockedByInput[]
    connectOrCreate?: ScriptCreateOrConnectWithoutLockedByInput | ScriptCreateOrConnectWithoutLockedByInput[]
    createMany?: ScriptCreateManyLockedByInputEnvelope
    connect?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
  }

  export type ScriptUncheckedCreateNestedManyWithoutAssignedReviewerInput = {
    create?: XOR<ScriptCreateWithoutAssignedReviewerInput, ScriptUncheckedCreateWithoutAssignedReviewerInput> | ScriptCreateWithoutAssignedReviewerInput[] | ScriptUncheckedCreateWithoutAssignedReviewerInput[]
    connectOrCreate?: ScriptCreateOrConnectWithoutAssignedReviewerInput | ScriptCreateOrConnectWithoutAssignedReviewerInput[]
    createMany?: ScriptCreateManyAssignedReviewerInputEnvelope
    connect?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
  }

  export type ScriptReviewUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<ScriptReviewCreateWithoutReviewerInput, ScriptReviewUncheckedCreateWithoutReviewerInput> | ScriptReviewCreateWithoutReviewerInput[] | ScriptReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: ScriptReviewCreateOrConnectWithoutReviewerInput | ScriptReviewCreateOrConnectWithoutReviewerInput[]
    createMany?: ScriptReviewCreateManyReviewerInputEnvelope
    connect?: ScriptReviewWhereUniqueInput | ScriptReviewWhereUniqueInput[]
  }

  export type VideoUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<VideoCreateWithoutUploadedByInput, VideoUncheckedCreateWithoutUploadedByInput> | VideoCreateWithoutUploadedByInput[] | VideoUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutUploadedByInput | VideoCreateOrConnectWithoutUploadedByInput[]
    createMany?: VideoCreateManyUploadedByInputEnvelope
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
  }

  export type VideoUncheckedCreateNestedManyWithoutLockedByInput = {
    create?: XOR<VideoCreateWithoutLockedByInput, VideoUncheckedCreateWithoutLockedByInput> | VideoCreateWithoutLockedByInput[] | VideoUncheckedCreateWithoutLockedByInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutLockedByInput | VideoCreateOrConnectWithoutLockedByInput[]
    createMany?: VideoCreateManyLockedByInputEnvelope
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
  }

  export type VideoUncheckedCreateNestedManyWithoutPublishedByInput = {
    create?: XOR<VideoCreateWithoutPublishedByInput, VideoUncheckedCreateWithoutPublishedByInput> | VideoCreateWithoutPublishedByInput[] | VideoUncheckedCreateWithoutPublishedByInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutPublishedByInput | VideoCreateOrConnectWithoutPublishedByInput[]
    createMany?: VideoCreateManyPublishedByInputEnvelope
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
  }

  export type VideoUncheckedCreateNestedManyWithoutAssignedReviewerInput = {
    create?: XOR<VideoCreateWithoutAssignedReviewerInput, VideoUncheckedCreateWithoutAssignedReviewerInput> | VideoCreateWithoutAssignedReviewerInput[] | VideoUncheckedCreateWithoutAssignedReviewerInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutAssignedReviewerInput | VideoCreateOrConnectWithoutAssignedReviewerInput[]
    createMany?: VideoCreateManyAssignedReviewerInputEnvelope
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
  }

  export type VideoReviewUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<VideoReviewCreateWithoutReviewerInput, VideoReviewUncheckedCreateWithoutReviewerInput> | VideoReviewCreateWithoutReviewerInput[] | VideoReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: VideoReviewCreateOrConnectWithoutReviewerInput | VideoReviewCreateOrConnectWithoutReviewerInput[]
    createMany?: VideoReviewCreateManyReviewerInputEnvelope
    connect?: VideoReviewWhereUniqueInput | VideoReviewWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type TopicUpdateManyWithoutAssignedDoctorNestedInput = {
    create?: XOR<TopicCreateWithoutAssignedDoctorInput, TopicUncheckedCreateWithoutAssignedDoctorInput> | TopicCreateWithoutAssignedDoctorInput[] | TopicUncheckedCreateWithoutAssignedDoctorInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutAssignedDoctorInput | TopicCreateOrConnectWithoutAssignedDoctorInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutAssignedDoctorInput | TopicUpsertWithWhereUniqueWithoutAssignedDoctorInput[]
    createMany?: TopicCreateManyAssignedDoctorInputEnvelope
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutAssignedDoctorInput | TopicUpdateWithWhereUniqueWithoutAssignedDoctorInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutAssignedDoctorInput | TopicUpdateManyWithWhereWithoutAssignedDoctorInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type TopicUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TopicCreateWithoutCreatedByInput, TopicUncheckedCreateWithoutCreatedByInput> | TopicCreateWithoutCreatedByInput[] | TopicUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutCreatedByInput | TopicCreateOrConnectWithoutCreatedByInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutCreatedByInput | TopicUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TopicCreateManyCreatedByInputEnvelope
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutCreatedByInput | TopicUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutCreatedByInput | TopicUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type DoctorPointerUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<DoctorPointerCreateWithoutDoctorInput, DoctorPointerUncheckedCreateWithoutDoctorInput> | DoctorPointerCreateWithoutDoctorInput[] | DoctorPointerUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorPointerCreateOrConnectWithoutDoctorInput | DoctorPointerCreateOrConnectWithoutDoctorInput[]
    upsert?: DoctorPointerUpsertWithWhereUniqueWithoutDoctorInput | DoctorPointerUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: DoctorPointerCreateManyDoctorInputEnvelope
    set?: DoctorPointerWhereUniqueInput | DoctorPointerWhereUniqueInput[]
    disconnect?: DoctorPointerWhereUniqueInput | DoctorPointerWhereUniqueInput[]
    delete?: DoctorPointerWhereUniqueInput | DoctorPointerWhereUniqueInput[]
    connect?: DoctorPointerWhereUniqueInput | DoctorPointerWhereUniqueInput[]
    update?: DoctorPointerUpdateWithWhereUniqueWithoutDoctorInput | DoctorPointerUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: DoctorPointerUpdateManyWithWhereWithoutDoctorInput | DoctorPointerUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: DoctorPointerScalarWhereInput | DoctorPointerScalarWhereInput[]
  }

  export type ScriptUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<ScriptCreateWithoutUploadedByInput, ScriptUncheckedCreateWithoutUploadedByInput> | ScriptCreateWithoutUploadedByInput[] | ScriptUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: ScriptCreateOrConnectWithoutUploadedByInput | ScriptCreateOrConnectWithoutUploadedByInput[]
    upsert?: ScriptUpsertWithWhereUniqueWithoutUploadedByInput | ScriptUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: ScriptCreateManyUploadedByInputEnvelope
    set?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    disconnect?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    delete?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    connect?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    update?: ScriptUpdateWithWhereUniqueWithoutUploadedByInput | ScriptUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: ScriptUpdateManyWithWhereWithoutUploadedByInput | ScriptUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: ScriptScalarWhereInput | ScriptScalarWhereInput[]
  }

  export type ScriptUpdateManyWithoutLockedByNestedInput = {
    create?: XOR<ScriptCreateWithoutLockedByInput, ScriptUncheckedCreateWithoutLockedByInput> | ScriptCreateWithoutLockedByInput[] | ScriptUncheckedCreateWithoutLockedByInput[]
    connectOrCreate?: ScriptCreateOrConnectWithoutLockedByInput | ScriptCreateOrConnectWithoutLockedByInput[]
    upsert?: ScriptUpsertWithWhereUniqueWithoutLockedByInput | ScriptUpsertWithWhereUniqueWithoutLockedByInput[]
    createMany?: ScriptCreateManyLockedByInputEnvelope
    set?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    disconnect?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    delete?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    connect?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    update?: ScriptUpdateWithWhereUniqueWithoutLockedByInput | ScriptUpdateWithWhereUniqueWithoutLockedByInput[]
    updateMany?: ScriptUpdateManyWithWhereWithoutLockedByInput | ScriptUpdateManyWithWhereWithoutLockedByInput[]
    deleteMany?: ScriptScalarWhereInput | ScriptScalarWhereInput[]
  }

  export type ScriptUpdateManyWithoutAssignedReviewerNestedInput = {
    create?: XOR<ScriptCreateWithoutAssignedReviewerInput, ScriptUncheckedCreateWithoutAssignedReviewerInput> | ScriptCreateWithoutAssignedReviewerInput[] | ScriptUncheckedCreateWithoutAssignedReviewerInput[]
    connectOrCreate?: ScriptCreateOrConnectWithoutAssignedReviewerInput | ScriptCreateOrConnectWithoutAssignedReviewerInput[]
    upsert?: ScriptUpsertWithWhereUniqueWithoutAssignedReviewerInput | ScriptUpsertWithWhereUniqueWithoutAssignedReviewerInput[]
    createMany?: ScriptCreateManyAssignedReviewerInputEnvelope
    set?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    disconnect?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    delete?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    connect?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    update?: ScriptUpdateWithWhereUniqueWithoutAssignedReviewerInput | ScriptUpdateWithWhereUniqueWithoutAssignedReviewerInput[]
    updateMany?: ScriptUpdateManyWithWhereWithoutAssignedReviewerInput | ScriptUpdateManyWithWhereWithoutAssignedReviewerInput[]
    deleteMany?: ScriptScalarWhereInput | ScriptScalarWhereInput[]
  }

  export type ScriptReviewUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<ScriptReviewCreateWithoutReviewerInput, ScriptReviewUncheckedCreateWithoutReviewerInput> | ScriptReviewCreateWithoutReviewerInput[] | ScriptReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: ScriptReviewCreateOrConnectWithoutReviewerInput | ScriptReviewCreateOrConnectWithoutReviewerInput[]
    upsert?: ScriptReviewUpsertWithWhereUniqueWithoutReviewerInput | ScriptReviewUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: ScriptReviewCreateManyReviewerInputEnvelope
    set?: ScriptReviewWhereUniqueInput | ScriptReviewWhereUniqueInput[]
    disconnect?: ScriptReviewWhereUniqueInput | ScriptReviewWhereUniqueInput[]
    delete?: ScriptReviewWhereUniqueInput | ScriptReviewWhereUniqueInput[]
    connect?: ScriptReviewWhereUniqueInput | ScriptReviewWhereUniqueInput[]
    update?: ScriptReviewUpdateWithWhereUniqueWithoutReviewerInput | ScriptReviewUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: ScriptReviewUpdateManyWithWhereWithoutReviewerInput | ScriptReviewUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: ScriptReviewScalarWhereInput | ScriptReviewScalarWhereInput[]
  }

  export type VideoUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<VideoCreateWithoutUploadedByInput, VideoUncheckedCreateWithoutUploadedByInput> | VideoCreateWithoutUploadedByInput[] | VideoUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutUploadedByInput | VideoCreateOrConnectWithoutUploadedByInput[]
    upsert?: VideoUpsertWithWhereUniqueWithoutUploadedByInput | VideoUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: VideoCreateManyUploadedByInputEnvelope
    set?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    disconnect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    delete?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    update?: VideoUpdateWithWhereUniqueWithoutUploadedByInput | VideoUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: VideoUpdateManyWithWhereWithoutUploadedByInput | VideoUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: VideoScalarWhereInput | VideoScalarWhereInput[]
  }

  export type VideoUpdateManyWithoutLockedByNestedInput = {
    create?: XOR<VideoCreateWithoutLockedByInput, VideoUncheckedCreateWithoutLockedByInput> | VideoCreateWithoutLockedByInput[] | VideoUncheckedCreateWithoutLockedByInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutLockedByInput | VideoCreateOrConnectWithoutLockedByInput[]
    upsert?: VideoUpsertWithWhereUniqueWithoutLockedByInput | VideoUpsertWithWhereUniqueWithoutLockedByInput[]
    createMany?: VideoCreateManyLockedByInputEnvelope
    set?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    disconnect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    delete?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    update?: VideoUpdateWithWhereUniqueWithoutLockedByInput | VideoUpdateWithWhereUniqueWithoutLockedByInput[]
    updateMany?: VideoUpdateManyWithWhereWithoutLockedByInput | VideoUpdateManyWithWhereWithoutLockedByInput[]
    deleteMany?: VideoScalarWhereInput | VideoScalarWhereInput[]
  }

  export type VideoUpdateManyWithoutPublishedByNestedInput = {
    create?: XOR<VideoCreateWithoutPublishedByInput, VideoUncheckedCreateWithoutPublishedByInput> | VideoCreateWithoutPublishedByInput[] | VideoUncheckedCreateWithoutPublishedByInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutPublishedByInput | VideoCreateOrConnectWithoutPublishedByInput[]
    upsert?: VideoUpsertWithWhereUniqueWithoutPublishedByInput | VideoUpsertWithWhereUniqueWithoutPublishedByInput[]
    createMany?: VideoCreateManyPublishedByInputEnvelope
    set?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    disconnect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    delete?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    update?: VideoUpdateWithWhereUniqueWithoutPublishedByInput | VideoUpdateWithWhereUniqueWithoutPublishedByInput[]
    updateMany?: VideoUpdateManyWithWhereWithoutPublishedByInput | VideoUpdateManyWithWhereWithoutPublishedByInput[]
    deleteMany?: VideoScalarWhereInput | VideoScalarWhereInput[]
  }

  export type VideoUpdateManyWithoutAssignedReviewerNestedInput = {
    create?: XOR<VideoCreateWithoutAssignedReviewerInput, VideoUncheckedCreateWithoutAssignedReviewerInput> | VideoCreateWithoutAssignedReviewerInput[] | VideoUncheckedCreateWithoutAssignedReviewerInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutAssignedReviewerInput | VideoCreateOrConnectWithoutAssignedReviewerInput[]
    upsert?: VideoUpsertWithWhereUniqueWithoutAssignedReviewerInput | VideoUpsertWithWhereUniqueWithoutAssignedReviewerInput[]
    createMany?: VideoCreateManyAssignedReviewerInputEnvelope
    set?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    disconnect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    delete?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    update?: VideoUpdateWithWhereUniqueWithoutAssignedReviewerInput | VideoUpdateWithWhereUniqueWithoutAssignedReviewerInput[]
    updateMany?: VideoUpdateManyWithWhereWithoutAssignedReviewerInput | VideoUpdateManyWithWhereWithoutAssignedReviewerInput[]
    deleteMany?: VideoScalarWhereInput | VideoScalarWhereInput[]
  }

  export type VideoReviewUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<VideoReviewCreateWithoutReviewerInput, VideoReviewUncheckedCreateWithoutReviewerInput> | VideoReviewCreateWithoutReviewerInput[] | VideoReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: VideoReviewCreateOrConnectWithoutReviewerInput | VideoReviewCreateOrConnectWithoutReviewerInput[]
    upsert?: VideoReviewUpsertWithWhereUniqueWithoutReviewerInput | VideoReviewUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: VideoReviewCreateManyReviewerInputEnvelope
    set?: VideoReviewWhereUniqueInput | VideoReviewWhereUniqueInput[]
    disconnect?: VideoReviewWhereUniqueInput | VideoReviewWhereUniqueInput[]
    delete?: VideoReviewWhereUniqueInput | VideoReviewWhereUniqueInput[]
    connect?: VideoReviewWhereUniqueInput | VideoReviewWhereUniqueInput[]
    update?: VideoReviewUpdateWithWhereUniqueWithoutReviewerInput | VideoReviewUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: VideoReviewUpdateManyWithWhereWithoutReviewerInput | VideoReviewUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: VideoReviewScalarWhereInput | VideoReviewScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type TopicUncheckedUpdateManyWithoutAssignedDoctorNestedInput = {
    create?: XOR<TopicCreateWithoutAssignedDoctorInput, TopicUncheckedCreateWithoutAssignedDoctorInput> | TopicCreateWithoutAssignedDoctorInput[] | TopicUncheckedCreateWithoutAssignedDoctorInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutAssignedDoctorInput | TopicCreateOrConnectWithoutAssignedDoctorInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutAssignedDoctorInput | TopicUpsertWithWhereUniqueWithoutAssignedDoctorInput[]
    createMany?: TopicCreateManyAssignedDoctorInputEnvelope
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutAssignedDoctorInput | TopicUpdateWithWhereUniqueWithoutAssignedDoctorInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutAssignedDoctorInput | TopicUpdateManyWithWhereWithoutAssignedDoctorInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type TopicUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TopicCreateWithoutCreatedByInput, TopicUncheckedCreateWithoutCreatedByInput> | TopicCreateWithoutCreatedByInput[] | TopicUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutCreatedByInput | TopicCreateOrConnectWithoutCreatedByInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutCreatedByInput | TopicUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TopicCreateManyCreatedByInputEnvelope
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutCreatedByInput | TopicUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutCreatedByInput | TopicUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type DoctorPointerUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<DoctorPointerCreateWithoutDoctorInput, DoctorPointerUncheckedCreateWithoutDoctorInput> | DoctorPointerCreateWithoutDoctorInput[] | DoctorPointerUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorPointerCreateOrConnectWithoutDoctorInput | DoctorPointerCreateOrConnectWithoutDoctorInput[]
    upsert?: DoctorPointerUpsertWithWhereUniqueWithoutDoctorInput | DoctorPointerUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: DoctorPointerCreateManyDoctorInputEnvelope
    set?: DoctorPointerWhereUniqueInput | DoctorPointerWhereUniqueInput[]
    disconnect?: DoctorPointerWhereUniqueInput | DoctorPointerWhereUniqueInput[]
    delete?: DoctorPointerWhereUniqueInput | DoctorPointerWhereUniqueInput[]
    connect?: DoctorPointerWhereUniqueInput | DoctorPointerWhereUniqueInput[]
    update?: DoctorPointerUpdateWithWhereUniqueWithoutDoctorInput | DoctorPointerUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: DoctorPointerUpdateManyWithWhereWithoutDoctorInput | DoctorPointerUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: DoctorPointerScalarWhereInput | DoctorPointerScalarWhereInput[]
  }

  export type ScriptUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<ScriptCreateWithoutUploadedByInput, ScriptUncheckedCreateWithoutUploadedByInput> | ScriptCreateWithoutUploadedByInput[] | ScriptUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: ScriptCreateOrConnectWithoutUploadedByInput | ScriptCreateOrConnectWithoutUploadedByInput[]
    upsert?: ScriptUpsertWithWhereUniqueWithoutUploadedByInput | ScriptUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: ScriptCreateManyUploadedByInputEnvelope
    set?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    disconnect?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    delete?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    connect?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    update?: ScriptUpdateWithWhereUniqueWithoutUploadedByInput | ScriptUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: ScriptUpdateManyWithWhereWithoutUploadedByInput | ScriptUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: ScriptScalarWhereInput | ScriptScalarWhereInput[]
  }

  export type ScriptUncheckedUpdateManyWithoutLockedByNestedInput = {
    create?: XOR<ScriptCreateWithoutLockedByInput, ScriptUncheckedCreateWithoutLockedByInput> | ScriptCreateWithoutLockedByInput[] | ScriptUncheckedCreateWithoutLockedByInput[]
    connectOrCreate?: ScriptCreateOrConnectWithoutLockedByInput | ScriptCreateOrConnectWithoutLockedByInput[]
    upsert?: ScriptUpsertWithWhereUniqueWithoutLockedByInput | ScriptUpsertWithWhereUniqueWithoutLockedByInput[]
    createMany?: ScriptCreateManyLockedByInputEnvelope
    set?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    disconnect?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    delete?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    connect?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    update?: ScriptUpdateWithWhereUniqueWithoutLockedByInput | ScriptUpdateWithWhereUniqueWithoutLockedByInput[]
    updateMany?: ScriptUpdateManyWithWhereWithoutLockedByInput | ScriptUpdateManyWithWhereWithoutLockedByInput[]
    deleteMany?: ScriptScalarWhereInput | ScriptScalarWhereInput[]
  }

  export type ScriptUncheckedUpdateManyWithoutAssignedReviewerNestedInput = {
    create?: XOR<ScriptCreateWithoutAssignedReviewerInput, ScriptUncheckedCreateWithoutAssignedReviewerInput> | ScriptCreateWithoutAssignedReviewerInput[] | ScriptUncheckedCreateWithoutAssignedReviewerInput[]
    connectOrCreate?: ScriptCreateOrConnectWithoutAssignedReviewerInput | ScriptCreateOrConnectWithoutAssignedReviewerInput[]
    upsert?: ScriptUpsertWithWhereUniqueWithoutAssignedReviewerInput | ScriptUpsertWithWhereUniqueWithoutAssignedReviewerInput[]
    createMany?: ScriptCreateManyAssignedReviewerInputEnvelope
    set?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    disconnect?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    delete?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    connect?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    update?: ScriptUpdateWithWhereUniqueWithoutAssignedReviewerInput | ScriptUpdateWithWhereUniqueWithoutAssignedReviewerInput[]
    updateMany?: ScriptUpdateManyWithWhereWithoutAssignedReviewerInput | ScriptUpdateManyWithWhereWithoutAssignedReviewerInput[]
    deleteMany?: ScriptScalarWhereInput | ScriptScalarWhereInput[]
  }

  export type ScriptReviewUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<ScriptReviewCreateWithoutReviewerInput, ScriptReviewUncheckedCreateWithoutReviewerInput> | ScriptReviewCreateWithoutReviewerInput[] | ScriptReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: ScriptReviewCreateOrConnectWithoutReviewerInput | ScriptReviewCreateOrConnectWithoutReviewerInput[]
    upsert?: ScriptReviewUpsertWithWhereUniqueWithoutReviewerInput | ScriptReviewUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: ScriptReviewCreateManyReviewerInputEnvelope
    set?: ScriptReviewWhereUniqueInput | ScriptReviewWhereUniqueInput[]
    disconnect?: ScriptReviewWhereUniqueInput | ScriptReviewWhereUniqueInput[]
    delete?: ScriptReviewWhereUniqueInput | ScriptReviewWhereUniqueInput[]
    connect?: ScriptReviewWhereUniqueInput | ScriptReviewWhereUniqueInput[]
    update?: ScriptReviewUpdateWithWhereUniqueWithoutReviewerInput | ScriptReviewUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: ScriptReviewUpdateManyWithWhereWithoutReviewerInput | ScriptReviewUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: ScriptReviewScalarWhereInput | ScriptReviewScalarWhereInput[]
  }

  export type VideoUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<VideoCreateWithoutUploadedByInput, VideoUncheckedCreateWithoutUploadedByInput> | VideoCreateWithoutUploadedByInput[] | VideoUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutUploadedByInput | VideoCreateOrConnectWithoutUploadedByInput[]
    upsert?: VideoUpsertWithWhereUniqueWithoutUploadedByInput | VideoUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: VideoCreateManyUploadedByInputEnvelope
    set?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    disconnect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    delete?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    update?: VideoUpdateWithWhereUniqueWithoutUploadedByInput | VideoUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: VideoUpdateManyWithWhereWithoutUploadedByInput | VideoUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: VideoScalarWhereInput | VideoScalarWhereInput[]
  }

  export type VideoUncheckedUpdateManyWithoutLockedByNestedInput = {
    create?: XOR<VideoCreateWithoutLockedByInput, VideoUncheckedCreateWithoutLockedByInput> | VideoCreateWithoutLockedByInput[] | VideoUncheckedCreateWithoutLockedByInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutLockedByInput | VideoCreateOrConnectWithoutLockedByInput[]
    upsert?: VideoUpsertWithWhereUniqueWithoutLockedByInput | VideoUpsertWithWhereUniqueWithoutLockedByInput[]
    createMany?: VideoCreateManyLockedByInputEnvelope
    set?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    disconnect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    delete?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    update?: VideoUpdateWithWhereUniqueWithoutLockedByInput | VideoUpdateWithWhereUniqueWithoutLockedByInput[]
    updateMany?: VideoUpdateManyWithWhereWithoutLockedByInput | VideoUpdateManyWithWhereWithoutLockedByInput[]
    deleteMany?: VideoScalarWhereInput | VideoScalarWhereInput[]
  }

  export type VideoUncheckedUpdateManyWithoutPublishedByNestedInput = {
    create?: XOR<VideoCreateWithoutPublishedByInput, VideoUncheckedCreateWithoutPublishedByInput> | VideoCreateWithoutPublishedByInput[] | VideoUncheckedCreateWithoutPublishedByInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutPublishedByInput | VideoCreateOrConnectWithoutPublishedByInput[]
    upsert?: VideoUpsertWithWhereUniqueWithoutPublishedByInput | VideoUpsertWithWhereUniqueWithoutPublishedByInput[]
    createMany?: VideoCreateManyPublishedByInputEnvelope
    set?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    disconnect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    delete?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    update?: VideoUpdateWithWhereUniqueWithoutPublishedByInput | VideoUpdateWithWhereUniqueWithoutPublishedByInput[]
    updateMany?: VideoUpdateManyWithWhereWithoutPublishedByInput | VideoUpdateManyWithWhereWithoutPublishedByInput[]
    deleteMany?: VideoScalarWhereInput | VideoScalarWhereInput[]
  }

  export type VideoUncheckedUpdateManyWithoutAssignedReviewerNestedInput = {
    create?: XOR<VideoCreateWithoutAssignedReviewerInput, VideoUncheckedCreateWithoutAssignedReviewerInput> | VideoCreateWithoutAssignedReviewerInput[] | VideoUncheckedCreateWithoutAssignedReviewerInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutAssignedReviewerInput | VideoCreateOrConnectWithoutAssignedReviewerInput[]
    upsert?: VideoUpsertWithWhereUniqueWithoutAssignedReviewerInput | VideoUpsertWithWhereUniqueWithoutAssignedReviewerInput[]
    createMany?: VideoCreateManyAssignedReviewerInputEnvelope
    set?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    disconnect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    delete?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    update?: VideoUpdateWithWhereUniqueWithoutAssignedReviewerInput | VideoUpdateWithWhereUniqueWithoutAssignedReviewerInput[]
    updateMany?: VideoUpdateManyWithWhereWithoutAssignedReviewerInput | VideoUpdateManyWithWhereWithoutAssignedReviewerInput[]
    deleteMany?: VideoScalarWhereInput | VideoScalarWhereInput[]
  }

  export type VideoReviewUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<VideoReviewCreateWithoutReviewerInput, VideoReviewUncheckedCreateWithoutReviewerInput> | VideoReviewCreateWithoutReviewerInput[] | VideoReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: VideoReviewCreateOrConnectWithoutReviewerInput | VideoReviewCreateOrConnectWithoutReviewerInput[]
    upsert?: VideoReviewUpsertWithWhereUniqueWithoutReviewerInput | VideoReviewUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: VideoReviewCreateManyReviewerInputEnvelope
    set?: VideoReviewWhereUniqueInput | VideoReviewWhereUniqueInput[]
    disconnect?: VideoReviewWhereUniqueInput | VideoReviewWhereUniqueInput[]
    delete?: VideoReviewWhereUniqueInput | VideoReviewWhereUniqueInput[]
    connect?: VideoReviewWhereUniqueInput | VideoReviewWhereUniqueInput[]
    update?: VideoReviewUpdateWithWhereUniqueWithoutReviewerInput | VideoReviewUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: VideoReviewUpdateManyWithWhereWithoutReviewerInput | VideoReviewUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: VideoReviewScalarWhereInput | VideoReviewScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAssignedTopicsInput = {
    create?: XOR<UserCreateWithoutAssignedTopicsInput, UserUncheckedCreateWithoutAssignedTopicsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTopicsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedTopicsInput = {
    create?: XOR<UserCreateWithoutCreatedTopicsInput, UserUncheckedCreateWithoutCreatedTopicsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTopicsInput
    connect?: UserWhereUniqueInput
  }

  export type DoctorPointerCreateNestedManyWithoutTopicInput = {
    create?: XOR<DoctorPointerCreateWithoutTopicInput, DoctorPointerUncheckedCreateWithoutTopicInput> | DoctorPointerCreateWithoutTopicInput[] | DoctorPointerUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: DoctorPointerCreateOrConnectWithoutTopicInput | DoctorPointerCreateOrConnectWithoutTopicInput[]
    createMany?: DoctorPointerCreateManyTopicInputEnvelope
    connect?: DoctorPointerWhereUniqueInput | DoctorPointerWhereUniqueInput[]
  }

  export type ScriptCreateNestedManyWithoutTopicInput = {
    create?: XOR<ScriptCreateWithoutTopicInput, ScriptUncheckedCreateWithoutTopicInput> | ScriptCreateWithoutTopicInput[] | ScriptUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ScriptCreateOrConnectWithoutTopicInput | ScriptCreateOrConnectWithoutTopicInput[]
    createMany?: ScriptCreateManyTopicInputEnvelope
    connect?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
  }

  export type VideoCreateNestedManyWithoutTopicInput = {
    create?: XOR<VideoCreateWithoutTopicInput, VideoUncheckedCreateWithoutTopicInput> | VideoCreateWithoutTopicInput[] | VideoUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutTopicInput | VideoCreateOrConnectWithoutTopicInput[]
    createMany?: VideoCreateManyTopicInputEnvelope
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
  }

  export type DoctorPointerUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<DoctorPointerCreateWithoutTopicInput, DoctorPointerUncheckedCreateWithoutTopicInput> | DoctorPointerCreateWithoutTopicInput[] | DoctorPointerUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: DoctorPointerCreateOrConnectWithoutTopicInput | DoctorPointerCreateOrConnectWithoutTopicInput[]
    createMany?: DoctorPointerCreateManyTopicInputEnvelope
    connect?: DoctorPointerWhereUniqueInput | DoctorPointerWhereUniqueInput[]
  }

  export type ScriptUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<ScriptCreateWithoutTopicInput, ScriptUncheckedCreateWithoutTopicInput> | ScriptCreateWithoutTopicInput[] | ScriptUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ScriptCreateOrConnectWithoutTopicInput | ScriptCreateOrConnectWithoutTopicInput[]
    createMany?: ScriptCreateManyTopicInputEnvelope
    connect?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
  }

  export type VideoUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<VideoCreateWithoutTopicInput, VideoUncheckedCreateWithoutTopicInput> | VideoCreateWithoutTopicInput[] | VideoUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutTopicInput | VideoCreateOrConnectWithoutTopicInput[]
    createMany?: VideoCreateManyTopicInputEnvelope
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
  }

  export type EnumTopicStatusFieldUpdateOperationsInput = {
    set?: $Enums.TopicStatus
  }

  export type UserUpdateOneRequiredWithoutAssignedTopicsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedTopicsInput, UserUncheckedCreateWithoutAssignedTopicsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTopicsInput
    upsert?: UserUpsertWithoutAssignedTopicsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedTopicsInput, UserUpdateWithoutAssignedTopicsInput>, UserUncheckedUpdateWithoutAssignedTopicsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedTopicsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedTopicsInput, UserUncheckedCreateWithoutCreatedTopicsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTopicsInput
    upsert?: UserUpsertWithoutCreatedTopicsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedTopicsInput, UserUpdateWithoutCreatedTopicsInput>, UserUncheckedUpdateWithoutCreatedTopicsInput>
  }

  export type DoctorPointerUpdateManyWithoutTopicNestedInput = {
    create?: XOR<DoctorPointerCreateWithoutTopicInput, DoctorPointerUncheckedCreateWithoutTopicInput> | DoctorPointerCreateWithoutTopicInput[] | DoctorPointerUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: DoctorPointerCreateOrConnectWithoutTopicInput | DoctorPointerCreateOrConnectWithoutTopicInput[]
    upsert?: DoctorPointerUpsertWithWhereUniqueWithoutTopicInput | DoctorPointerUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: DoctorPointerCreateManyTopicInputEnvelope
    set?: DoctorPointerWhereUniqueInput | DoctorPointerWhereUniqueInput[]
    disconnect?: DoctorPointerWhereUniqueInput | DoctorPointerWhereUniqueInput[]
    delete?: DoctorPointerWhereUniqueInput | DoctorPointerWhereUniqueInput[]
    connect?: DoctorPointerWhereUniqueInput | DoctorPointerWhereUniqueInput[]
    update?: DoctorPointerUpdateWithWhereUniqueWithoutTopicInput | DoctorPointerUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: DoctorPointerUpdateManyWithWhereWithoutTopicInput | DoctorPointerUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: DoctorPointerScalarWhereInput | DoctorPointerScalarWhereInput[]
  }

  export type ScriptUpdateManyWithoutTopicNestedInput = {
    create?: XOR<ScriptCreateWithoutTopicInput, ScriptUncheckedCreateWithoutTopicInput> | ScriptCreateWithoutTopicInput[] | ScriptUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ScriptCreateOrConnectWithoutTopicInput | ScriptCreateOrConnectWithoutTopicInput[]
    upsert?: ScriptUpsertWithWhereUniqueWithoutTopicInput | ScriptUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: ScriptCreateManyTopicInputEnvelope
    set?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    disconnect?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    delete?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    connect?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    update?: ScriptUpdateWithWhereUniqueWithoutTopicInput | ScriptUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: ScriptUpdateManyWithWhereWithoutTopicInput | ScriptUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: ScriptScalarWhereInput | ScriptScalarWhereInput[]
  }

  export type VideoUpdateManyWithoutTopicNestedInput = {
    create?: XOR<VideoCreateWithoutTopicInput, VideoUncheckedCreateWithoutTopicInput> | VideoCreateWithoutTopicInput[] | VideoUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutTopicInput | VideoCreateOrConnectWithoutTopicInput[]
    upsert?: VideoUpsertWithWhereUniqueWithoutTopicInput | VideoUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: VideoCreateManyTopicInputEnvelope
    set?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    disconnect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    delete?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    update?: VideoUpdateWithWhereUniqueWithoutTopicInput | VideoUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: VideoUpdateManyWithWhereWithoutTopicInput | VideoUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: VideoScalarWhereInput | VideoScalarWhereInput[]
  }

  export type DoctorPointerUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<DoctorPointerCreateWithoutTopicInput, DoctorPointerUncheckedCreateWithoutTopicInput> | DoctorPointerCreateWithoutTopicInput[] | DoctorPointerUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: DoctorPointerCreateOrConnectWithoutTopicInput | DoctorPointerCreateOrConnectWithoutTopicInput[]
    upsert?: DoctorPointerUpsertWithWhereUniqueWithoutTopicInput | DoctorPointerUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: DoctorPointerCreateManyTopicInputEnvelope
    set?: DoctorPointerWhereUniqueInput | DoctorPointerWhereUniqueInput[]
    disconnect?: DoctorPointerWhereUniqueInput | DoctorPointerWhereUniqueInput[]
    delete?: DoctorPointerWhereUniqueInput | DoctorPointerWhereUniqueInput[]
    connect?: DoctorPointerWhereUniqueInput | DoctorPointerWhereUniqueInput[]
    update?: DoctorPointerUpdateWithWhereUniqueWithoutTopicInput | DoctorPointerUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: DoctorPointerUpdateManyWithWhereWithoutTopicInput | DoctorPointerUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: DoctorPointerScalarWhereInput | DoctorPointerScalarWhereInput[]
  }

  export type ScriptUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<ScriptCreateWithoutTopicInput, ScriptUncheckedCreateWithoutTopicInput> | ScriptCreateWithoutTopicInput[] | ScriptUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ScriptCreateOrConnectWithoutTopicInput | ScriptCreateOrConnectWithoutTopicInput[]
    upsert?: ScriptUpsertWithWhereUniqueWithoutTopicInput | ScriptUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: ScriptCreateManyTopicInputEnvelope
    set?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    disconnect?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    delete?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    connect?: ScriptWhereUniqueInput | ScriptWhereUniqueInput[]
    update?: ScriptUpdateWithWhereUniqueWithoutTopicInput | ScriptUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: ScriptUpdateManyWithWhereWithoutTopicInput | ScriptUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: ScriptScalarWhereInput | ScriptScalarWhereInput[]
  }

  export type VideoUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<VideoCreateWithoutTopicInput, VideoUncheckedCreateWithoutTopicInput> | VideoCreateWithoutTopicInput[] | VideoUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutTopicInput | VideoCreateOrConnectWithoutTopicInput[]
    upsert?: VideoUpsertWithWhereUniqueWithoutTopicInput | VideoUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: VideoCreateManyTopicInputEnvelope
    set?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    disconnect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    delete?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    update?: VideoUpdateWithWhereUniqueWithoutTopicInput | VideoUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: VideoUpdateManyWithWhereWithoutTopicInput | VideoUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: VideoScalarWhereInput | VideoScalarWhereInput[]
  }

  export type TopicCreateNestedOneWithoutDoctorPointersInput = {
    create?: XOR<TopicCreateWithoutDoctorPointersInput, TopicUncheckedCreateWithoutDoctorPointersInput>
    connectOrCreate?: TopicCreateOrConnectWithoutDoctorPointersInput
    connect?: TopicWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDoctorPointersInput = {
    create?: XOR<UserCreateWithoutDoctorPointersInput, UserUncheckedCreateWithoutDoctorPointersInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorPointersInput
    connect?: UserWhereUniqueInput
  }

  export type TopicUpdateOneRequiredWithoutDoctorPointersNestedInput = {
    create?: XOR<TopicCreateWithoutDoctorPointersInput, TopicUncheckedCreateWithoutDoctorPointersInput>
    connectOrCreate?: TopicCreateOrConnectWithoutDoctorPointersInput
    upsert?: TopicUpsertWithoutDoctorPointersInput
    connect?: TopicWhereUniqueInput
    update?: XOR<XOR<TopicUpdateToOneWithWhereWithoutDoctorPointersInput, TopicUpdateWithoutDoctorPointersInput>, TopicUncheckedUpdateWithoutDoctorPointersInput>
  }

  export type UserUpdateOneRequiredWithoutDoctorPointersNestedInput = {
    create?: XOR<UserCreateWithoutDoctorPointersInput, UserUncheckedCreateWithoutDoctorPointersInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorPointersInput
    upsert?: UserUpsertWithoutDoctorPointersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDoctorPointersInput, UserUpdateWithoutDoctorPointersInput>, UserUncheckedUpdateWithoutDoctorPointersInput>
  }

  export type ScriptCreatetagsInput = {
    set: string[]
  }

  export type TopicCreateNestedOneWithoutScriptsInput = {
    create?: XOR<TopicCreateWithoutScriptsInput, TopicUncheckedCreateWithoutScriptsInput>
    connectOrCreate?: TopicCreateOrConnectWithoutScriptsInput
    connect?: TopicWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUploadedScriptsInput = {
    create?: XOR<UserCreateWithoutUploadedScriptsInput, UserUncheckedCreateWithoutUploadedScriptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedScriptsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLockedScriptsInput = {
    create?: XOR<UserCreateWithoutLockedScriptsInput, UserUncheckedCreateWithoutLockedScriptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLockedScriptsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedScriptsInput = {
    create?: XOR<UserCreateWithoutAssignedScriptsInput, UserUncheckedCreateWithoutAssignedScriptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedScriptsInput
    connect?: UserWhereUniqueInput
  }

  export type ScriptReviewCreateNestedManyWithoutScriptInput = {
    create?: XOR<ScriptReviewCreateWithoutScriptInput, ScriptReviewUncheckedCreateWithoutScriptInput> | ScriptReviewCreateWithoutScriptInput[] | ScriptReviewUncheckedCreateWithoutScriptInput[]
    connectOrCreate?: ScriptReviewCreateOrConnectWithoutScriptInput | ScriptReviewCreateOrConnectWithoutScriptInput[]
    createMany?: ScriptReviewCreateManyScriptInputEnvelope
    connect?: ScriptReviewWhereUniqueInput | ScriptReviewWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutScriptInput = {
    create?: XOR<CommentCreateWithoutScriptInput, CommentUncheckedCreateWithoutScriptInput> | CommentCreateWithoutScriptInput[] | CommentUncheckedCreateWithoutScriptInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutScriptInput | CommentCreateOrConnectWithoutScriptInput[]
    createMany?: CommentCreateManyScriptInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type VideoCreateNestedManyWithoutScriptInput = {
    create?: XOR<VideoCreateWithoutScriptInput, VideoUncheckedCreateWithoutScriptInput> | VideoCreateWithoutScriptInput[] | VideoUncheckedCreateWithoutScriptInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutScriptInput | VideoCreateOrConnectWithoutScriptInput[]
    createMany?: VideoCreateManyScriptInputEnvelope
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
  }

  export type ScriptReviewUncheckedCreateNestedManyWithoutScriptInput = {
    create?: XOR<ScriptReviewCreateWithoutScriptInput, ScriptReviewUncheckedCreateWithoutScriptInput> | ScriptReviewCreateWithoutScriptInput[] | ScriptReviewUncheckedCreateWithoutScriptInput[]
    connectOrCreate?: ScriptReviewCreateOrConnectWithoutScriptInput | ScriptReviewCreateOrConnectWithoutScriptInput[]
    createMany?: ScriptReviewCreateManyScriptInputEnvelope
    connect?: ScriptReviewWhereUniqueInput | ScriptReviewWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutScriptInput = {
    create?: XOR<CommentCreateWithoutScriptInput, CommentUncheckedCreateWithoutScriptInput> | CommentCreateWithoutScriptInput[] | CommentUncheckedCreateWithoutScriptInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutScriptInput | CommentCreateOrConnectWithoutScriptInput[]
    createMany?: CommentCreateManyScriptInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type VideoUncheckedCreateNestedManyWithoutScriptInput = {
    create?: XOR<VideoCreateWithoutScriptInput, VideoUncheckedCreateWithoutScriptInput> | VideoCreateWithoutScriptInput[] | VideoUncheckedCreateWithoutScriptInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutScriptInput | VideoCreateOrConnectWithoutScriptInput[]
    createMany?: VideoCreateManyScriptInputEnvelope
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumScriptStatusFieldUpdateOperationsInput = {
    set?: $Enums.ScriptStatus
  }

  export type ScriptUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TopicUpdateOneRequiredWithoutScriptsNestedInput = {
    create?: XOR<TopicCreateWithoutScriptsInput, TopicUncheckedCreateWithoutScriptsInput>
    connectOrCreate?: TopicCreateOrConnectWithoutScriptsInput
    upsert?: TopicUpsertWithoutScriptsInput
    connect?: TopicWhereUniqueInput
    update?: XOR<XOR<TopicUpdateToOneWithWhereWithoutScriptsInput, TopicUpdateWithoutScriptsInput>, TopicUncheckedUpdateWithoutScriptsInput>
  }

  export type UserUpdateOneWithoutUploadedScriptsNestedInput = {
    create?: XOR<UserCreateWithoutUploadedScriptsInput, UserUncheckedCreateWithoutUploadedScriptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedScriptsInput
    upsert?: UserUpsertWithoutUploadedScriptsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedScriptsInput, UserUpdateWithoutUploadedScriptsInput>, UserUncheckedUpdateWithoutUploadedScriptsInput>
  }

  export type UserUpdateOneWithoutLockedScriptsNestedInput = {
    create?: XOR<UserCreateWithoutLockedScriptsInput, UserUncheckedCreateWithoutLockedScriptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLockedScriptsInput
    upsert?: UserUpsertWithoutLockedScriptsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLockedScriptsInput, UserUpdateWithoutLockedScriptsInput>, UserUncheckedUpdateWithoutLockedScriptsInput>
  }

  export type UserUpdateOneWithoutAssignedScriptsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedScriptsInput, UserUncheckedCreateWithoutAssignedScriptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedScriptsInput
    upsert?: UserUpsertWithoutAssignedScriptsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedScriptsInput, UserUpdateWithoutAssignedScriptsInput>, UserUncheckedUpdateWithoutAssignedScriptsInput>
  }

  export type ScriptReviewUpdateManyWithoutScriptNestedInput = {
    create?: XOR<ScriptReviewCreateWithoutScriptInput, ScriptReviewUncheckedCreateWithoutScriptInput> | ScriptReviewCreateWithoutScriptInput[] | ScriptReviewUncheckedCreateWithoutScriptInput[]
    connectOrCreate?: ScriptReviewCreateOrConnectWithoutScriptInput | ScriptReviewCreateOrConnectWithoutScriptInput[]
    upsert?: ScriptReviewUpsertWithWhereUniqueWithoutScriptInput | ScriptReviewUpsertWithWhereUniqueWithoutScriptInput[]
    createMany?: ScriptReviewCreateManyScriptInputEnvelope
    set?: ScriptReviewWhereUniqueInput | ScriptReviewWhereUniqueInput[]
    disconnect?: ScriptReviewWhereUniqueInput | ScriptReviewWhereUniqueInput[]
    delete?: ScriptReviewWhereUniqueInput | ScriptReviewWhereUniqueInput[]
    connect?: ScriptReviewWhereUniqueInput | ScriptReviewWhereUniqueInput[]
    update?: ScriptReviewUpdateWithWhereUniqueWithoutScriptInput | ScriptReviewUpdateWithWhereUniqueWithoutScriptInput[]
    updateMany?: ScriptReviewUpdateManyWithWhereWithoutScriptInput | ScriptReviewUpdateManyWithWhereWithoutScriptInput[]
    deleteMany?: ScriptReviewScalarWhereInput | ScriptReviewScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutScriptNestedInput = {
    create?: XOR<CommentCreateWithoutScriptInput, CommentUncheckedCreateWithoutScriptInput> | CommentCreateWithoutScriptInput[] | CommentUncheckedCreateWithoutScriptInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutScriptInput | CommentCreateOrConnectWithoutScriptInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutScriptInput | CommentUpsertWithWhereUniqueWithoutScriptInput[]
    createMany?: CommentCreateManyScriptInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutScriptInput | CommentUpdateWithWhereUniqueWithoutScriptInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutScriptInput | CommentUpdateManyWithWhereWithoutScriptInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type VideoUpdateManyWithoutScriptNestedInput = {
    create?: XOR<VideoCreateWithoutScriptInput, VideoUncheckedCreateWithoutScriptInput> | VideoCreateWithoutScriptInput[] | VideoUncheckedCreateWithoutScriptInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutScriptInput | VideoCreateOrConnectWithoutScriptInput[]
    upsert?: VideoUpsertWithWhereUniqueWithoutScriptInput | VideoUpsertWithWhereUniqueWithoutScriptInput[]
    createMany?: VideoCreateManyScriptInputEnvelope
    set?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    disconnect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    delete?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    update?: VideoUpdateWithWhereUniqueWithoutScriptInput | VideoUpdateWithWhereUniqueWithoutScriptInput[]
    updateMany?: VideoUpdateManyWithWhereWithoutScriptInput | VideoUpdateManyWithWhereWithoutScriptInput[]
    deleteMany?: VideoScalarWhereInput | VideoScalarWhereInput[]
  }

  export type ScriptReviewUncheckedUpdateManyWithoutScriptNestedInput = {
    create?: XOR<ScriptReviewCreateWithoutScriptInput, ScriptReviewUncheckedCreateWithoutScriptInput> | ScriptReviewCreateWithoutScriptInput[] | ScriptReviewUncheckedCreateWithoutScriptInput[]
    connectOrCreate?: ScriptReviewCreateOrConnectWithoutScriptInput | ScriptReviewCreateOrConnectWithoutScriptInput[]
    upsert?: ScriptReviewUpsertWithWhereUniqueWithoutScriptInput | ScriptReviewUpsertWithWhereUniqueWithoutScriptInput[]
    createMany?: ScriptReviewCreateManyScriptInputEnvelope
    set?: ScriptReviewWhereUniqueInput | ScriptReviewWhereUniqueInput[]
    disconnect?: ScriptReviewWhereUniqueInput | ScriptReviewWhereUniqueInput[]
    delete?: ScriptReviewWhereUniqueInput | ScriptReviewWhereUniqueInput[]
    connect?: ScriptReviewWhereUniqueInput | ScriptReviewWhereUniqueInput[]
    update?: ScriptReviewUpdateWithWhereUniqueWithoutScriptInput | ScriptReviewUpdateWithWhereUniqueWithoutScriptInput[]
    updateMany?: ScriptReviewUpdateManyWithWhereWithoutScriptInput | ScriptReviewUpdateManyWithWhereWithoutScriptInput[]
    deleteMany?: ScriptReviewScalarWhereInput | ScriptReviewScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutScriptNestedInput = {
    create?: XOR<CommentCreateWithoutScriptInput, CommentUncheckedCreateWithoutScriptInput> | CommentCreateWithoutScriptInput[] | CommentUncheckedCreateWithoutScriptInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutScriptInput | CommentCreateOrConnectWithoutScriptInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutScriptInput | CommentUpsertWithWhereUniqueWithoutScriptInput[]
    createMany?: CommentCreateManyScriptInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutScriptInput | CommentUpdateWithWhereUniqueWithoutScriptInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutScriptInput | CommentUpdateManyWithWhereWithoutScriptInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type VideoUncheckedUpdateManyWithoutScriptNestedInput = {
    create?: XOR<VideoCreateWithoutScriptInput, VideoUncheckedCreateWithoutScriptInput> | VideoCreateWithoutScriptInput[] | VideoUncheckedCreateWithoutScriptInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutScriptInput | VideoCreateOrConnectWithoutScriptInput[]
    upsert?: VideoUpsertWithWhereUniqueWithoutScriptInput | VideoUpsertWithWhereUniqueWithoutScriptInput[]
    createMany?: VideoCreateManyScriptInputEnvelope
    set?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    disconnect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    delete?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    update?: VideoUpdateWithWhereUniqueWithoutScriptInput | VideoUpdateWithWhereUniqueWithoutScriptInput[]
    updateMany?: VideoUpdateManyWithWhereWithoutScriptInput | VideoUpdateManyWithWhereWithoutScriptInput[]
    deleteMany?: VideoScalarWhereInput | VideoScalarWhereInput[]
  }

  export type ScriptCreateNestedOneWithoutReviewsInput = {
    create?: XOR<ScriptCreateWithoutReviewsInput, ScriptUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ScriptCreateOrConnectWithoutReviewsInput
    connect?: ScriptWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutScriptReviewsInput = {
    create?: XOR<UserCreateWithoutScriptReviewsInput, UserUncheckedCreateWithoutScriptReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutScriptReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumReviewDecisionFieldUpdateOperationsInput = {
    set?: $Enums.ReviewDecision
  }

  export type ScriptUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<ScriptCreateWithoutReviewsInput, ScriptUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ScriptCreateOrConnectWithoutReviewsInput
    upsert?: ScriptUpsertWithoutReviewsInput
    connect?: ScriptWhereUniqueInput
    update?: XOR<XOR<ScriptUpdateToOneWithWhereWithoutReviewsInput, ScriptUpdateWithoutReviewsInput>, ScriptUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateOneRequiredWithoutScriptReviewsNestedInput = {
    create?: XOR<UserCreateWithoutScriptReviewsInput, UserUncheckedCreateWithoutScriptReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutScriptReviewsInput
    upsert?: UserUpsertWithoutScriptReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutScriptReviewsInput, UserUpdateWithoutScriptReviewsInput>, UserUncheckedUpdateWithoutScriptReviewsInput>
  }

  export type VideoCreatetagsInput = {
    set: string[]
  }

  export type VideoCreatekeyTakeawaysInput = {
    set: string[]
  }

  export type VideoCreaterelatedVideoIdsInput = {
    set: string[]
  }

  export type TopicCreateNestedOneWithoutVideosInput = {
    create?: XOR<TopicCreateWithoutVideosInput, TopicUncheckedCreateWithoutVideosInput>
    connectOrCreate?: TopicCreateOrConnectWithoutVideosInput
    connect?: TopicWhereUniqueInput
  }

  export type ScriptCreateNestedOneWithoutVideosInput = {
    create?: XOR<ScriptCreateWithoutVideosInput, ScriptUncheckedCreateWithoutVideosInput>
    connectOrCreate?: ScriptCreateOrConnectWithoutVideosInput
    connect?: ScriptWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUploadedVideosInput = {
    create?: XOR<UserCreateWithoutUploadedVideosInput, UserUncheckedCreateWithoutUploadedVideosInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedVideosInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLockedVideosInput = {
    create?: XOR<UserCreateWithoutLockedVideosInput, UserUncheckedCreateWithoutLockedVideosInput>
    connectOrCreate?: UserCreateOrConnectWithoutLockedVideosInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPublishedVideosInput = {
    create?: XOR<UserCreateWithoutPublishedVideosInput, UserUncheckedCreateWithoutPublishedVideosInput>
    connectOrCreate?: UserCreateOrConnectWithoutPublishedVideosInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedVideosInput = {
    create?: XOR<UserCreateWithoutAssignedVideosInput, UserUncheckedCreateWithoutAssignedVideosInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedVideosInput
    connect?: UserWhereUniqueInput
  }

  export type VideoReviewCreateNestedManyWithoutVideoInput = {
    create?: XOR<VideoReviewCreateWithoutVideoInput, VideoReviewUncheckedCreateWithoutVideoInput> | VideoReviewCreateWithoutVideoInput[] | VideoReviewUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: VideoReviewCreateOrConnectWithoutVideoInput | VideoReviewCreateOrConnectWithoutVideoInput[]
    createMany?: VideoReviewCreateManyVideoInputEnvelope
    connect?: VideoReviewWhereUniqueInput | VideoReviewWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutVideoInput = {
    create?: XOR<CommentCreateWithoutVideoInput, CommentUncheckedCreateWithoutVideoInput> | CommentCreateWithoutVideoInput[] | CommentUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutVideoInput | CommentCreateOrConnectWithoutVideoInput[]
    createMany?: CommentCreateManyVideoInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type VideoAnalyticsCreateNestedOneWithoutVideoInput = {
    create?: XOR<VideoAnalyticsCreateWithoutVideoInput, VideoAnalyticsUncheckedCreateWithoutVideoInput>
    connectOrCreate?: VideoAnalyticsCreateOrConnectWithoutVideoInput
    connect?: VideoAnalyticsWhereUniqueInput
  }

  export type VideoReviewUncheckedCreateNestedManyWithoutVideoInput = {
    create?: XOR<VideoReviewCreateWithoutVideoInput, VideoReviewUncheckedCreateWithoutVideoInput> | VideoReviewCreateWithoutVideoInput[] | VideoReviewUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: VideoReviewCreateOrConnectWithoutVideoInput | VideoReviewCreateOrConnectWithoutVideoInput[]
    createMany?: VideoReviewCreateManyVideoInputEnvelope
    connect?: VideoReviewWhereUniqueInput | VideoReviewWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutVideoInput = {
    create?: XOR<CommentCreateWithoutVideoInput, CommentUncheckedCreateWithoutVideoInput> | CommentCreateWithoutVideoInput[] | CommentUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutVideoInput | CommentCreateOrConnectWithoutVideoInput[]
    createMany?: CommentCreateManyVideoInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type VideoAnalyticsUncheckedCreateNestedOneWithoutVideoInput = {
    create?: XOR<VideoAnalyticsCreateWithoutVideoInput, VideoAnalyticsUncheckedCreateWithoutVideoInput>
    connectOrCreate?: VideoAnalyticsCreateOrConnectWithoutVideoInput
    connect?: VideoAnalyticsWhereUniqueInput
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type EnumCTATypeFieldUpdateOperationsInput = {
    set?: $Enums.CTAType
  }

  export type VideoUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type VideoUpdatekeyTakeawaysInput = {
    set?: string[]
    push?: string | string[]
  }

  export type VideoUpdaterelatedVideoIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumVideoStatusFieldUpdateOperationsInput = {
    set?: $Enums.VideoStatus
  }

  export type TopicUpdateOneRequiredWithoutVideosNestedInput = {
    create?: XOR<TopicCreateWithoutVideosInput, TopicUncheckedCreateWithoutVideosInput>
    connectOrCreate?: TopicCreateOrConnectWithoutVideosInput
    upsert?: TopicUpsertWithoutVideosInput
    connect?: TopicWhereUniqueInput
    update?: XOR<XOR<TopicUpdateToOneWithWhereWithoutVideosInput, TopicUpdateWithoutVideosInput>, TopicUncheckedUpdateWithoutVideosInput>
  }

  export type ScriptUpdateOneWithoutVideosNestedInput = {
    create?: XOR<ScriptCreateWithoutVideosInput, ScriptUncheckedCreateWithoutVideosInput>
    connectOrCreate?: ScriptCreateOrConnectWithoutVideosInput
    upsert?: ScriptUpsertWithoutVideosInput
    disconnect?: ScriptWhereInput | boolean
    delete?: ScriptWhereInput | boolean
    connect?: ScriptWhereUniqueInput
    update?: XOR<XOR<ScriptUpdateToOneWithWhereWithoutVideosInput, ScriptUpdateWithoutVideosInput>, ScriptUncheckedUpdateWithoutVideosInput>
  }

  export type UserUpdateOneWithoutUploadedVideosNestedInput = {
    create?: XOR<UserCreateWithoutUploadedVideosInput, UserUncheckedCreateWithoutUploadedVideosInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedVideosInput
    upsert?: UserUpsertWithoutUploadedVideosInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedVideosInput, UserUpdateWithoutUploadedVideosInput>, UserUncheckedUpdateWithoutUploadedVideosInput>
  }

  export type UserUpdateOneWithoutLockedVideosNestedInput = {
    create?: XOR<UserCreateWithoutLockedVideosInput, UserUncheckedCreateWithoutLockedVideosInput>
    connectOrCreate?: UserCreateOrConnectWithoutLockedVideosInput
    upsert?: UserUpsertWithoutLockedVideosInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLockedVideosInput, UserUpdateWithoutLockedVideosInput>, UserUncheckedUpdateWithoutLockedVideosInput>
  }

  export type UserUpdateOneWithoutPublishedVideosNestedInput = {
    create?: XOR<UserCreateWithoutPublishedVideosInput, UserUncheckedCreateWithoutPublishedVideosInput>
    connectOrCreate?: UserCreateOrConnectWithoutPublishedVideosInput
    upsert?: UserUpsertWithoutPublishedVideosInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPublishedVideosInput, UserUpdateWithoutPublishedVideosInput>, UserUncheckedUpdateWithoutPublishedVideosInput>
  }

  export type UserUpdateOneWithoutAssignedVideosNestedInput = {
    create?: XOR<UserCreateWithoutAssignedVideosInput, UserUncheckedCreateWithoutAssignedVideosInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedVideosInput
    upsert?: UserUpsertWithoutAssignedVideosInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedVideosInput, UserUpdateWithoutAssignedVideosInput>, UserUncheckedUpdateWithoutAssignedVideosInput>
  }

  export type VideoReviewUpdateManyWithoutVideoNestedInput = {
    create?: XOR<VideoReviewCreateWithoutVideoInput, VideoReviewUncheckedCreateWithoutVideoInput> | VideoReviewCreateWithoutVideoInput[] | VideoReviewUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: VideoReviewCreateOrConnectWithoutVideoInput | VideoReviewCreateOrConnectWithoutVideoInput[]
    upsert?: VideoReviewUpsertWithWhereUniqueWithoutVideoInput | VideoReviewUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: VideoReviewCreateManyVideoInputEnvelope
    set?: VideoReviewWhereUniqueInput | VideoReviewWhereUniqueInput[]
    disconnect?: VideoReviewWhereUniqueInput | VideoReviewWhereUniqueInput[]
    delete?: VideoReviewWhereUniqueInput | VideoReviewWhereUniqueInput[]
    connect?: VideoReviewWhereUniqueInput | VideoReviewWhereUniqueInput[]
    update?: VideoReviewUpdateWithWhereUniqueWithoutVideoInput | VideoReviewUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: VideoReviewUpdateManyWithWhereWithoutVideoInput | VideoReviewUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: VideoReviewScalarWhereInput | VideoReviewScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutVideoNestedInput = {
    create?: XOR<CommentCreateWithoutVideoInput, CommentUncheckedCreateWithoutVideoInput> | CommentCreateWithoutVideoInput[] | CommentUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutVideoInput | CommentCreateOrConnectWithoutVideoInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutVideoInput | CommentUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: CommentCreateManyVideoInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutVideoInput | CommentUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutVideoInput | CommentUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type VideoAnalyticsUpdateOneWithoutVideoNestedInput = {
    create?: XOR<VideoAnalyticsCreateWithoutVideoInput, VideoAnalyticsUncheckedCreateWithoutVideoInput>
    connectOrCreate?: VideoAnalyticsCreateOrConnectWithoutVideoInput
    upsert?: VideoAnalyticsUpsertWithoutVideoInput
    disconnect?: VideoAnalyticsWhereInput | boolean
    delete?: VideoAnalyticsWhereInput | boolean
    connect?: VideoAnalyticsWhereUniqueInput
    update?: XOR<XOR<VideoAnalyticsUpdateToOneWithWhereWithoutVideoInput, VideoAnalyticsUpdateWithoutVideoInput>, VideoAnalyticsUncheckedUpdateWithoutVideoInput>
  }

  export type VideoReviewUncheckedUpdateManyWithoutVideoNestedInput = {
    create?: XOR<VideoReviewCreateWithoutVideoInput, VideoReviewUncheckedCreateWithoutVideoInput> | VideoReviewCreateWithoutVideoInput[] | VideoReviewUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: VideoReviewCreateOrConnectWithoutVideoInput | VideoReviewCreateOrConnectWithoutVideoInput[]
    upsert?: VideoReviewUpsertWithWhereUniqueWithoutVideoInput | VideoReviewUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: VideoReviewCreateManyVideoInputEnvelope
    set?: VideoReviewWhereUniqueInput | VideoReviewWhereUniqueInput[]
    disconnect?: VideoReviewWhereUniqueInput | VideoReviewWhereUniqueInput[]
    delete?: VideoReviewWhereUniqueInput | VideoReviewWhereUniqueInput[]
    connect?: VideoReviewWhereUniqueInput | VideoReviewWhereUniqueInput[]
    update?: VideoReviewUpdateWithWhereUniqueWithoutVideoInput | VideoReviewUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: VideoReviewUpdateManyWithWhereWithoutVideoInput | VideoReviewUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: VideoReviewScalarWhereInput | VideoReviewScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutVideoNestedInput = {
    create?: XOR<CommentCreateWithoutVideoInput, CommentUncheckedCreateWithoutVideoInput> | CommentCreateWithoutVideoInput[] | CommentUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutVideoInput | CommentCreateOrConnectWithoutVideoInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutVideoInput | CommentUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: CommentCreateManyVideoInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutVideoInput | CommentUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutVideoInput | CommentUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type VideoAnalyticsUncheckedUpdateOneWithoutVideoNestedInput = {
    create?: XOR<VideoAnalyticsCreateWithoutVideoInput, VideoAnalyticsUncheckedCreateWithoutVideoInput>
    connectOrCreate?: VideoAnalyticsCreateOrConnectWithoutVideoInput
    upsert?: VideoAnalyticsUpsertWithoutVideoInput
    disconnect?: VideoAnalyticsWhereInput | boolean
    delete?: VideoAnalyticsWhereInput | boolean
    connect?: VideoAnalyticsWhereUniqueInput
    update?: XOR<XOR<VideoAnalyticsUpdateToOneWithWhereWithoutVideoInput, VideoAnalyticsUpdateWithoutVideoInput>, VideoAnalyticsUncheckedUpdateWithoutVideoInput>
  }

  export type VideoCreateNestedOneWithoutReviewsInput = {
    create?: XOR<VideoCreateWithoutReviewsInput, VideoUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutReviewsInput
    connect?: VideoWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVideoReviewsInput = {
    create?: XOR<UserCreateWithoutVideoReviewsInput, UserUncheckedCreateWithoutVideoReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVideoReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type VideoUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<VideoCreateWithoutReviewsInput, VideoUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutReviewsInput
    upsert?: VideoUpsertWithoutReviewsInput
    connect?: VideoWhereUniqueInput
    update?: XOR<XOR<VideoUpdateToOneWithWhereWithoutReviewsInput, VideoUpdateWithoutReviewsInput>, VideoUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateOneRequiredWithoutVideoReviewsNestedInput = {
    create?: XOR<UserCreateWithoutVideoReviewsInput, UserUncheckedCreateWithoutVideoReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVideoReviewsInput
    upsert?: UserUpsertWithoutVideoReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVideoReviewsInput, UserUpdateWithoutVideoReviewsInput>, UserUncheckedUpdateWithoutVideoReviewsInput>
  }

  export type ScriptCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ScriptCreateWithoutCommentsInput, ScriptUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ScriptCreateOrConnectWithoutCommentsInput
    connect?: ScriptWhereUniqueInput
  }

  export type VideoCreateNestedOneWithoutCommentsInput = {
    create?: XOR<VideoCreateWithoutCommentsInput, VideoUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutCommentsInput
    connect?: VideoWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type ScriptUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<ScriptCreateWithoutCommentsInput, ScriptUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ScriptCreateOrConnectWithoutCommentsInput
    upsert?: ScriptUpsertWithoutCommentsInput
    disconnect?: ScriptWhereInput | boolean
    delete?: ScriptWhereInput | boolean
    connect?: ScriptWhereUniqueInput
    update?: XOR<XOR<ScriptUpdateToOneWithWhereWithoutCommentsInput, ScriptUpdateWithoutCommentsInput>, ScriptUncheckedUpdateWithoutCommentsInput>
  }

  export type VideoUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<VideoCreateWithoutCommentsInput, VideoUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutCommentsInput
    upsert?: VideoUpsertWithoutCommentsInput
    disconnect?: VideoWhereInput | boolean
    delete?: VideoWhereInput | boolean
    connect?: VideoWhereUniqueInput
    update?: XOR<XOR<VideoUpdateToOneWithWhereWithoutCommentsInput, VideoUpdateWithoutCommentsInput>, VideoUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type VideoCreateNestedOneWithoutAnalyticsInput = {
    create?: XOR<VideoCreateWithoutAnalyticsInput, VideoUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutAnalyticsInput
    connect?: VideoWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type VideoUpdateOneRequiredWithoutAnalyticsNestedInput = {
    create?: XOR<VideoCreateWithoutAnalyticsInput, VideoUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutAnalyticsInput
    upsert?: VideoUpsertWithoutAnalyticsInput
    connect?: VideoWhereUniqueInput
    update?: XOR<XOR<VideoUpdateToOneWithWhereWithoutAnalyticsInput, VideoUpdateWithoutAnalyticsInput>, VideoUncheckedUpdateWithoutAnalyticsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumTopicStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TopicStatus | EnumTopicStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TopicStatus[] | ListEnumTopicStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TopicStatus[] | ListEnumTopicStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTopicStatusFilter<$PrismaModel> | $Enums.TopicStatus
  }

  export type NestedEnumTopicStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TopicStatus | EnumTopicStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TopicStatus[] | ListEnumTopicStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TopicStatus[] | ListEnumTopicStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTopicStatusWithAggregatesFilter<$PrismaModel> | $Enums.TopicStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTopicStatusFilter<$PrismaModel>
    _max?: NestedEnumTopicStatusFilter<$PrismaModel>
  }

  export type NestedEnumScriptStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ScriptStatus | EnumScriptStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScriptStatus[] | ListEnumScriptStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScriptStatus[] | ListEnumScriptStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScriptStatusFilter<$PrismaModel> | $Enums.ScriptStatus
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumScriptStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScriptStatus | EnumScriptStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScriptStatus[] | ListEnumScriptStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScriptStatus[] | ListEnumScriptStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScriptStatusWithAggregatesFilter<$PrismaModel> | $Enums.ScriptStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScriptStatusFilter<$PrismaModel>
    _max?: NestedEnumScriptStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumReviewDecisionFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewDecision | EnumReviewDecisionFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewDecision[] | ListEnumReviewDecisionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewDecision[] | ListEnumReviewDecisionFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewDecisionFilter<$PrismaModel> | $Enums.ReviewDecision
  }

  export type NestedEnumReviewDecisionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewDecision | EnumReviewDecisionFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewDecision[] | ListEnumReviewDecisionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewDecision[] | ListEnumReviewDecisionFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewDecisionWithAggregatesFilter<$PrismaModel> | $Enums.ReviewDecision
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewDecisionFilter<$PrismaModel>
    _max?: NestedEnumReviewDecisionFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedEnumCTATypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CTAType | EnumCTATypeFieldRefInput<$PrismaModel>
    in?: $Enums.CTAType[] | ListEnumCTATypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CTAType[] | ListEnumCTATypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCTATypeFilter<$PrismaModel> | $Enums.CTAType
  }

  export type NestedEnumVideoStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoStatus | EnumVideoStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VideoStatus[] | ListEnumVideoStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VideoStatus[] | ListEnumVideoStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVideoStatusFilter<$PrismaModel> | $Enums.VideoStatus
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumCTATypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CTAType | EnumCTATypeFieldRefInput<$PrismaModel>
    in?: $Enums.CTAType[] | ListEnumCTATypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CTAType[] | ListEnumCTATypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCTATypeWithAggregatesFilter<$PrismaModel> | $Enums.CTAType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCTATypeFilter<$PrismaModel>
    _max?: NestedEnumCTATypeFilter<$PrismaModel>
  }

  export type NestedEnumVideoStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoStatus | EnumVideoStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VideoStatus[] | ListEnumVideoStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VideoStatus[] | ListEnumVideoStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVideoStatusWithAggregatesFilter<$PrismaModel> | $Enums.VideoStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVideoStatusFilter<$PrismaModel>
    _max?: NestedEnumVideoStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type TopicCreateWithoutAssignedDoctorInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TopicStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedTopicsInput
    doctorPointers?: DoctorPointerCreateNestedManyWithoutTopicInput
    scripts?: ScriptCreateNestedManyWithoutTopicInput
    videos?: VideoCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateWithoutAssignedDoctorInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TopicStatus
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorPointers?: DoctorPointerUncheckedCreateNestedManyWithoutTopicInput
    scripts?: ScriptUncheckedCreateNestedManyWithoutTopicInput
    videos?: VideoUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicCreateOrConnectWithoutAssignedDoctorInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutAssignedDoctorInput, TopicUncheckedCreateWithoutAssignedDoctorInput>
  }

  export type TopicCreateManyAssignedDoctorInputEnvelope = {
    data: TopicCreateManyAssignedDoctorInput | TopicCreateManyAssignedDoctorInput[]
    skipDuplicates?: boolean
  }

  export type TopicCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TopicStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedDoctor: UserCreateNestedOneWithoutAssignedTopicsInput
    doctorPointers?: DoctorPointerCreateNestedManyWithoutTopicInput
    scripts?: ScriptCreateNestedManyWithoutTopicInput
    videos?: VideoCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TopicStatus
    assignedDoctorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorPointers?: DoctorPointerUncheckedCreateNestedManyWithoutTopicInput
    scripts?: ScriptUncheckedCreateNestedManyWithoutTopicInput
    videos?: VideoUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicCreateOrConnectWithoutCreatedByInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutCreatedByInput, TopicUncheckedCreateWithoutCreatedByInput>
  }

  export type TopicCreateManyCreatedByInputEnvelope = {
    data: TopicCreateManyCreatedByInput | TopicCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type DoctorPointerCreateWithoutDoctorInput = {
    id?: string
    notes?: string | null
    fileUrl?: string | null
    fileType?: string | null
    createdAt?: Date | string
    topic: TopicCreateNestedOneWithoutDoctorPointersInput
  }

  export type DoctorPointerUncheckedCreateWithoutDoctorInput = {
    id?: string
    topicId: string
    notes?: string | null
    fileUrl?: string | null
    fileType?: string | null
    createdAt?: Date | string
  }

  export type DoctorPointerCreateOrConnectWithoutDoctorInput = {
    where: DoctorPointerWhereUniqueInput
    create: XOR<DoctorPointerCreateWithoutDoctorInput, DoctorPointerUncheckedCreateWithoutDoctorInput>
  }

  export type DoctorPointerCreateManyDoctorInputEnvelope = {
    data: DoctorPointerCreateManyDoctorInput | DoctorPointerCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type ScriptCreateWithoutUploadedByInput = {
    id?: string
    version?: number
    content: string
    status?: $Enums.ScriptStatus
    summary?: string | null
    tags?: ScriptCreatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    lockedAt?: Date | string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    topic: TopicCreateNestedOneWithoutScriptsInput
    lockedBy?: UserCreateNestedOneWithoutLockedScriptsInput
    assignedReviewer?: UserCreateNestedOneWithoutAssignedScriptsInput
    reviews?: ScriptReviewCreateNestedManyWithoutScriptInput
    comments?: CommentCreateNestedManyWithoutScriptInput
    videos?: VideoCreateNestedManyWithoutScriptInput
  }

  export type ScriptUncheckedCreateWithoutUploadedByInput = {
    id?: string
    topicId: string
    version?: number
    content: string
    status?: $Enums.ScriptStatus
    summary?: string | null
    tags?: ScriptCreatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    assignedReviewerId?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ScriptReviewUncheckedCreateNestedManyWithoutScriptInput
    comments?: CommentUncheckedCreateNestedManyWithoutScriptInput
    videos?: VideoUncheckedCreateNestedManyWithoutScriptInput
  }

  export type ScriptCreateOrConnectWithoutUploadedByInput = {
    where: ScriptWhereUniqueInput
    create: XOR<ScriptCreateWithoutUploadedByInput, ScriptUncheckedCreateWithoutUploadedByInput>
  }

  export type ScriptCreateManyUploadedByInputEnvelope = {
    data: ScriptCreateManyUploadedByInput | ScriptCreateManyUploadedByInput[]
    skipDuplicates?: boolean
  }

  export type ScriptCreateWithoutLockedByInput = {
    id?: string
    version?: number
    content: string
    status?: $Enums.ScriptStatus
    summary?: string | null
    tags?: ScriptCreatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    lockedAt?: Date | string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    topic: TopicCreateNestedOneWithoutScriptsInput
    uploadedBy?: UserCreateNestedOneWithoutUploadedScriptsInput
    assignedReviewer?: UserCreateNestedOneWithoutAssignedScriptsInput
    reviews?: ScriptReviewCreateNestedManyWithoutScriptInput
    comments?: CommentCreateNestedManyWithoutScriptInput
    videos?: VideoCreateNestedManyWithoutScriptInput
  }

  export type ScriptUncheckedCreateWithoutLockedByInput = {
    id?: string
    topicId: string
    version?: number
    content: string
    status?: $Enums.ScriptStatus
    summary?: string | null
    tags?: ScriptCreatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    uploadedById?: string | null
    lockedAt?: Date | string | null
    assignedReviewerId?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ScriptReviewUncheckedCreateNestedManyWithoutScriptInput
    comments?: CommentUncheckedCreateNestedManyWithoutScriptInput
    videos?: VideoUncheckedCreateNestedManyWithoutScriptInput
  }

  export type ScriptCreateOrConnectWithoutLockedByInput = {
    where: ScriptWhereUniqueInput
    create: XOR<ScriptCreateWithoutLockedByInput, ScriptUncheckedCreateWithoutLockedByInput>
  }

  export type ScriptCreateManyLockedByInputEnvelope = {
    data: ScriptCreateManyLockedByInput | ScriptCreateManyLockedByInput[]
    skipDuplicates?: boolean
  }

  export type ScriptCreateWithoutAssignedReviewerInput = {
    id?: string
    version?: number
    content: string
    status?: $Enums.ScriptStatus
    summary?: string | null
    tags?: ScriptCreatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    lockedAt?: Date | string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    topic: TopicCreateNestedOneWithoutScriptsInput
    uploadedBy?: UserCreateNestedOneWithoutUploadedScriptsInput
    lockedBy?: UserCreateNestedOneWithoutLockedScriptsInput
    reviews?: ScriptReviewCreateNestedManyWithoutScriptInput
    comments?: CommentCreateNestedManyWithoutScriptInput
    videos?: VideoCreateNestedManyWithoutScriptInput
  }

  export type ScriptUncheckedCreateWithoutAssignedReviewerInput = {
    id?: string
    topicId: string
    version?: number
    content: string
    status?: $Enums.ScriptStatus
    summary?: string | null
    tags?: ScriptCreatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    uploadedById?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ScriptReviewUncheckedCreateNestedManyWithoutScriptInput
    comments?: CommentUncheckedCreateNestedManyWithoutScriptInput
    videos?: VideoUncheckedCreateNestedManyWithoutScriptInput
  }

  export type ScriptCreateOrConnectWithoutAssignedReviewerInput = {
    where: ScriptWhereUniqueInput
    create: XOR<ScriptCreateWithoutAssignedReviewerInput, ScriptUncheckedCreateWithoutAssignedReviewerInput>
  }

  export type ScriptCreateManyAssignedReviewerInputEnvelope = {
    data: ScriptCreateManyAssignedReviewerInput | ScriptCreateManyAssignedReviewerInput[]
    skipDuplicates?: boolean
  }

  export type ScriptReviewCreateWithoutReviewerInput = {
    id?: string
    reviewerType: $Enums.UserRole
    decision?: $Enums.ReviewDecision
    comments?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    script: ScriptCreateNestedOneWithoutReviewsInput
  }

  export type ScriptReviewUncheckedCreateWithoutReviewerInput = {
    id?: string
    scriptId: string
    reviewerType: $Enums.UserRole
    decision?: $Enums.ReviewDecision
    comments?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ScriptReviewCreateOrConnectWithoutReviewerInput = {
    where: ScriptReviewWhereUniqueInput
    create: XOR<ScriptReviewCreateWithoutReviewerInput, ScriptReviewUncheckedCreateWithoutReviewerInput>
  }

  export type ScriptReviewCreateManyReviewerInputEnvelope = {
    data: ScriptReviewCreateManyReviewerInput | ScriptReviewCreateManyReviewerInput[]
    skipDuplicates?: boolean
  }

  export type VideoCreateWithoutUploadedByInput = {
    id?: string
    title: string
    description?: string | null
    videoUrl: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: bigint | number | null
    doctorName: string
    specialty: string
    language: string
    city: string
    ctaType: $Enums.CTAType
    tags?: VideoCreatetagsInput | string[]
    transcript?: string | null
    transcriptUrl?: string | null
    summary?: string | null
    shortSummary?: string | null
    keyTakeaways?: VideoCreatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    relatedVideoIds?: VideoCreaterelatedVideoIdsInput | string[]
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    status?: $Enums.VideoStatus
    version?: number
    lockedAt?: Date | string | null
    publishedAt?: Date | string | null
    assignedAt?: Date | string | null
    deepLink?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    topic: TopicCreateNestedOneWithoutVideosInput
    script?: ScriptCreateNestedOneWithoutVideosInput
    lockedBy?: UserCreateNestedOneWithoutLockedVideosInput
    publishedBy?: UserCreateNestedOneWithoutPublishedVideosInput
    assignedReviewer?: UserCreateNestedOneWithoutAssignedVideosInput
    reviews?: VideoReviewCreateNestedManyWithoutVideoInput
    comments?: CommentCreateNestedManyWithoutVideoInput
    analytics?: VideoAnalyticsCreateNestedOneWithoutVideoInput
  }

  export type VideoUncheckedCreateWithoutUploadedByInput = {
    id?: string
    topicId: string
    scriptId?: string | null
    title: string
    description?: string | null
    videoUrl: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: bigint | number | null
    doctorName: string
    specialty: string
    language: string
    city: string
    ctaType: $Enums.CTAType
    tags?: VideoCreatetagsInput | string[]
    transcript?: string | null
    transcriptUrl?: string | null
    summary?: string | null
    shortSummary?: string | null
    keyTakeaways?: VideoCreatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    relatedVideoIds?: VideoCreaterelatedVideoIdsInput | string[]
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    status?: $Enums.VideoStatus
    version?: number
    lockedById?: string | null
    lockedAt?: Date | string | null
    publishedById?: string | null
    publishedAt?: Date | string | null
    assignedReviewerId?: string | null
    assignedAt?: Date | string | null
    deepLink?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: VideoReviewUncheckedCreateNestedManyWithoutVideoInput
    comments?: CommentUncheckedCreateNestedManyWithoutVideoInput
    analytics?: VideoAnalyticsUncheckedCreateNestedOneWithoutVideoInput
  }

  export type VideoCreateOrConnectWithoutUploadedByInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutUploadedByInput, VideoUncheckedCreateWithoutUploadedByInput>
  }

  export type VideoCreateManyUploadedByInputEnvelope = {
    data: VideoCreateManyUploadedByInput | VideoCreateManyUploadedByInput[]
    skipDuplicates?: boolean
  }

  export type VideoCreateWithoutLockedByInput = {
    id?: string
    title: string
    description?: string | null
    videoUrl: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: bigint | number | null
    doctorName: string
    specialty: string
    language: string
    city: string
    ctaType: $Enums.CTAType
    tags?: VideoCreatetagsInput | string[]
    transcript?: string | null
    transcriptUrl?: string | null
    summary?: string | null
    shortSummary?: string | null
    keyTakeaways?: VideoCreatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    relatedVideoIds?: VideoCreaterelatedVideoIdsInput | string[]
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    status?: $Enums.VideoStatus
    version?: number
    lockedAt?: Date | string | null
    publishedAt?: Date | string | null
    assignedAt?: Date | string | null
    deepLink?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    topic: TopicCreateNestedOneWithoutVideosInput
    script?: ScriptCreateNestedOneWithoutVideosInput
    uploadedBy?: UserCreateNestedOneWithoutUploadedVideosInput
    publishedBy?: UserCreateNestedOneWithoutPublishedVideosInput
    assignedReviewer?: UserCreateNestedOneWithoutAssignedVideosInput
    reviews?: VideoReviewCreateNestedManyWithoutVideoInput
    comments?: CommentCreateNestedManyWithoutVideoInput
    analytics?: VideoAnalyticsCreateNestedOneWithoutVideoInput
  }

  export type VideoUncheckedCreateWithoutLockedByInput = {
    id?: string
    topicId: string
    scriptId?: string | null
    title: string
    description?: string | null
    videoUrl: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: bigint | number | null
    doctorName: string
    specialty: string
    language: string
    city: string
    ctaType: $Enums.CTAType
    tags?: VideoCreatetagsInput | string[]
    transcript?: string | null
    transcriptUrl?: string | null
    summary?: string | null
    shortSummary?: string | null
    keyTakeaways?: VideoCreatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    relatedVideoIds?: VideoCreaterelatedVideoIdsInput | string[]
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    status?: $Enums.VideoStatus
    version?: number
    uploadedById?: string | null
    lockedAt?: Date | string | null
    publishedById?: string | null
    publishedAt?: Date | string | null
    assignedReviewerId?: string | null
    assignedAt?: Date | string | null
    deepLink?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: VideoReviewUncheckedCreateNestedManyWithoutVideoInput
    comments?: CommentUncheckedCreateNestedManyWithoutVideoInput
    analytics?: VideoAnalyticsUncheckedCreateNestedOneWithoutVideoInput
  }

  export type VideoCreateOrConnectWithoutLockedByInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutLockedByInput, VideoUncheckedCreateWithoutLockedByInput>
  }

  export type VideoCreateManyLockedByInputEnvelope = {
    data: VideoCreateManyLockedByInput | VideoCreateManyLockedByInput[]
    skipDuplicates?: boolean
  }

  export type VideoCreateWithoutPublishedByInput = {
    id?: string
    title: string
    description?: string | null
    videoUrl: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: bigint | number | null
    doctorName: string
    specialty: string
    language: string
    city: string
    ctaType: $Enums.CTAType
    tags?: VideoCreatetagsInput | string[]
    transcript?: string | null
    transcriptUrl?: string | null
    summary?: string | null
    shortSummary?: string | null
    keyTakeaways?: VideoCreatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    relatedVideoIds?: VideoCreaterelatedVideoIdsInput | string[]
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    status?: $Enums.VideoStatus
    version?: number
    lockedAt?: Date | string | null
    publishedAt?: Date | string | null
    assignedAt?: Date | string | null
    deepLink?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    topic: TopicCreateNestedOneWithoutVideosInput
    script?: ScriptCreateNestedOneWithoutVideosInput
    uploadedBy?: UserCreateNestedOneWithoutUploadedVideosInput
    lockedBy?: UserCreateNestedOneWithoutLockedVideosInput
    assignedReviewer?: UserCreateNestedOneWithoutAssignedVideosInput
    reviews?: VideoReviewCreateNestedManyWithoutVideoInput
    comments?: CommentCreateNestedManyWithoutVideoInput
    analytics?: VideoAnalyticsCreateNestedOneWithoutVideoInput
  }

  export type VideoUncheckedCreateWithoutPublishedByInput = {
    id?: string
    topicId: string
    scriptId?: string | null
    title: string
    description?: string | null
    videoUrl: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: bigint | number | null
    doctorName: string
    specialty: string
    language: string
    city: string
    ctaType: $Enums.CTAType
    tags?: VideoCreatetagsInput | string[]
    transcript?: string | null
    transcriptUrl?: string | null
    summary?: string | null
    shortSummary?: string | null
    keyTakeaways?: VideoCreatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    relatedVideoIds?: VideoCreaterelatedVideoIdsInput | string[]
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    status?: $Enums.VideoStatus
    version?: number
    uploadedById?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    publishedAt?: Date | string | null
    assignedReviewerId?: string | null
    assignedAt?: Date | string | null
    deepLink?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: VideoReviewUncheckedCreateNestedManyWithoutVideoInput
    comments?: CommentUncheckedCreateNestedManyWithoutVideoInput
    analytics?: VideoAnalyticsUncheckedCreateNestedOneWithoutVideoInput
  }

  export type VideoCreateOrConnectWithoutPublishedByInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutPublishedByInput, VideoUncheckedCreateWithoutPublishedByInput>
  }

  export type VideoCreateManyPublishedByInputEnvelope = {
    data: VideoCreateManyPublishedByInput | VideoCreateManyPublishedByInput[]
    skipDuplicates?: boolean
  }

  export type VideoCreateWithoutAssignedReviewerInput = {
    id?: string
    title: string
    description?: string | null
    videoUrl: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: bigint | number | null
    doctorName: string
    specialty: string
    language: string
    city: string
    ctaType: $Enums.CTAType
    tags?: VideoCreatetagsInput | string[]
    transcript?: string | null
    transcriptUrl?: string | null
    summary?: string | null
    shortSummary?: string | null
    keyTakeaways?: VideoCreatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    relatedVideoIds?: VideoCreaterelatedVideoIdsInput | string[]
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    status?: $Enums.VideoStatus
    version?: number
    lockedAt?: Date | string | null
    publishedAt?: Date | string | null
    assignedAt?: Date | string | null
    deepLink?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    topic: TopicCreateNestedOneWithoutVideosInput
    script?: ScriptCreateNestedOneWithoutVideosInput
    uploadedBy?: UserCreateNestedOneWithoutUploadedVideosInput
    lockedBy?: UserCreateNestedOneWithoutLockedVideosInput
    publishedBy?: UserCreateNestedOneWithoutPublishedVideosInput
    reviews?: VideoReviewCreateNestedManyWithoutVideoInput
    comments?: CommentCreateNestedManyWithoutVideoInput
    analytics?: VideoAnalyticsCreateNestedOneWithoutVideoInput
  }

  export type VideoUncheckedCreateWithoutAssignedReviewerInput = {
    id?: string
    topicId: string
    scriptId?: string | null
    title: string
    description?: string | null
    videoUrl: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: bigint | number | null
    doctorName: string
    specialty: string
    language: string
    city: string
    ctaType: $Enums.CTAType
    tags?: VideoCreatetagsInput | string[]
    transcript?: string | null
    transcriptUrl?: string | null
    summary?: string | null
    shortSummary?: string | null
    keyTakeaways?: VideoCreatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    relatedVideoIds?: VideoCreaterelatedVideoIdsInput | string[]
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    status?: $Enums.VideoStatus
    version?: number
    uploadedById?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    publishedById?: string | null
    publishedAt?: Date | string | null
    assignedAt?: Date | string | null
    deepLink?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: VideoReviewUncheckedCreateNestedManyWithoutVideoInput
    comments?: CommentUncheckedCreateNestedManyWithoutVideoInput
    analytics?: VideoAnalyticsUncheckedCreateNestedOneWithoutVideoInput
  }

  export type VideoCreateOrConnectWithoutAssignedReviewerInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutAssignedReviewerInput, VideoUncheckedCreateWithoutAssignedReviewerInput>
  }

  export type VideoCreateManyAssignedReviewerInputEnvelope = {
    data: VideoCreateManyAssignedReviewerInput | VideoCreateManyAssignedReviewerInput[]
    skipDuplicates?: boolean
  }

  export type VideoReviewCreateWithoutReviewerInput = {
    id?: string
    reviewerType: $Enums.UserRole
    decision?: $Enums.ReviewDecision
    comments?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    video: VideoCreateNestedOneWithoutReviewsInput
  }

  export type VideoReviewUncheckedCreateWithoutReviewerInput = {
    id?: string
    videoId: string
    reviewerType: $Enums.UserRole
    decision?: $Enums.ReviewDecision
    comments?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type VideoReviewCreateOrConnectWithoutReviewerInput = {
    where: VideoReviewWhereUniqueInput
    create: XOR<VideoReviewCreateWithoutReviewerInput, VideoReviewUncheckedCreateWithoutReviewerInput>
  }

  export type VideoReviewCreateManyReviewerInputEnvelope = {
    data: VideoReviewCreateManyReviewerInput | VideoReviewCreateManyReviewerInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutAuthorInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    script?: ScriptCreateNestedOneWithoutCommentsInput
    video?: VideoCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutAuthorInput = {
    id?: string
    scriptId?: string | null
    videoId?: string | null
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentCreateManyAuthorInputEnvelope = {
    data: CommentCreateManyAuthorInput | CommentCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type?: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type?: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TopicUpsertWithWhereUniqueWithoutAssignedDoctorInput = {
    where: TopicWhereUniqueInput
    update: XOR<TopicUpdateWithoutAssignedDoctorInput, TopicUncheckedUpdateWithoutAssignedDoctorInput>
    create: XOR<TopicCreateWithoutAssignedDoctorInput, TopicUncheckedCreateWithoutAssignedDoctorInput>
  }

  export type TopicUpdateWithWhereUniqueWithoutAssignedDoctorInput = {
    where: TopicWhereUniqueInput
    data: XOR<TopicUpdateWithoutAssignedDoctorInput, TopicUncheckedUpdateWithoutAssignedDoctorInput>
  }

  export type TopicUpdateManyWithWhereWithoutAssignedDoctorInput = {
    where: TopicScalarWhereInput
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyWithoutAssignedDoctorInput>
  }

  export type TopicScalarWhereInput = {
    AND?: TopicScalarWhereInput | TopicScalarWhereInput[]
    OR?: TopicScalarWhereInput[]
    NOT?: TopicScalarWhereInput | TopicScalarWhereInput[]
    id?: StringFilter<"Topic"> | string
    title?: StringFilter<"Topic"> | string
    description?: StringFilter<"Topic"> | string
    status?: EnumTopicStatusFilter<"Topic"> | $Enums.TopicStatus
    assignedDoctorId?: StringFilter<"Topic"> | string
    createdById?: StringFilter<"Topic"> | string
    createdAt?: DateTimeFilter<"Topic"> | Date | string
    updatedAt?: DateTimeFilter<"Topic"> | Date | string
  }

  export type TopicUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: TopicWhereUniqueInput
    update: XOR<TopicUpdateWithoutCreatedByInput, TopicUncheckedUpdateWithoutCreatedByInput>
    create: XOR<TopicCreateWithoutCreatedByInput, TopicUncheckedCreateWithoutCreatedByInput>
  }

  export type TopicUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: TopicWhereUniqueInput
    data: XOR<TopicUpdateWithoutCreatedByInput, TopicUncheckedUpdateWithoutCreatedByInput>
  }

  export type TopicUpdateManyWithWhereWithoutCreatedByInput = {
    where: TopicScalarWhereInput
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type DoctorPointerUpsertWithWhereUniqueWithoutDoctorInput = {
    where: DoctorPointerWhereUniqueInput
    update: XOR<DoctorPointerUpdateWithoutDoctorInput, DoctorPointerUncheckedUpdateWithoutDoctorInput>
    create: XOR<DoctorPointerCreateWithoutDoctorInput, DoctorPointerUncheckedCreateWithoutDoctorInput>
  }

  export type DoctorPointerUpdateWithWhereUniqueWithoutDoctorInput = {
    where: DoctorPointerWhereUniqueInput
    data: XOR<DoctorPointerUpdateWithoutDoctorInput, DoctorPointerUncheckedUpdateWithoutDoctorInput>
  }

  export type DoctorPointerUpdateManyWithWhereWithoutDoctorInput = {
    where: DoctorPointerScalarWhereInput
    data: XOR<DoctorPointerUpdateManyMutationInput, DoctorPointerUncheckedUpdateManyWithoutDoctorInput>
  }

  export type DoctorPointerScalarWhereInput = {
    AND?: DoctorPointerScalarWhereInput | DoctorPointerScalarWhereInput[]
    OR?: DoctorPointerScalarWhereInput[]
    NOT?: DoctorPointerScalarWhereInput | DoctorPointerScalarWhereInput[]
    id?: StringFilter<"DoctorPointer"> | string
    topicId?: StringFilter<"DoctorPointer"> | string
    doctorId?: StringFilter<"DoctorPointer"> | string
    notes?: StringNullableFilter<"DoctorPointer"> | string | null
    fileUrl?: StringNullableFilter<"DoctorPointer"> | string | null
    fileType?: StringNullableFilter<"DoctorPointer"> | string | null
    createdAt?: DateTimeFilter<"DoctorPointer"> | Date | string
  }

  export type ScriptUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: ScriptWhereUniqueInput
    update: XOR<ScriptUpdateWithoutUploadedByInput, ScriptUncheckedUpdateWithoutUploadedByInput>
    create: XOR<ScriptCreateWithoutUploadedByInput, ScriptUncheckedCreateWithoutUploadedByInput>
  }

  export type ScriptUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: ScriptWhereUniqueInput
    data: XOR<ScriptUpdateWithoutUploadedByInput, ScriptUncheckedUpdateWithoutUploadedByInput>
  }

  export type ScriptUpdateManyWithWhereWithoutUploadedByInput = {
    where: ScriptScalarWhereInput
    data: XOR<ScriptUpdateManyMutationInput, ScriptUncheckedUpdateManyWithoutUploadedByInput>
  }

  export type ScriptScalarWhereInput = {
    AND?: ScriptScalarWhereInput | ScriptScalarWhereInput[]
    OR?: ScriptScalarWhereInput[]
    NOT?: ScriptScalarWhereInput | ScriptScalarWhereInput[]
    id?: StringFilter<"Script"> | string
    topicId?: StringFilter<"Script"> | string
    version?: IntFilter<"Script"> | number
    content?: StringFilter<"Script"> | string
    status?: EnumScriptStatusFilter<"Script"> | $Enums.ScriptStatus
    summary?: StringNullableFilter<"Script"> | string | null
    tags?: StringNullableListFilter<"Script">
    entities?: JsonNullableFilter<"Script">
    qualityScore?: IntNullableFilter<"Script"> | number | null
    aiProcessedAt?: DateTimeNullableFilter<"Script"> | Date | string | null
    aiProcessingStatus?: StringNullableFilter<"Script"> | string | null
    uploadedById?: StringNullableFilter<"Script"> | string | null
    lockedById?: StringNullableFilter<"Script"> | string | null
    lockedAt?: DateTimeNullableFilter<"Script"> | Date | string | null
    assignedReviewerId?: StringNullableFilter<"Script"> | string | null
    assignedAt?: DateTimeNullableFilter<"Script"> | Date | string | null
    createdAt?: DateTimeFilter<"Script"> | Date | string
    updatedAt?: DateTimeFilter<"Script"> | Date | string
  }

  export type ScriptUpsertWithWhereUniqueWithoutLockedByInput = {
    where: ScriptWhereUniqueInput
    update: XOR<ScriptUpdateWithoutLockedByInput, ScriptUncheckedUpdateWithoutLockedByInput>
    create: XOR<ScriptCreateWithoutLockedByInput, ScriptUncheckedCreateWithoutLockedByInput>
  }

  export type ScriptUpdateWithWhereUniqueWithoutLockedByInput = {
    where: ScriptWhereUniqueInput
    data: XOR<ScriptUpdateWithoutLockedByInput, ScriptUncheckedUpdateWithoutLockedByInput>
  }

  export type ScriptUpdateManyWithWhereWithoutLockedByInput = {
    where: ScriptScalarWhereInput
    data: XOR<ScriptUpdateManyMutationInput, ScriptUncheckedUpdateManyWithoutLockedByInput>
  }

  export type ScriptUpsertWithWhereUniqueWithoutAssignedReviewerInput = {
    where: ScriptWhereUniqueInput
    update: XOR<ScriptUpdateWithoutAssignedReviewerInput, ScriptUncheckedUpdateWithoutAssignedReviewerInput>
    create: XOR<ScriptCreateWithoutAssignedReviewerInput, ScriptUncheckedCreateWithoutAssignedReviewerInput>
  }

  export type ScriptUpdateWithWhereUniqueWithoutAssignedReviewerInput = {
    where: ScriptWhereUniqueInput
    data: XOR<ScriptUpdateWithoutAssignedReviewerInput, ScriptUncheckedUpdateWithoutAssignedReviewerInput>
  }

  export type ScriptUpdateManyWithWhereWithoutAssignedReviewerInput = {
    where: ScriptScalarWhereInput
    data: XOR<ScriptUpdateManyMutationInput, ScriptUncheckedUpdateManyWithoutAssignedReviewerInput>
  }

  export type ScriptReviewUpsertWithWhereUniqueWithoutReviewerInput = {
    where: ScriptReviewWhereUniqueInput
    update: XOR<ScriptReviewUpdateWithoutReviewerInput, ScriptReviewUncheckedUpdateWithoutReviewerInput>
    create: XOR<ScriptReviewCreateWithoutReviewerInput, ScriptReviewUncheckedCreateWithoutReviewerInput>
  }

  export type ScriptReviewUpdateWithWhereUniqueWithoutReviewerInput = {
    where: ScriptReviewWhereUniqueInput
    data: XOR<ScriptReviewUpdateWithoutReviewerInput, ScriptReviewUncheckedUpdateWithoutReviewerInput>
  }

  export type ScriptReviewUpdateManyWithWhereWithoutReviewerInput = {
    where: ScriptReviewScalarWhereInput
    data: XOR<ScriptReviewUpdateManyMutationInput, ScriptReviewUncheckedUpdateManyWithoutReviewerInput>
  }

  export type ScriptReviewScalarWhereInput = {
    AND?: ScriptReviewScalarWhereInput | ScriptReviewScalarWhereInput[]
    OR?: ScriptReviewScalarWhereInput[]
    NOT?: ScriptReviewScalarWhereInput | ScriptReviewScalarWhereInput[]
    id?: StringFilter<"ScriptReview"> | string
    scriptId?: StringFilter<"ScriptReview"> | string
    reviewerId?: StringFilter<"ScriptReview"> | string
    reviewerType?: EnumUserRoleFilter<"ScriptReview"> | $Enums.UserRole
    decision?: EnumReviewDecisionFilter<"ScriptReview"> | $Enums.ReviewDecision
    comments?: StringNullableFilter<"ScriptReview"> | string | null
    reviewedAt?: DateTimeNullableFilter<"ScriptReview"> | Date | string | null
    createdAt?: DateTimeFilter<"ScriptReview"> | Date | string
  }

  export type VideoUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: VideoWhereUniqueInput
    update: XOR<VideoUpdateWithoutUploadedByInput, VideoUncheckedUpdateWithoutUploadedByInput>
    create: XOR<VideoCreateWithoutUploadedByInput, VideoUncheckedCreateWithoutUploadedByInput>
  }

  export type VideoUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: VideoWhereUniqueInput
    data: XOR<VideoUpdateWithoutUploadedByInput, VideoUncheckedUpdateWithoutUploadedByInput>
  }

  export type VideoUpdateManyWithWhereWithoutUploadedByInput = {
    where: VideoScalarWhereInput
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyWithoutUploadedByInput>
  }

  export type VideoScalarWhereInput = {
    AND?: VideoScalarWhereInput | VideoScalarWhereInput[]
    OR?: VideoScalarWhereInput[]
    NOT?: VideoScalarWhereInput | VideoScalarWhereInput[]
    id?: StringFilter<"Video"> | string
    topicId?: StringFilter<"Video"> | string
    scriptId?: StringNullableFilter<"Video"> | string | null
    title?: StringFilter<"Video"> | string
    description?: StringNullableFilter<"Video"> | string | null
    videoUrl?: StringFilter<"Video"> | string
    thumbnailUrl?: StringNullableFilter<"Video"> | string | null
    duration?: IntNullableFilter<"Video"> | number | null
    fileSize?: BigIntNullableFilter<"Video"> | bigint | number | null
    doctorName?: StringFilter<"Video"> | string
    specialty?: StringFilter<"Video"> | string
    language?: StringFilter<"Video"> | string
    city?: StringFilter<"Video"> | string
    ctaType?: EnumCTATypeFilter<"Video"> | $Enums.CTAType
    tags?: StringNullableListFilter<"Video">
    transcript?: StringNullableFilter<"Video"> | string | null
    transcriptUrl?: StringNullableFilter<"Video"> | string | null
    summary?: StringNullableFilter<"Video"> | string | null
    shortSummary?: StringNullableFilter<"Video"> | string | null
    keyTakeaways?: StringNullableListFilter<"Video">
    entities?: JsonNullableFilter<"Video">
    qualityScore?: IntNullableFilter<"Video"> | number | null
    relatedVideoIds?: StringNullableListFilter<"Video">
    aiProcessedAt?: DateTimeNullableFilter<"Video"> | Date | string | null
    aiProcessingStatus?: StringNullableFilter<"Video"> | string | null
    status?: EnumVideoStatusFilter<"Video"> | $Enums.VideoStatus
    version?: IntFilter<"Video"> | number
    uploadedById?: StringNullableFilter<"Video"> | string | null
    lockedById?: StringNullableFilter<"Video"> | string | null
    lockedAt?: DateTimeNullableFilter<"Video"> | Date | string | null
    publishedById?: StringNullableFilter<"Video"> | string | null
    publishedAt?: DateTimeNullableFilter<"Video"> | Date | string | null
    assignedReviewerId?: StringNullableFilter<"Video"> | string | null
    assignedAt?: DateTimeNullableFilter<"Video"> | Date | string | null
    deepLink?: StringNullableFilter<"Video"> | string | null
    viewCount?: IntFilter<"Video"> | number
    createdAt?: DateTimeFilter<"Video"> | Date | string
    updatedAt?: DateTimeFilter<"Video"> | Date | string
  }

  export type VideoUpsertWithWhereUniqueWithoutLockedByInput = {
    where: VideoWhereUniqueInput
    update: XOR<VideoUpdateWithoutLockedByInput, VideoUncheckedUpdateWithoutLockedByInput>
    create: XOR<VideoCreateWithoutLockedByInput, VideoUncheckedCreateWithoutLockedByInput>
  }

  export type VideoUpdateWithWhereUniqueWithoutLockedByInput = {
    where: VideoWhereUniqueInput
    data: XOR<VideoUpdateWithoutLockedByInput, VideoUncheckedUpdateWithoutLockedByInput>
  }

  export type VideoUpdateManyWithWhereWithoutLockedByInput = {
    where: VideoScalarWhereInput
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyWithoutLockedByInput>
  }

  export type VideoUpsertWithWhereUniqueWithoutPublishedByInput = {
    where: VideoWhereUniqueInput
    update: XOR<VideoUpdateWithoutPublishedByInput, VideoUncheckedUpdateWithoutPublishedByInput>
    create: XOR<VideoCreateWithoutPublishedByInput, VideoUncheckedCreateWithoutPublishedByInput>
  }

  export type VideoUpdateWithWhereUniqueWithoutPublishedByInput = {
    where: VideoWhereUniqueInput
    data: XOR<VideoUpdateWithoutPublishedByInput, VideoUncheckedUpdateWithoutPublishedByInput>
  }

  export type VideoUpdateManyWithWhereWithoutPublishedByInput = {
    where: VideoScalarWhereInput
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyWithoutPublishedByInput>
  }

  export type VideoUpsertWithWhereUniqueWithoutAssignedReviewerInput = {
    where: VideoWhereUniqueInput
    update: XOR<VideoUpdateWithoutAssignedReviewerInput, VideoUncheckedUpdateWithoutAssignedReviewerInput>
    create: XOR<VideoCreateWithoutAssignedReviewerInput, VideoUncheckedCreateWithoutAssignedReviewerInput>
  }

  export type VideoUpdateWithWhereUniqueWithoutAssignedReviewerInput = {
    where: VideoWhereUniqueInput
    data: XOR<VideoUpdateWithoutAssignedReviewerInput, VideoUncheckedUpdateWithoutAssignedReviewerInput>
  }

  export type VideoUpdateManyWithWhereWithoutAssignedReviewerInput = {
    where: VideoScalarWhereInput
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyWithoutAssignedReviewerInput>
  }

  export type VideoReviewUpsertWithWhereUniqueWithoutReviewerInput = {
    where: VideoReviewWhereUniqueInput
    update: XOR<VideoReviewUpdateWithoutReviewerInput, VideoReviewUncheckedUpdateWithoutReviewerInput>
    create: XOR<VideoReviewCreateWithoutReviewerInput, VideoReviewUncheckedCreateWithoutReviewerInput>
  }

  export type VideoReviewUpdateWithWhereUniqueWithoutReviewerInput = {
    where: VideoReviewWhereUniqueInput
    data: XOR<VideoReviewUpdateWithoutReviewerInput, VideoReviewUncheckedUpdateWithoutReviewerInput>
  }

  export type VideoReviewUpdateManyWithWhereWithoutReviewerInput = {
    where: VideoReviewScalarWhereInput
    data: XOR<VideoReviewUpdateManyMutationInput, VideoReviewUncheckedUpdateManyWithoutReviewerInput>
  }

  export type VideoReviewScalarWhereInput = {
    AND?: VideoReviewScalarWhereInput | VideoReviewScalarWhereInput[]
    OR?: VideoReviewScalarWhereInput[]
    NOT?: VideoReviewScalarWhereInput | VideoReviewScalarWhereInput[]
    id?: StringFilter<"VideoReview"> | string
    videoId?: StringFilter<"VideoReview"> | string
    reviewerId?: StringFilter<"VideoReview"> | string
    reviewerType?: EnumUserRoleFilter<"VideoReview"> | $Enums.UserRole
    decision?: EnumReviewDecisionFilter<"VideoReview"> | $Enums.ReviewDecision
    comments?: StringNullableFilter<"VideoReview"> | string | null
    reviewedAt?: DateTimeNullableFilter<"VideoReview"> | Date | string | null
    createdAt?: DateTimeFilter<"VideoReview"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
  }

  export type CommentUpdateManyWithWhereWithoutAuthorInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    scriptId?: StringNullableFilter<"Comment"> | string | null
    videoId?: StringNullableFilter<"Comment"> | string | null
    authorId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    oldValue?: JsonNullableFilter<"AuditLog">
    newValue?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type UserCreateWithoutAssignedTopicsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdTopics?: TopicCreateNestedManyWithoutCreatedByInput
    doctorPointers?: DoctorPointerCreateNestedManyWithoutDoctorInput
    uploadedScripts?: ScriptCreateNestedManyWithoutUploadedByInput
    lockedScripts?: ScriptCreateNestedManyWithoutLockedByInput
    assignedScripts?: ScriptCreateNestedManyWithoutAssignedReviewerInput
    scriptReviews?: ScriptReviewCreateNestedManyWithoutReviewerInput
    uploadedVideos?: VideoCreateNestedManyWithoutUploadedByInput
    lockedVideos?: VideoCreateNestedManyWithoutLockedByInput
    publishedVideos?: VideoCreateNestedManyWithoutPublishedByInput
    assignedVideos?: VideoCreateNestedManyWithoutAssignedReviewerInput
    videoReviews?: VideoReviewCreateNestedManyWithoutReviewerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedTopicsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdTopics?: TopicUncheckedCreateNestedManyWithoutCreatedByInput
    doctorPointers?: DoctorPointerUncheckedCreateNestedManyWithoutDoctorInput
    uploadedScripts?: ScriptUncheckedCreateNestedManyWithoutUploadedByInput
    lockedScripts?: ScriptUncheckedCreateNestedManyWithoutLockedByInput
    assignedScripts?: ScriptUncheckedCreateNestedManyWithoutAssignedReviewerInput
    scriptReviews?: ScriptReviewUncheckedCreateNestedManyWithoutReviewerInput
    uploadedVideos?: VideoUncheckedCreateNestedManyWithoutUploadedByInput
    lockedVideos?: VideoUncheckedCreateNestedManyWithoutLockedByInput
    publishedVideos?: VideoUncheckedCreateNestedManyWithoutPublishedByInput
    assignedVideos?: VideoUncheckedCreateNestedManyWithoutAssignedReviewerInput
    videoReviews?: VideoReviewUncheckedCreateNestedManyWithoutReviewerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedTopicsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedTopicsInput, UserUncheckedCreateWithoutAssignedTopicsInput>
  }

  export type UserCreateWithoutCreatedTopicsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    assignedTopics?: TopicCreateNestedManyWithoutAssignedDoctorInput
    doctorPointers?: DoctorPointerCreateNestedManyWithoutDoctorInput
    uploadedScripts?: ScriptCreateNestedManyWithoutUploadedByInput
    lockedScripts?: ScriptCreateNestedManyWithoutLockedByInput
    assignedScripts?: ScriptCreateNestedManyWithoutAssignedReviewerInput
    scriptReviews?: ScriptReviewCreateNestedManyWithoutReviewerInput
    uploadedVideos?: VideoCreateNestedManyWithoutUploadedByInput
    lockedVideos?: VideoCreateNestedManyWithoutLockedByInput
    publishedVideos?: VideoCreateNestedManyWithoutPublishedByInput
    assignedVideos?: VideoCreateNestedManyWithoutAssignedReviewerInput
    videoReviews?: VideoReviewCreateNestedManyWithoutReviewerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedTopicsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    assignedTopics?: TopicUncheckedCreateNestedManyWithoutAssignedDoctorInput
    doctorPointers?: DoctorPointerUncheckedCreateNestedManyWithoutDoctorInput
    uploadedScripts?: ScriptUncheckedCreateNestedManyWithoutUploadedByInput
    lockedScripts?: ScriptUncheckedCreateNestedManyWithoutLockedByInput
    assignedScripts?: ScriptUncheckedCreateNestedManyWithoutAssignedReviewerInput
    scriptReviews?: ScriptReviewUncheckedCreateNestedManyWithoutReviewerInput
    uploadedVideos?: VideoUncheckedCreateNestedManyWithoutUploadedByInput
    lockedVideos?: VideoUncheckedCreateNestedManyWithoutLockedByInput
    publishedVideos?: VideoUncheckedCreateNestedManyWithoutPublishedByInput
    assignedVideos?: VideoUncheckedCreateNestedManyWithoutAssignedReviewerInput
    videoReviews?: VideoReviewUncheckedCreateNestedManyWithoutReviewerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedTopicsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedTopicsInput, UserUncheckedCreateWithoutCreatedTopicsInput>
  }

  export type DoctorPointerCreateWithoutTopicInput = {
    id?: string
    notes?: string | null
    fileUrl?: string | null
    fileType?: string | null
    createdAt?: Date | string
    doctor: UserCreateNestedOneWithoutDoctorPointersInput
  }

  export type DoctorPointerUncheckedCreateWithoutTopicInput = {
    id?: string
    doctorId: string
    notes?: string | null
    fileUrl?: string | null
    fileType?: string | null
    createdAt?: Date | string
  }

  export type DoctorPointerCreateOrConnectWithoutTopicInput = {
    where: DoctorPointerWhereUniqueInput
    create: XOR<DoctorPointerCreateWithoutTopicInput, DoctorPointerUncheckedCreateWithoutTopicInput>
  }

  export type DoctorPointerCreateManyTopicInputEnvelope = {
    data: DoctorPointerCreateManyTopicInput | DoctorPointerCreateManyTopicInput[]
    skipDuplicates?: boolean
  }

  export type ScriptCreateWithoutTopicInput = {
    id?: string
    version?: number
    content: string
    status?: $Enums.ScriptStatus
    summary?: string | null
    tags?: ScriptCreatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    lockedAt?: Date | string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedBy?: UserCreateNestedOneWithoutUploadedScriptsInput
    lockedBy?: UserCreateNestedOneWithoutLockedScriptsInput
    assignedReviewer?: UserCreateNestedOneWithoutAssignedScriptsInput
    reviews?: ScriptReviewCreateNestedManyWithoutScriptInput
    comments?: CommentCreateNestedManyWithoutScriptInput
    videos?: VideoCreateNestedManyWithoutScriptInput
  }

  export type ScriptUncheckedCreateWithoutTopicInput = {
    id?: string
    version?: number
    content: string
    status?: $Enums.ScriptStatus
    summary?: string | null
    tags?: ScriptCreatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    uploadedById?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    assignedReviewerId?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ScriptReviewUncheckedCreateNestedManyWithoutScriptInput
    comments?: CommentUncheckedCreateNestedManyWithoutScriptInput
    videos?: VideoUncheckedCreateNestedManyWithoutScriptInput
  }

  export type ScriptCreateOrConnectWithoutTopicInput = {
    where: ScriptWhereUniqueInput
    create: XOR<ScriptCreateWithoutTopicInput, ScriptUncheckedCreateWithoutTopicInput>
  }

  export type ScriptCreateManyTopicInputEnvelope = {
    data: ScriptCreateManyTopicInput | ScriptCreateManyTopicInput[]
    skipDuplicates?: boolean
  }

  export type VideoCreateWithoutTopicInput = {
    id?: string
    title: string
    description?: string | null
    videoUrl: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: bigint | number | null
    doctorName: string
    specialty: string
    language: string
    city: string
    ctaType: $Enums.CTAType
    tags?: VideoCreatetagsInput | string[]
    transcript?: string | null
    transcriptUrl?: string | null
    summary?: string | null
    shortSummary?: string | null
    keyTakeaways?: VideoCreatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    relatedVideoIds?: VideoCreaterelatedVideoIdsInput | string[]
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    status?: $Enums.VideoStatus
    version?: number
    lockedAt?: Date | string | null
    publishedAt?: Date | string | null
    assignedAt?: Date | string | null
    deepLink?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    script?: ScriptCreateNestedOneWithoutVideosInput
    uploadedBy?: UserCreateNestedOneWithoutUploadedVideosInput
    lockedBy?: UserCreateNestedOneWithoutLockedVideosInput
    publishedBy?: UserCreateNestedOneWithoutPublishedVideosInput
    assignedReviewer?: UserCreateNestedOneWithoutAssignedVideosInput
    reviews?: VideoReviewCreateNestedManyWithoutVideoInput
    comments?: CommentCreateNestedManyWithoutVideoInput
    analytics?: VideoAnalyticsCreateNestedOneWithoutVideoInput
  }

  export type VideoUncheckedCreateWithoutTopicInput = {
    id?: string
    scriptId?: string | null
    title: string
    description?: string | null
    videoUrl: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: bigint | number | null
    doctorName: string
    specialty: string
    language: string
    city: string
    ctaType: $Enums.CTAType
    tags?: VideoCreatetagsInput | string[]
    transcript?: string | null
    transcriptUrl?: string | null
    summary?: string | null
    shortSummary?: string | null
    keyTakeaways?: VideoCreatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    relatedVideoIds?: VideoCreaterelatedVideoIdsInput | string[]
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    status?: $Enums.VideoStatus
    version?: number
    uploadedById?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    publishedById?: string | null
    publishedAt?: Date | string | null
    assignedReviewerId?: string | null
    assignedAt?: Date | string | null
    deepLink?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: VideoReviewUncheckedCreateNestedManyWithoutVideoInput
    comments?: CommentUncheckedCreateNestedManyWithoutVideoInput
    analytics?: VideoAnalyticsUncheckedCreateNestedOneWithoutVideoInput
  }

  export type VideoCreateOrConnectWithoutTopicInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutTopicInput, VideoUncheckedCreateWithoutTopicInput>
  }

  export type VideoCreateManyTopicInputEnvelope = {
    data: VideoCreateManyTopicInput | VideoCreateManyTopicInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAssignedTopicsInput = {
    update: XOR<UserUpdateWithoutAssignedTopicsInput, UserUncheckedUpdateWithoutAssignedTopicsInput>
    create: XOR<UserCreateWithoutAssignedTopicsInput, UserUncheckedCreateWithoutAssignedTopicsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedTopicsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedTopicsInput, UserUncheckedUpdateWithoutAssignedTopicsInput>
  }

  export type UserUpdateWithoutAssignedTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdTopics?: TopicUpdateManyWithoutCreatedByNestedInput
    doctorPointers?: DoctorPointerUpdateManyWithoutDoctorNestedInput
    uploadedScripts?: ScriptUpdateManyWithoutUploadedByNestedInput
    lockedScripts?: ScriptUpdateManyWithoutLockedByNestedInput
    assignedScripts?: ScriptUpdateManyWithoutAssignedReviewerNestedInput
    scriptReviews?: ScriptReviewUpdateManyWithoutReviewerNestedInput
    uploadedVideos?: VideoUpdateManyWithoutUploadedByNestedInput
    lockedVideos?: VideoUpdateManyWithoutLockedByNestedInput
    publishedVideos?: VideoUpdateManyWithoutPublishedByNestedInput
    assignedVideos?: VideoUpdateManyWithoutAssignedReviewerNestedInput
    videoReviews?: VideoReviewUpdateManyWithoutReviewerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdTopics?: TopicUncheckedUpdateManyWithoutCreatedByNestedInput
    doctorPointers?: DoctorPointerUncheckedUpdateManyWithoutDoctorNestedInput
    uploadedScripts?: ScriptUncheckedUpdateManyWithoutUploadedByNestedInput
    lockedScripts?: ScriptUncheckedUpdateManyWithoutLockedByNestedInput
    assignedScripts?: ScriptUncheckedUpdateManyWithoutAssignedReviewerNestedInput
    scriptReviews?: ScriptReviewUncheckedUpdateManyWithoutReviewerNestedInput
    uploadedVideos?: VideoUncheckedUpdateManyWithoutUploadedByNestedInput
    lockedVideos?: VideoUncheckedUpdateManyWithoutLockedByNestedInput
    publishedVideos?: VideoUncheckedUpdateManyWithoutPublishedByNestedInput
    assignedVideos?: VideoUncheckedUpdateManyWithoutAssignedReviewerNestedInput
    videoReviews?: VideoReviewUncheckedUpdateManyWithoutReviewerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutCreatedTopicsInput = {
    update: XOR<UserUpdateWithoutCreatedTopicsInput, UserUncheckedUpdateWithoutCreatedTopicsInput>
    create: XOR<UserCreateWithoutCreatedTopicsInput, UserUncheckedCreateWithoutCreatedTopicsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedTopicsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedTopicsInput, UserUncheckedUpdateWithoutCreatedTopicsInput>
  }

  export type UserUpdateWithoutCreatedTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTopics?: TopicUpdateManyWithoutAssignedDoctorNestedInput
    doctorPointers?: DoctorPointerUpdateManyWithoutDoctorNestedInput
    uploadedScripts?: ScriptUpdateManyWithoutUploadedByNestedInput
    lockedScripts?: ScriptUpdateManyWithoutLockedByNestedInput
    assignedScripts?: ScriptUpdateManyWithoutAssignedReviewerNestedInput
    scriptReviews?: ScriptReviewUpdateManyWithoutReviewerNestedInput
    uploadedVideos?: VideoUpdateManyWithoutUploadedByNestedInput
    lockedVideos?: VideoUpdateManyWithoutLockedByNestedInput
    publishedVideos?: VideoUpdateManyWithoutPublishedByNestedInput
    assignedVideos?: VideoUpdateManyWithoutAssignedReviewerNestedInput
    videoReviews?: VideoReviewUpdateManyWithoutReviewerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTopics?: TopicUncheckedUpdateManyWithoutAssignedDoctorNestedInput
    doctorPointers?: DoctorPointerUncheckedUpdateManyWithoutDoctorNestedInput
    uploadedScripts?: ScriptUncheckedUpdateManyWithoutUploadedByNestedInput
    lockedScripts?: ScriptUncheckedUpdateManyWithoutLockedByNestedInput
    assignedScripts?: ScriptUncheckedUpdateManyWithoutAssignedReviewerNestedInput
    scriptReviews?: ScriptReviewUncheckedUpdateManyWithoutReviewerNestedInput
    uploadedVideos?: VideoUncheckedUpdateManyWithoutUploadedByNestedInput
    lockedVideos?: VideoUncheckedUpdateManyWithoutLockedByNestedInput
    publishedVideos?: VideoUncheckedUpdateManyWithoutPublishedByNestedInput
    assignedVideos?: VideoUncheckedUpdateManyWithoutAssignedReviewerNestedInput
    videoReviews?: VideoReviewUncheckedUpdateManyWithoutReviewerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DoctorPointerUpsertWithWhereUniqueWithoutTopicInput = {
    where: DoctorPointerWhereUniqueInput
    update: XOR<DoctorPointerUpdateWithoutTopicInput, DoctorPointerUncheckedUpdateWithoutTopicInput>
    create: XOR<DoctorPointerCreateWithoutTopicInput, DoctorPointerUncheckedCreateWithoutTopicInput>
  }

  export type DoctorPointerUpdateWithWhereUniqueWithoutTopicInput = {
    where: DoctorPointerWhereUniqueInput
    data: XOR<DoctorPointerUpdateWithoutTopicInput, DoctorPointerUncheckedUpdateWithoutTopicInput>
  }

  export type DoctorPointerUpdateManyWithWhereWithoutTopicInput = {
    where: DoctorPointerScalarWhereInput
    data: XOR<DoctorPointerUpdateManyMutationInput, DoctorPointerUncheckedUpdateManyWithoutTopicInput>
  }

  export type ScriptUpsertWithWhereUniqueWithoutTopicInput = {
    where: ScriptWhereUniqueInput
    update: XOR<ScriptUpdateWithoutTopicInput, ScriptUncheckedUpdateWithoutTopicInput>
    create: XOR<ScriptCreateWithoutTopicInput, ScriptUncheckedCreateWithoutTopicInput>
  }

  export type ScriptUpdateWithWhereUniqueWithoutTopicInput = {
    where: ScriptWhereUniqueInput
    data: XOR<ScriptUpdateWithoutTopicInput, ScriptUncheckedUpdateWithoutTopicInput>
  }

  export type ScriptUpdateManyWithWhereWithoutTopicInput = {
    where: ScriptScalarWhereInput
    data: XOR<ScriptUpdateManyMutationInput, ScriptUncheckedUpdateManyWithoutTopicInput>
  }

  export type VideoUpsertWithWhereUniqueWithoutTopicInput = {
    where: VideoWhereUniqueInput
    update: XOR<VideoUpdateWithoutTopicInput, VideoUncheckedUpdateWithoutTopicInput>
    create: XOR<VideoCreateWithoutTopicInput, VideoUncheckedCreateWithoutTopicInput>
  }

  export type VideoUpdateWithWhereUniqueWithoutTopicInput = {
    where: VideoWhereUniqueInput
    data: XOR<VideoUpdateWithoutTopicInput, VideoUncheckedUpdateWithoutTopicInput>
  }

  export type VideoUpdateManyWithWhereWithoutTopicInput = {
    where: VideoScalarWhereInput
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyWithoutTopicInput>
  }

  export type TopicCreateWithoutDoctorPointersInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TopicStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedDoctor: UserCreateNestedOneWithoutAssignedTopicsInput
    createdBy: UserCreateNestedOneWithoutCreatedTopicsInput
    scripts?: ScriptCreateNestedManyWithoutTopicInput
    videos?: VideoCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateWithoutDoctorPointersInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TopicStatus
    assignedDoctorId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    scripts?: ScriptUncheckedCreateNestedManyWithoutTopicInput
    videos?: VideoUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicCreateOrConnectWithoutDoctorPointersInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutDoctorPointersInput, TopicUncheckedCreateWithoutDoctorPointersInput>
  }

  export type UserCreateWithoutDoctorPointersInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    assignedTopics?: TopicCreateNestedManyWithoutAssignedDoctorInput
    createdTopics?: TopicCreateNestedManyWithoutCreatedByInput
    uploadedScripts?: ScriptCreateNestedManyWithoutUploadedByInput
    lockedScripts?: ScriptCreateNestedManyWithoutLockedByInput
    assignedScripts?: ScriptCreateNestedManyWithoutAssignedReviewerInput
    scriptReviews?: ScriptReviewCreateNestedManyWithoutReviewerInput
    uploadedVideos?: VideoCreateNestedManyWithoutUploadedByInput
    lockedVideos?: VideoCreateNestedManyWithoutLockedByInput
    publishedVideos?: VideoCreateNestedManyWithoutPublishedByInput
    assignedVideos?: VideoCreateNestedManyWithoutAssignedReviewerInput
    videoReviews?: VideoReviewCreateNestedManyWithoutReviewerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDoctorPointersInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    assignedTopics?: TopicUncheckedCreateNestedManyWithoutAssignedDoctorInput
    createdTopics?: TopicUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedScripts?: ScriptUncheckedCreateNestedManyWithoutUploadedByInput
    lockedScripts?: ScriptUncheckedCreateNestedManyWithoutLockedByInput
    assignedScripts?: ScriptUncheckedCreateNestedManyWithoutAssignedReviewerInput
    scriptReviews?: ScriptReviewUncheckedCreateNestedManyWithoutReviewerInput
    uploadedVideos?: VideoUncheckedCreateNestedManyWithoutUploadedByInput
    lockedVideos?: VideoUncheckedCreateNestedManyWithoutLockedByInput
    publishedVideos?: VideoUncheckedCreateNestedManyWithoutPublishedByInput
    assignedVideos?: VideoUncheckedCreateNestedManyWithoutAssignedReviewerInput
    videoReviews?: VideoReviewUncheckedCreateNestedManyWithoutReviewerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDoctorPointersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDoctorPointersInput, UserUncheckedCreateWithoutDoctorPointersInput>
  }

  export type TopicUpsertWithoutDoctorPointersInput = {
    update: XOR<TopicUpdateWithoutDoctorPointersInput, TopicUncheckedUpdateWithoutDoctorPointersInput>
    create: XOR<TopicCreateWithoutDoctorPointersInput, TopicUncheckedCreateWithoutDoctorPointersInput>
    where?: TopicWhereInput
  }

  export type TopicUpdateToOneWithWhereWithoutDoctorPointersInput = {
    where?: TopicWhereInput
    data: XOR<TopicUpdateWithoutDoctorPointersInput, TopicUncheckedUpdateWithoutDoctorPointersInput>
  }

  export type TopicUpdateWithoutDoctorPointersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedDoctor?: UserUpdateOneRequiredWithoutAssignedTopicsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTopicsNestedInput
    scripts?: ScriptUpdateManyWithoutTopicNestedInput
    videos?: VideoUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateWithoutDoctorPointersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    assignedDoctorId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scripts?: ScriptUncheckedUpdateManyWithoutTopicNestedInput
    videos?: VideoUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type UserUpsertWithoutDoctorPointersInput = {
    update: XOR<UserUpdateWithoutDoctorPointersInput, UserUncheckedUpdateWithoutDoctorPointersInput>
    create: XOR<UserCreateWithoutDoctorPointersInput, UserUncheckedCreateWithoutDoctorPointersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDoctorPointersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDoctorPointersInput, UserUncheckedUpdateWithoutDoctorPointersInput>
  }

  export type UserUpdateWithoutDoctorPointersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTopics?: TopicUpdateManyWithoutAssignedDoctorNestedInput
    createdTopics?: TopicUpdateManyWithoutCreatedByNestedInput
    uploadedScripts?: ScriptUpdateManyWithoutUploadedByNestedInput
    lockedScripts?: ScriptUpdateManyWithoutLockedByNestedInput
    assignedScripts?: ScriptUpdateManyWithoutAssignedReviewerNestedInput
    scriptReviews?: ScriptReviewUpdateManyWithoutReviewerNestedInput
    uploadedVideos?: VideoUpdateManyWithoutUploadedByNestedInput
    lockedVideos?: VideoUpdateManyWithoutLockedByNestedInput
    publishedVideos?: VideoUpdateManyWithoutPublishedByNestedInput
    assignedVideos?: VideoUpdateManyWithoutAssignedReviewerNestedInput
    videoReviews?: VideoReviewUpdateManyWithoutReviewerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDoctorPointersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTopics?: TopicUncheckedUpdateManyWithoutAssignedDoctorNestedInput
    createdTopics?: TopicUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedScripts?: ScriptUncheckedUpdateManyWithoutUploadedByNestedInput
    lockedScripts?: ScriptUncheckedUpdateManyWithoutLockedByNestedInput
    assignedScripts?: ScriptUncheckedUpdateManyWithoutAssignedReviewerNestedInput
    scriptReviews?: ScriptReviewUncheckedUpdateManyWithoutReviewerNestedInput
    uploadedVideos?: VideoUncheckedUpdateManyWithoutUploadedByNestedInput
    lockedVideos?: VideoUncheckedUpdateManyWithoutLockedByNestedInput
    publishedVideos?: VideoUncheckedUpdateManyWithoutPublishedByNestedInput
    assignedVideos?: VideoUncheckedUpdateManyWithoutAssignedReviewerNestedInput
    videoReviews?: VideoReviewUncheckedUpdateManyWithoutReviewerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TopicCreateWithoutScriptsInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TopicStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedDoctor: UserCreateNestedOneWithoutAssignedTopicsInput
    createdBy: UserCreateNestedOneWithoutCreatedTopicsInput
    doctorPointers?: DoctorPointerCreateNestedManyWithoutTopicInput
    videos?: VideoCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateWithoutScriptsInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TopicStatus
    assignedDoctorId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorPointers?: DoctorPointerUncheckedCreateNestedManyWithoutTopicInput
    videos?: VideoUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicCreateOrConnectWithoutScriptsInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutScriptsInput, TopicUncheckedCreateWithoutScriptsInput>
  }

  export type UserCreateWithoutUploadedScriptsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    assignedTopics?: TopicCreateNestedManyWithoutAssignedDoctorInput
    createdTopics?: TopicCreateNestedManyWithoutCreatedByInput
    doctorPointers?: DoctorPointerCreateNestedManyWithoutDoctorInput
    lockedScripts?: ScriptCreateNestedManyWithoutLockedByInput
    assignedScripts?: ScriptCreateNestedManyWithoutAssignedReviewerInput
    scriptReviews?: ScriptReviewCreateNestedManyWithoutReviewerInput
    uploadedVideos?: VideoCreateNestedManyWithoutUploadedByInput
    lockedVideos?: VideoCreateNestedManyWithoutLockedByInput
    publishedVideos?: VideoCreateNestedManyWithoutPublishedByInput
    assignedVideos?: VideoCreateNestedManyWithoutAssignedReviewerInput
    videoReviews?: VideoReviewCreateNestedManyWithoutReviewerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUploadedScriptsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    assignedTopics?: TopicUncheckedCreateNestedManyWithoutAssignedDoctorInput
    createdTopics?: TopicUncheckedCreateNestedManyWithoutCreatedByInput
    doctorPointers?: DoctorPointerUncheckedCreateNestedManyWithoutDoctorInput
    lockedScripts?: ScriptUncheckedCreateNestedManyWithoutLockedByInput
    assignedScripts?: ScriptUncheckedCreateNestedManyWithoutAssignedReviewerInput
    scriptReviews?: ScriptReviewUncheckedCreateNestedManyWithoutReviewerInput
    uploadedVideos?: VideoUncheckedCreateNestedManyWithoutUploadedByInput
    lockedVideos?: VideoUncheckedCreateNestedManyWithoutLockedByInput
    publishedVideos?: VideoUncheckedCreateNestedManyWithoutPublishedByInput
    assignedVideos?: VideoUncheckedCreateNestedManyWithoutAssignedReviewerInput
    videoReviews?: VideoReviewUncheckedCreateNestedManyWithoutReviewerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUploadedScriptsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedScriptsInput, UserUncheckedCreateWithoutUploadedScriptsInput>
  }

  export type UserCreateWithoutLockedScriptsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    assignedTopics?: TopicCreateNestedManyWithoutAssignedDoctorInput
    createdTopics?: TopicCreateNestedManyWithoutCreatedByInput
    doctorPointers?: DoctorPointerCreateNestedManyWithoutDoctorInput
    uploadedScripts?: ScriptCreateNestedManyWithoutUploadedByInput
    assignedScripts?: ScriptCreateNestedManyWithoutAssignedReviewerInput
    scriptReviews?: ScriptReviewCreateNestedManyWithoutReviewerInput
    uploadedVideos?: VideoCreateNestedManyWithoutUploadedByInput
    lockedVideos?: VideoCreateNestedManyWithoutLockedByInput
    publishedVideos?: VideoCreateNestedManyWithoutPublishedByInput
    assignedVideos?: VideoCreateNestedManyWithoutAssignedReviewerInput
    videoReviews?: VideoReviewCreateNestedManyWithoutReviewerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLockedScriptsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    assignedTopics?: TopicUncheckedCreateNestedManyWithoutAssignedDoctorInput
    createdTopics?: TopicUncheckedCreateNestedManyWithoutCreatedByInput
    doctorPointers?: DoctorPointerUncheckedCreateNestedManyWithoutDoctorInput
    uploadedScripts?: ScriptUncheckedCreateNestedManyWithoutUploadedByInput
    assignedScripts?: ScriptUncheckedCreateNestedManyWithoutAssignedReviewerInput
    scriptReviews?: ScriptReviewUncheckedCreateNestedManyWithoutReviewerInput
    uploadedVideos?: VideoUncheckedCreateNestedManyWithoutUploadedByInput
    lockedVideos?: VideoUncheckedCreateNestedManyWithoutLockedByInput
    publishedVideos?: VideoUncheckedCreateNestedManyWithoutPublishedByInput
    assignedVideos?: VideoUncheckedCreateNestedManyWithoutAssignedReviewerInput
    videoReviews?: VideoReviewUncheckedCreateNestedManyWithoutReviewerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLockedScriptsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLockedScriptsInput, UserUncheckedCreateWithoutLockedScriptsInput>
  }

  export type UserCreateWithoutAssignedScriptsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    assignedTopics?: TopicCreateNestedManyWithoutAssignedDoctorInput
    createdTopics?: TopicCreateNestedManyWithoutCreatedByInput
    doctorPointers?: DoctorPointerCreateNestedManyWithoutDoctorInput
    uploadedScripts?: ScriptCreateNestedManyWithoutUploadedByInput
    lockedScripts?: ScriptCreateNestedManyWithoutLockedByInput
    scriptReviews?: ScriptReviewCreateNestedManyWithoutReviewerInput
    uploadedVideos?: VideoCreateNestedManyWithoutUploadedByInput
    lockedVideos?: VideoCreateNestedManyWithoutLockedByInput
    publishedVideos?: VideoCreateNestedManyWithoutPublishedByInput
    assignedVideos?: VideoCreateNestedManyWithoutAssignedReviewerInput
    videoReviews?: VideoReviewCreateNestedManyWithoutReviewerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedScriptsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    assignedTopics?: TopicUncheckedCreateNestedManyWithoutAssignedDoctorInput
    createdTopics?: TopicUncheckedCreateNestedManyWithoutCreatedByInput
    doctorPointers?: DoctorPointerUncheckedCreateNestedManyWithoutDoctorInput
    uploadedScripts?: ScriptUncheckedCreateNestedManyWithoutUploadedByInput
    lockedScripts?: ScriptUncheckedCreateNestedManyWithoutLockedByInput
    scriptReviews?: ScriptReviewUncheckedCreateNestedManyWithoutReviewerInput
    uploadedVideos?: VideoUncheckedCreateNestedManyWithoutUploadedByInput
    lockedVideos?: VideoUncheckedCreateNestedManyWithoutLockedByInput
    publishedVideos?: VideoUncheckedCreateNestedManyWithoutPublishedByInput
    assignedVideos?: VideoUncheckedCreateNestedManyWithoutAssignedReviewerInput
    videoReviews?: VideoReviewUncheckedCreateNestedManyWithoutReviewerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedScriptsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedScriptsInput, UserUncheckedCreateWithoutAssignedScriptsInput>
  }

  export type ScriptReviewCreateWithoutScriptInput = {
    id?: string
    reviewerType: $Enums.UserRole
    decision?: $Enums.ReviewDecision
    comments?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    reviewer: UserCreateNestedOneWithoutScriptReviewsInput
  }

  export type ScriptReviewUncheckedCreateWithoutScriptInput = {
    id?: string
    reviewerId: string
    reviewerType: $Enums.UserRole
    decision?: $Enums.ReviewDecision
    comments?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ScriptReviewCreateOrConnectWithoutScriptInput = {
    where: ScriptReviewWhereUniqueInput
    create: XOR<ScriptReviewCreateWithoutScriptInput, ScriptReviewUncheckedCreateWithoutScriptInput>
  }

  export type ScriptReviewCreateManyScriptInputEnvelope = {
    data: ScriptReviewCreateManyScriptInput | ScriptReviewCreateManyScriptInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutScriptInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    video?: VideoCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutScriptInput = {
    id?: string
    videoId?: string | null
    authorId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutScriptInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutScriptInput, CommentUncheckedCreateWithoutScriptInput>
  }

  export type CommentCreateManyScriptInputEnvelope = {
    data: CommentCreateManyScriptInput | CommentCreateManyScriptInput[]
    skipDuplicates?: boolean
  }

  export type VideoCreateWithoutScriptInput = {
    id?: string
    title: string
    description?: string | null
    videoUrl: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: bigint | number | null
    doctorName: string
    specialty: string
    language: string
    city: string
    ctaType: $Enums.CTAType
    tags?: VideoCreatetagsInput | string[]
    transcript?: string | null
    transcriptUrl?: string | null
    summary?: string | null
    shortSummary?: string | null
    keyTakeaways?: VideoCreatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    relatedVideoIds?: VideoCreaterelatedVideoIdsInput | string[]
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    status?: $Enums.VideoStatus
    version?: number
    lockedAt?: Date | string | null
    publishedAt?: Date | string | null
    assignedAt?: Date | string | null
    deepLink?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    topic: TopicCreateNestedOneWithoutVideosInput
    uploadedBy?: UserCreateNestedOneWithoutUploadedVideosInput
    lockedBy?: UserCreateNestedOneWithoutLockedVideosInput
    publishedBy?: UserCreateNestedOneWithoutPublishedVideosInput
    assignedReviewer?: UserCreateNestedOneWithoutAssignedVideosInput
    reviews?: VideoReviewCreateNestedManyWithoutVideoInput
    comments?: CommentCreateNestedManyWithoutVideoInput
    analytics?: VideoAnalyticsCreateNestedOneWithoutVideoInput
  }

  export type VideoUncheckedCreateWithoutScriptInput = {
    id?: string
    topicId: string
    title: string
    description?: string | null
    videoUrl: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: bigint | number | null
    doctorName: string
    specialty: string
    language: string
    city: string
    ctaType: $Enums.CTAType
    tags?: VideoCreatetagsInput | string[]
    transcript?: string | null
    transcriptUrl?: string | null
    summary?: string | null
    shortSummary?: string | null
    keyTakeaways?: VideoCreatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    relatedVideoIds?: VideoCreaterelatedVideoIdsInput | string[]
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    status?: $Enums.VideoStatus
    version?: number
    uploadedById?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    publishedById?: string | null
    publishedAt?: Date | string | null
    assignedReviewerId?: string | null
    assignedAt?: Date | string | null
    deepLink?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: VideoReviewUncheckedCreateNestedManyWithoutVideoInput
    comments?: CommentUncheckedCreateNestedManyWithoutVideoInput
    analytics?: VideoAnalyticsUncheckedCreateNestedOneWithoutVideoInput
  }

  export type VideoCreateOrConnectWithoutScriptInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutScriptInput, VideoUncheckedCreateWithoutScriptInput>
  }

  export type VideoCreateManyScriptInputEnvelope = {
    data: VideoCreateManyScriptInput | VideoCreateManyScriptInput[]
    skipDuplicates?: boolean
  }

  export type TopicUpsertWithoutScriptsInput = {
    update: XOR<TopicUpdateWithoutScriptsInput, TopicUncheckedUpdateWithoutScriptsInput>
    create: XOR<TopicCreateWithoutScriptsInput, TopicUncheckedCreateWithoutScriptsInput>
    where?: TopicWhereInput
  }

  export type TopicUpdateToOneWithWhereWithoutScriptsInput = {
    where?: TopicWhereInput
    data: XOR<TopicUpdateWithoutScriptsInput, TopicUncheckedUpdateWithoutScriptsInput>
  }

  export type TopicUpdateWithoutScriptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedDoctor?: UserUpdateOneRequiredWithoutAssignedTopicsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTopicsNestedInput
    doctorPointers?: DoctorPointerUpdateManyWithoutTopicNestedInput
    videos?: VideoUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateWithoutScriptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    assignedDoctorId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorPointers?: DoctorPointerUncheckedUpdateManyWithoutTopicNestedInput
    videos?: VideoUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type UserUpsertWithoutUploadedScriptsInput = {
    update: XOR<UserUpdateWithoutUploadedScriptsInput, UserUncheckedUpdateWithoutUploadedScriptsInput>
    create: XOR<UserCreateWithoutUploadedScriptsInput, UserUncheckedCreateWithoutUploadedScriptsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadedScriptsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadedScriptsInput, UserUncheckedUpdateWithoutUploadedScriptsInput>
  }

  export type UserUpdateWithoutUploadedScriptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTopics?: TopicUpdateManyWithoutAssignedDoctorNestedInput
    createdTopics?: TopicUpdateManyWithoutCreatedByNestedInput
    doctorPointers?: DoctorPointerUpdateManyWithoutDoctorNestedInput
    lockedScripts?: ScriptUpdateManyWithoutLockedByNestedInput
    assignedScripts?: ScriptUpdateManyWithoutAssignedReviewerNestedInput
    scriptReviews?: ScriptReviewUpdateManyWithoutReviewerNestedInput
    uploadedVideos?: VideoUpdateManyWithoutUploadedByNestedInput
    lockedVideos?: VideoUpdateManyWithoutLockedByNestedInput
    publishedVideos?: VideoUpdateManyWithoutPublishedByNestedInput
    assignedVideos?: VideoUpdateManyWithoutAssignedReviewerNestedInput
    videoReviews?: VideoReviewUpdateManyWithoutReviewerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadedScriptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTopics?: TopicUncheckedUpdateManyWithoutAssignedDoctorNestedInput
    createdTopics?: TopicUncheckedUpdateManyWithoutCreatedByNestedInput
    doctorPointers?: DoctorPointerUncheckedUpdateManyWithoutDoctorNestedInput
    lockedScripts?: ScriptUncheckedUpdateManyWithoutLockedByNestedInput
    assignedScripts?: ScriptUncheckedUpdateManyWithoutAssignedReviewerNestedInput
    scriptReviews?: ScriptReviewUncheckedUpdateManyWithoutReviewerNestedInput
    uploadedVideos?: VideoUncheckedUpdateManyWithoutUploadedByNestedInput
    lockedVideos?: VideoUncheckedUpdateManyWithoutLockedByNestedInput
    publishedVideos?: VideoUncheckedUpdateManyWithoutPublishedByNestedInput
    assignedVideos?: VideoUncheckedUpdateManyWithoutAssignedReviewerNestedInput
    videoReviews?: VideoReviewUncheckedUpdateManyWithoutReviewerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutLockedScriptsInput = {
    update: XOR<UserUpdateWithoutLockedScriptsInput, UserUncheckedUpdateWithoutLockedScriptsInput>
    create: XOR<UserCreateWithoutLockedScriptsInput, UserUncheckedCreateWithoutLockedScriptsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLockedScriptsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLockedScriptsInput, UserUncheckedUpdateWithoutLockedScriptsInput>
  }

  export type UserUpdateWithoutLockedScriptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTopics?: TopicUpdateManyWithoutAssignedDoctorNestedInput
    createdTopics?: TopicUpdateManyWithoutCreatedByNestedInput
    doctorPointers?: DoctorPointerUpdateManyWithoutDoctorNestedInput
    uploadedScripts?: ScriptUpdateManyWithoutUploadedByNestedInput
    assignedScripts?: ScriptUpdateManyWithoutAssignedReviewerNestedInput
    scriptReviews?: ScriptReviewUpdateManyWithoutReviewerNestedInput
    uploadedVideos?: VideoUpdateManyWithoutUploadedByNestedInput
    lockedVideos?: VideoUpdateManyWithoutLockedByNestedInput
    publishedVideos?: VideoUpdateManyWithoutPublishedByNestedInput
    assignedVideos?: VideoUpdateManyWithoutAssignedReviewerNestedInput
    videoReviews?: VideoReviewUpdateManyWithoutReviewerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLockedScriptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTopics?: TopicUncheckedUpdateManyWithoutAssignedDoctorNestedInput
    createdTopics?: TopicUncheckedUpdateManyWithoutCreatedByNestedInput
    doctorPointers?: DoctorPointerUncheckedUpdateManyWithoutDoctorNestedInput
    uploadedScripts?: ScriptUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedScripts?: ScriptUncheckedUpdateManyWithoutAssignedReviewerNestedInput
    scriptReviews?: ScriptReviewUncheckedUpdateManyWithoutReviewerNestedInput
    uploadedVideos?: VideoUncheckedUpdateManyWithoutUploadedByNestedInput
    lockedVideos?: VideoUncheckedUpdateManyWithoutLockedByNestedInput
    publishedVideos?: VideoUncheckedUpdateManyWithoutPublishedByNestedInput
    assignedVideos?: VideoUncheckedUpdateManyWithoutAssignedReviewerNestedInput
    videoReviews?: VideoReviewUncheckedUpdateManyWithoutReviewerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutAssignedScriptsInput = {
    update: XOR<UserUpdateWithoutAssignedScriptsInput, UserUncheckedUpdateWithoutAssignedScriptsInput>
    create: XOR<UserCreateWithoutAssignedScriptsInput, UserUncheckedCreateWithoutAssignedScriptsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedScriptsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedScriptsInput, UserUncheckedUpdateWithoutAssignedScriptsInput>
  }

  export type UserUpdateWithoutAssignedScriptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTopics?: TopicUpdateManyWithoutAssignedDoctorNestedInput
    createdTopics?: TopicUpdateManyWithoutCreatedByNestedInput
    doctorPointers?: DoctorPointerUpdateManyWithoutDoctorNestedInput
    uploadedScripts?: ScriptUpdateManyWithoutUploadedByNestedInput
    lockedScripts?: ScriptUpdateManyWithoutLockedByNestedInput
    scriptReviews?: ScriptReviewUpdateManyWithoutReviewerNestedInput
    uploadedVideos?: VideoUpdateManyWithoutUploadedByNestedInput
    lockedVideos?: VideoUpdateManyWithoutLockedByNestedInput
    publishedVideos?: VideoUpdateManyWithoutPublishedByNestedInput
    assignedVideos?: VideoUpdateManyWithoutAssignedReviewerNestedInput
    videoReviews?: VideoReviewUpdateManyWithoutReviewerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedScriptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTopics?: TopicUncheckedUpdateManyWithoutAssignedDoctorNestedInput
    createdTopics?: TopicUncheckedUpdateManyWithoutCreatedByNestedInput
    doctorPointers?: DoctorPointerUncheckedUpdateManyWithoutDoctorNestedInput
    uploadedScripts?: ScriptUncheckedUpdateManyWithoutUploadedByNestedInput
    lockedScripts?: ScriptUncheckedUpdateManyWithoutLockedByNestedInput
    scriptReviews?: ScriptReviewUncheckedUpdateManyWithoutReviewerNestedInput
    uploadedVideos?: VideoUncheckedUpdateManyWithoutUploadedByNestedInput
    lockedVideos?: VideoUncheckedUpdateManyWithoutLockedByNestedInput
    publishedVideos?: VideoUncheckedUpdateManyWithoutPublishedByNestedInput
    assignedVideos?: VideoUncheckedUpdateManyWithoutAssignedReviewerNestedInput
    videoReviews?: VideoReviewUncheckedUpdateManyWithoutReviewerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ScriptReviewUpsertWithWhereUniqueWithoutScriptInput = {
    where: ScriptReviewWhereUniqueInput
    update: XOR<ScriptReviewUpdateWithoutScriptInput, ScriptReviewUncheckedUpdateWithoutScriptInput>
    create: XOR<ScriptReviewCreateWithoutScriptInput, ScriptReviewUncheckedCreateWithoutScriptInput>
  }

  export type ScriptReviewUpdateWithWhereUniqueWithoutScriptInput = {
    where: ScriptReviewWhereUniqueInput
    data: XOR<ScriptReviewUpdateWithoutScriptInput, ScriptReviewUncheckedUpdateWithoutScriptInput>
  }

  export type ScriptReviewUpdateManyWithWhereWithoutScriptInput = {
    where: ScriptReviewScalarWhereInput
    data: XOR<ScriptReviewUpdateManyMutationInput, ScriptReviewUncheckedUpdateManyWithoutScriptInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutScriptInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutScriptInput, CommentUncheckedUpdateWithoutScriptInput>
    create: XOR<CommentCreateWithoutScriptInput, CommentUncheckedCreateWithoutScriptInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutScriptInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutScriptInput, CommentUncheckedUpdateWithoutScriptInput>
  }

  export type CommentUpdateManyWithWhereWithoutScriptInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutScriptInput>
  }

  export type VideoUpsertWithWhereUniqueWithoutScriptInput = {
    where: VideoWhereUniqueInput
    update: XOR<VideoUpdateWithoutScriptInput, VideoUncheckedUpdateWithoutScriptInput>
    create: XOR<VideoCreateWithoutScriptInput, VideoUncheckedCreateWithoutScriptInput>
  }

  export type VideoUpdateWithWhereUniqueWithoutScriptInput = {
    where: VideoWhereUniqueInput
    data: XOR<VideoUpdateWithoutScriptInput, VideoUncheckedUpdateWithoutScriptInput>
  }

  export type VideoUpdateManyWithWhereWithoutScriptInput = {
    where: VideoScalarWhereInput
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyWithoutScriptInput>
  }

  export type ScriptCreateWithoutReviewsInput = {
    id?: string
    version?: number
    content: string
    status?: $Enums.ScriptStatus
    summary?: string | null
    tags?: ScriptCreatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    lockedAt?: Date | string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    topic: TopicCreateNestedOneWithoutScriptsInput
    uploadedBy?: UserCreateNestedOneWithoutUploadedScriptsInput
    lockedBy?: UserCreateNestedOneWithoutLockedScriptsInput
    assignedReviewer?: UserCreateNestedOneWithoutAssignedScriptsInput
    comments?: CommentCreateNestedManyWithoutScriptInput
    videos?: VideoCreateNestedManyWithoutScriptInput
  }

  export type ScriptUncheckedCreateWithoutReviewsInput = {
    id?: string
    topicId: string
    version?: number
    content: string
    status?: $Enums.ScriptStatus
    summary?: string | null
    tags?: ScriptCreatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    uploadedById?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    assignedReviewerId?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutScriptInput
    videos?: VideoUncheckedCreateNestedManyWithoutScriptInput
  }

  export type ScriptCreateOrConnectWithoutReviewsInput = {
    where: ScriptWhereUniqueInput
    create: XOR<ScriptCreateWithoutReviewsInput, ScriptUncheckedCreateWithoutReviewsInput>
  }

  export type UserCreateWithoutScriptReviewsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    assignedTopics?: TopicCreateNestedManyWithoutAssignedDoctorInput
    createdTopics?: TopicCreateNestedManyWithoutCreatedByInput
    doctorPointers?: DoctorPointerCreateNestedManyWithoutDoctorInput
    uploadedScripts?: ScriptCreateNestedManyWithoutUploadedByInput
    lockedScripts?: ScriptCreateNestedManyWithoutLockedByInput
    assignedScripts?: ScriptCreateNestedManyWithoutAssignedReviewerInput
    uploadedVideos?: VideoCreateNestedManyWithoutUploadedByInput
    lockedVideos?: VideoCreateNestedManyWithoutLockedByInput
    publishedVideos?: VideoCreateNestedManyWithoutPublishedByInput
    assignedVideos?: VideoCreateNestedManyWithoutAssignedReviewerInput
    videoReviews?: VideoReviewCreateNestedManyWithoutReviewerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutScriptReviewsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    assignedTopics?: TopicUncheckedCreateNestedManyWithoutAssignedDoctorInput
    createdTopics?: TopicUncheckedCreateNestedManyWithoutCreatedByInput
    doctorPointers?: DoctorPointerUncheckedCreateNestedManyWithoutDoctorInput
    uploadedScripts?: ScriptUncheckedCreateNestedManyWithoutUploadedByInput
    lockedScripts?: ScriptUncheckedCreateNestedManyWithoutLockedByInput
    assignedScripts?: ScriptUncheckedCreateNestedManyWithoutAssignedReviewerInput
    uploadedVideos?: VideoUncheckedCreateNestedManyWithoutUploadedByInput
    lockedVideos?: VideoUncheckedCreateNestedManyWithoutLockedByInput
    publishedVideos?: VideoUncheckedCreateNestedManyWithoutPublishedByInput
    assignedVideos?: VideoUncheckedCreateNestedManyWithoutAssignedReviewerInput
    videoReviews?: VideoReviewUncheckedCreateNestedManyWithoutReviewerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutScriptReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutScriptReviewsInput, UserUncheckedCreateWithoutScriptReviewsInput>
  }

  export type ScriptUpsertWithoutReviewsInput = {
    update: XOR<ScriptUpdateWithoutReviewsInput, ScriptUncheckedUpdateWithoutReviewsInput>
    create: XOR<ScriptCreateWithoutReviewsInput, ScriptUncheckedCreateWithoutReviewsInput>
    where?: ScriptWhereInput
  }

  export type ScriptUpdateToOneWithWhereWithoutReviewsInput = {
    where?: ScriptWhereInput
    data: XOR<ScriptUpdateWithoutReviewsInput, ScriptUncheckedUpdateWithoutReviewsInput>
  }

  export type ScriptUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumScriptStatusFieldUpdateOperationsInput | $Enums.ScriptStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ScriptUpdatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: TopicUpdateOneRequiredWithoutScriptsNestedInput
    uploadedBy?: UserUpdateOneWithoutUploadedScriptsNestedInput
    lockedBy?: UserUpdateOneWithoutLockedScriptsNestedInput
    assignedReviewer?: UserUpdateOneWithoutAssignedScriptsNestedInput
    comments?: CommentUpdateManyWithoutScriptNestedInput
    videos?: VideoUpdateManyWithoutScriptNestedInput
  }

  export type ScriptUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumScriptStatusFieldUpdateOperationsInput | $Enums.ScriptStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ScriptUpdatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedReviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutScriptNestedInput
    videos?: VideoUncheckedUpdateManyWithoutScriptNestedInput
  }

  export type UserUpsertWithoutScriptReviewsInput = {
    update: XOR<UserUpdateWithoutScriptReviewsInput, UserUncheckedUpdateWithoutScriptReviewsInput>
    create: XOR<UserCreateWithoutScriptReviewsInput, UserUncheckedCreateWithoutScriptReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutScriptReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutScriptReviewsInput, UserUncheckedUpdateWithoutScriptReviewsInput>
  }

  export type UserUpdateWithoutScriptReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTopics?: TopicUpdateManyWithoutAssignedDoctorNestedInput
    createdTopics?: TopicUpdateManyWithoutCreatedByNestedInput
    doctorPointers?: DoctorPointerUpdateManyWithoutDoctorNestedInput
    uploadedScripts?: ScriptUpdateManyWithoutUploadedByNestedInput
    lockedScripts?: ScriptUpdateManyWithoutLockedByNestedInput
    assignedScripts?: ScriptUpdateManyWithoutAssignedReviewerNestedInput
    uploadedVideos?: VideoUpdateManyWithoutUploadedByNestedInput
    lockedVideos?: VideoUpdateManyWithoutLockedByNestedInput
    publishedVideos?: VideoUpdateManyWithoutPublishedByNestedInput
    assignedVideos?: VideoUpdateManyWithoutAssignedReviewerNestedInput
    videoReviews?: VideoReviewUpdateManyWithoutReviewerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutScriptReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTopics?: TopicUncheckedUpdateManyWithoutAssignedDoctorNestedInput
    createdTopics?: TopicUncheckedUpdateManyWithoutCreatedByNestedInput
    doctorPointers?: DoctorPointerUncheckedUpdateManyWithoutDoctorNestedInput
    uploadedScripts?: ScriptUncheckedUpdateManyWithoutUploadedByNestedInput
    lockedScripts?: ScriptUncheckedUpdateManyWithoutLockedByNestedInput
    assignedScripts?: ScriptUncheckedUpdateManyWithoutAssignedReviewerNestedInput
    uploadedVideos?: VideoUncheckedUpdateManyWithoutUploadedByNestedInput
    lockedVideos?: VideoUncheckedUpdateManyWithoutLockedByNestedInput
    publishedVideos?: VideoUncheckedUpdateManyWithoutPublishedByNestedInput
    assignedVideos?: VideoUncheckedUpdateManyWithoutAssignedReviewerNestedInput
    videoReviews?: VideoReviewUncheckedUpdateManyWithoutReviewerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TopicCreateWithoutVideosInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TopicStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedDoctor: UserCreateNestedOneWithoutAssignedTopicsInput
    createdBy: UserCreateNestedOneWithoutCreatedTopicsInput
    doctorPointers?: DoctorPointerCreateNestedManyWithoutTopicInput
    scripts?: ScriptCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateWithoutVideosInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TopicStatus
    assignedDoctorId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorPointers?: DoctorPointerUncheckedCreateNestedManyWithoutTopicInput
    scripts?: ScriptUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicCreateOrConnectWithoutVideosInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutVideosInput, TopicUncheckedCreateWithoutVideosInput>
  }

  export type ScriptCreateWithoutVideosInput = {
    id?: string
    version?: number
    content: string
    status?: $Enums.ScriptStatus
    summary?: string | null
    tags?: ScriptCreatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    lockedAt?: Date | string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    topic: TopicCreateNestedOneWithoutScriptsInput
    uploadedBy?: UserCreateNestedOneWithoutUploadedScriptsInput
    lockedBy?: UserCreateNestedOneWithoutLockedScriptsInput
    assignedReviewer?: UserCreateNestedOneWithoutAssignedScriptsInput
    reviews?: ScriptReviewCreateNestedManyWithoutScriptInput
    comments?: CommentCreateNestedManyWithoutScriptInput
  }

  export type ScriptUncheckedCreateWithoutVideosInput = {
    id?: string
    topicId: string
    version?: number
    content: string
    status?: $Enums.ScriptStatus
    summary?: string | null
    tags?: ScriptCreatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    uploadedById?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    assignedReviewerId?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ScriptReviewUncheckedCreateNestedManyWithoutScriptInput
    comments?: CommentUncheckedCreateNestedManyWithoutScriptInput
  }

  export type ScriptCreateOrConnectWithoutVideosInput = {
    where: ScriptWhereUniqueInput
    create: XOR<ScriptCreateWithoutVideosInput, ScriptUncheckedCreateWithoutVideosInput>
  }

  export type UserCreateWithoutUploadedVideosInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    assignedTopics?: TopicCreateNestedManyWithoutAssignedDoctorInput
    createdTopics?: TopicCreateNestedManyWithoutCreatedByInput
    doctorPointers?: DoctorPointerCreateNestedManyWithoutDoctorInput
    uploadedScripts?: ScriptCreateNestedManyWithoutUploadedByInput
    lockedScripts?: ScriptCreateNestedManyWithoutLockedByInput
    assignedScripts?: ScriptCreateNestedManyWithoutAssignedReviewerInput
    scriptReviews?: ScriptReviewCreateNestedManyWithoutReviewerInput
    lockedVideos?: VideoCreateNestedManyWithoutLockedByInput
    publishedVideos?: VideoCreateNestedManyWithoutPublishedByInput
    assignedVideos?: VideoCreateNestedManyWithoutAssignedReviewerInput
    videoReviews?: VideoReviewCreateNestedManyWithoutReviewerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUploadedVideosInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    assignedTopics?: TopicUncheckedCreateNestedManyWithoutAssignedDoctorInput
    createdTopics?: TopicUncheckedCreateNestedManyWithoutCreatedByInput
    doctorPointers?: DoctorPointerUncheckedCreateNestedManyWithoutDoctorInput
    uploadedScripts?: ScriptUncheckedCreateNestedManyWithoutUploadedByInput
    lockedScripts?: ScriptUncheckedCreateNestedManyWithoutLockedByInput
    assignedScripts?: ScriptUncheckedCreateNestedManyWithoutAssignedReviewerInput
    scriptReviews?: ScriptReviewUncheckedCreateNestedManyWithoutReviewerInput
    lockedVideos?: VideoUncheckedCreateNestedManyWithoutLockedByInput
    publishedVideos?: VideoUncheckedCreateNestedManyWithoutPublishedByInput
    assignedVideos?: VideoUncheckedCreateNestedManyWithoutAssignedReviewerInput
    videoReviews?: VideoReviewUncheckedCreateNestedManyWithoutReviewerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUploadedVideosInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedVideosInput, UserUncheckedCreateWithoutUploadedVideosInput>
  }

  export type UserCreateWithoutLockedVideosInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    assignedTopics?: TopicCreateNestedManyWithoutAssignedDoctorInput
    createdTopics?: TopicCreateNestedManyWithoutCreatedByInput
    doctorPointers?: DoctorPointerCreateNestedManyWithoutDoctorInput
    uploadedScripts?: ScriptCreateNestedManyWithoutUploadedByInput
    lockedScripts?: ScriptCreateNestedManyWithoutLockedByInput
    assignedScripts?: ScriptCreateNestedManyWithoutAssignedReviewerInput
    scriptReviews?: ScriptReviewCreateNestedManyWithoutReviewerInput
    uploadedVideos?: VideoCreateNestedManyWithoutUploadedByInput
    publishedVideos?: VideoCreateNestedManyWithoutPublishedByInput
    assignedVideos?: VideoCreateNestedManyWithoutAssignedReviewerInput
    videoReviews?: VideoReviewCreateNestedManyWithoutReviewerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLockedVideosInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    assignedTopics?: TopicUncheckedCreateNestedManyWithoutAssignedDoctorInput
    createdTopics?: TopicUncheckedCreateNestedManyWithoutCreatedByInput
    doctorPointers?: DoctorPointerUncheckedCreateNestedManyWithoutDoctorInput
    uploadedScripts?: ScriptUncheckedCreateNestedManyWithoutUploadedByInput
    lockedScripts?: ScriptUncheckedCreateNestedManyWithoutLockedByInput
    assignedScripts?: ScriptUncheckedCreateNestedManyWithoutAssignedReviewerInput
    scriptReviews?: ScriptReviewUncheckedCreateNestedManyWithoutReviewerInput
    uploadedVideos?: VideoUncheckedCreateNestedManyWithoutUploadedByInput
    publishedVideos?: VideoUncheckedCreateNestedManyWithoutPublishedByInput
    assignedVideos?: VideoUncheckedCreateNestedManyWithoutAssignedReviewerInput
    videoReviews?: VideoReviewUncheckedCreateNestedManyWithoutReviewerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLockedVideosInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLockedVideosInput, UserUncheckedCreateWithoutLockedVideosInput>
  }

  export type UserCreateWithoutPublishedVideosInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    assignedTopics?: TopicCreateNestedManyWithoutAssignedDoctorInput
    createdTopics?: TopicCreateNestedManyWithoutCreatedByInput
    doctorPointers?: DoctorPointerCreateNestedManyWithoutDoctorInput
    uploadedScripts?: ScriptCreateNestedManyWithoutUploadedByInput
    lockedScripts?: ScriptCreateNestedManyWithoutLockedByInput
    assignedScripts?: ScriptCreateNestedManyWithoutAssignedReviewerInput
    scriptReviews?: ScriptReviewCreateNestedManyWithoutReviewerInput
    uploadedVideos?: VideoCreateNestedManyWithoutUploadedByInput
    lockedVideos?: VideoCreateNestedManyWithoutLockedByInput
    assignedVideos?: VideoCreateNestedManyWithoutAssignedReviewerInput
    videoReviews?: VideoReviewCreateNestedManyWithoutReviewerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPublishedVideosInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    assignedTopics?: TopicUncheckedCreateNestedManyWithoutAssignedDoctorInput
    createdTopics?: TopicUncheckedCreateNestedManyWithoutCreatedByInput
    doctorPointers?: DoctorPointerUncheckedCreateNestedManyWithoutDoctorInput
    uploadedScripts?: ScriptUncheckedCreateNestedManyWithoutUploadedByInput
    lockedScripts?: ScriptUncheckedCreateNestedManyWithoutLockedByInput
    assignedScripts?: ScriptUncheckedCreateNestedManyWithoutAssignedReviewerInput
    scriptReviews?: ScriptReviewUncheckedCreateNestedManyWithoutReviewerInput
    uploadedVideos?: VideoUncheckedCreateNestedManyWithoutUploadedByInput
    lockedVideos?: VideoUncheckedCreateNestedManyWithoutLockedByInput
    assignedVideos?: VideoUncheckedCreateNestedManyWithoutAssignedReviewerInput
    videoReviews?: VideoReviewUncheckedCreateNestedManyWithoutReviewerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPublishedVideosInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPublishedVideosInput, UserUncheckedCreateWithoutPublishedVideosInput>
  }

  export type UserCreateWithoutAssignedVideosInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    assignedTopics?: TopicCreateNestedManyWithoutAssignedDoctorInput
    createdTopics?: TopicCreateNestedManyWithoutCreatedByInput
    doctorPointers?: DoctorPointerCreateNestedManyWithoutDoctorInput
    uploadedScripts?: ScriptCreateNestedManyWithoutUploadedByInput
    lockedScripts?: ScriptCreateNestedManyWithoutLockedByInput
    assignedScripts?: ScriptCreateNestedManyWithoutAssignedReviewerInput
    scriptReviews?: ScriptReviewCreateNestedManyWithoutReviewerInput
    uploadedVideos?: VideoCreateNestedManyWithoutUploadedByInput
    lockedVideos?: VideoCreateNestedManyWithoutLockedByInput
    publishedVideos?: VideoCreateNestedManyWithoutPublishedByInput
    videoReviews?: VideoReviewCreateNestedManyWithoutReviewerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedVideosInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    assignedTopics?: TopicUncheckedCreateNestedManyWithoutAssignedDoctorInput
    createdTopics?: TopicUncheckedCreateNestedManyWithoutCreatedByInput
    doctorPointers?: DoctorPointerUncheckedCreateNestedManyWithoutDoctorInput
    uploadedScripts?: ScriptUncheckedCreateNestedManyWithoutUploadedByInput
    lockedScripts?: ScriptUncheckedCreateNestedManyWithoutLockedByInput
    assignedScripts?: ScriptUncheckedCreateNestedManyWithoutAssignedReviewerInput
    scriptReviews?: ScriptReviewUncheckedCreateNestedManyWithoutReviewerInput
    uploadedVideos?: VideoUncheckedCreateNestedManyWithoutUploadedByInput
    lockedVideos?: VideoUncheckedCreateNestedManyWithoutLockedByInput
    publishedVideos?: VideoUncheckedCreateNestedManyWithoutPublishedByInput
    videoReviews?: VideoReviewUncheckedCreateNestedManyWithoutReviewerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedVideosInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedVideosInput, UserUncheckedCreateWithoutAssignedVideosInput>
  }

  export type VideoReviewCreateWithoutVideoInput = {
    id?: string
    reviewerType: $Enums.UserRole
    decision?: $Enums.ReviewDecision
    comments?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    reviewer: UserCreateNestedOneWithoutVideoReviewsInput
  }

  export type VideoReviewUncheckedCreateWithoutVideoInput = {
    id?: string
    reviewerId: string
    reviewerType: $Enums.UserRole
    decision?: $Enums.ReviewDecision
    comments?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type VideoReviewCreateOrConnectWithoutVideoInput = {
    where: VideoReviewWhereUniqueInput
    create: XOR<VideoReviewCreateWithoutVideoInput, VideoReviewUncheckedCreateWithoutVideoInput>
  }

  export type VideoReviewCreateManyVideoInputEnvelope = {
    data: VideoReviewCreateManyVideoInput | VideoReviewCreateManyVideoInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutVideoInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    script?: ScriptCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutVideoInput = {
    id?: string
    scriptId?: string | null
    authorId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutVideoInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutVideoInput, CommentUncheckedCreateWithoutVideoInput>
  }

  export type CommentCreateManyVideoInputEnvelope = {
    data: CommentCreateManyVideoInput | CommentCreateManyVideoInput[]
    skipDuplicates?: boolean
  }

  export type VideoAnalyticsCreateWithoutVideoInput = {
    id?: string
    views?: number
    uniqueViews?: number
    avgWatchTime?: number
    ctr?: number
    quizStarted?: number
    quizCompleted?: number
    consultClicked?: number
    consultCompleted?: number
    hookRate3s?: number
    hookRate5s?: number
    updatedAt?: Date | string
  }

  export type VideoAnalyticsUncheckedCreateWithoutVideoInput = {
    id?: string
    views?: number
    uniqueViews?: number
    avgWatchTime?: number
    ctr?: number
    quizStarted?: number
    quizCompleted?: number
    consultClicked?: number
    consultCompleted?: number
    hookRate3s?: number
    hookRate5s?: number
    updatedAt?: Date | string
  }

  export type VideoAnalyticsCreateOrConnectWithoutVideoInput = {
    where: VideoAnalyticsWhereUniqueInput
    create: XOR<VideoAnalyticsCreateWithoutVideoInput, VideoAnalyticsUncheckedCreateWithoutVideoInput>
  }

  export type TopicUpsertWithoutVideosInput = {
    update: XOR<TopicUpdateWithoutVideosInput, TopicUncheckedUpdateWithoutVideosInput>
    create: XOR<TopicCreateWithoutVideosInput, TopicUncheckedCreateWithoutVideosInput>
    where?: TopicWhereInput
  }

  export type TopicUpdateToOneWithWhereWithoutVideosInput = {
    where?: TopicWhereInput
    data: XOR<TopicUpdateWithoutVideosInput, TopicUncheckedUpdateWithoutVideosInput>
  }

  export type TopicUpdateWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedDoctor?: UserUpdateOneRequiredWithoutAssignedTopicsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTopicsNestedInput
    doctorPointers?: DoctorPointerUpdateManyWithoutTopicNestedInput
    scripts?: ScriptUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    assignedDoctorId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorPointers?: DoctorPointerUncheckedUpdateManyWithoutTopicNestedInput
    scripts?: ScriptUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type ScriptUpsertWithoutVideosInput = {
    update: XOR<ScriptUpdateWithoutVideosInput, ScriptUncheckedUpdateWithoutVideosInput>
    create: XOR<ScriptCreateWithoutVideosInput, ScriptUncheckedCreateWithoutVideosInput>
    where?: ScriptWhereInput
  }

  export type ScriptUpdateToOneWithWhereWithoutVideosInput = {
    where?: ScriptWhereInput
    data: XOR<ScriptUpdateWithoutVideosInput, ScriptUncheckedUpdateWithoutVideosInput>
  }

  export type ScriptUpdateWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumScriptStatusFieldUpdateOperationsInput | $Enums.ScriptStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ScriptUpdatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: TopicUpdateOneRequiredWithoutScriptsNestedInput
    uploadedBy?: UserUpdateOneWithoutUploadedScriptsNestedInput
    lockedBy?: UserUpdateOneWithoutLockedScriptsNestedInput
    assignedReviewer?: UserUpdateOneWithoutAssignedScriptsNestedInput
    reviews?: ScriptReviewUpdateManyWithoutScriptNestedInput
    comments?: CommentUpdateManyWithoutScriptNestedInput
  }

  export type ScriptUncheckedUpdateWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumScriptStatusFieldUpdateOperationsInput | $Enums.ScriptStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ScriptUpdatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedReviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ScriptReviewUncheckedUpdateManyWithoutScriptNestedInput
    comments?: CommentUncheckedUpdateManyWithoutScriptNestedInput
  }

  export type UserUpsertWithoutUploadedVideosInput = {
    update: XOR<UserUpdateWithoutUploadedVideosInput, UserUncheckedUpdateWithoutUploadedVideosInput>
    create: XOR<UserCreateWithoutUploadedVideosInput, UserUncheckedCreateWithoutUploadedVideosInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadedVideosInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadedVideosInput, UserUncheckedUpdateWithoutUploadedVideosInput>
  }

  export type UserUpdateWithoutUploadedVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTopics?: TopicUpdateManyWithoutAssignedDoctorNestedInput
    createdTopics?: TopicUpdateManyWithoutCreatedByNestedInput
    doctorPointers?: DoctorPointerUpdateManyWithoutDoctorNestedInput
    uploadedScripts?: ScriptUpdateManyWithoutUploadedByNestedInput
    lockedScripts?: ScriptUpdateManyWithoutLockedByNestedInput
    assignedScripts?: ScriptUpdateManyWithoutAssignedReviewerNestedInput
    scriptReviews?: ScriptReviewUpdateManyWithoutReviewerNestedInput
    lockedVideos?: VideoUpdateManyWithoutLockedByNestedInput
    publishedVideos?: VideoUpdateManyWithoutPublishedByNestedInput
    assignedVideos?: VideoUpdateManyWithoutAssignedReviewerNestedInput
    videoReviews?: VideoReviewUpdateManyWithoutReviewerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadedVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTopics?: TopicUncheckedUpdateManyWithoutAssignedDoctorNestedInput
    createdTopics?: TopicUncheckedUpdateManyWithoutCreatedByNestedInput
    doctorPointers?: DoctorPointerUncheckedUpdateManyWithoutDoctorNestedInput
    uploadedScripts?: ScriptUncheckedUpdateManyWithoutUploadedByNestedInput
    lockedScripts?: ScriptUncheckedUpdateManyWithoutLockedByNestedInput
    assignedScripts?: ScriptUncheckedUpdateManyWithoutAssignedReviewerNestedInput
    scriptReviews?: ScriptReviewUncheckedUpdateManyWithoutReviewerNestedInput
    lockedVideos?: VideoUncheckedUpdateManyWithoutLockedByNestedInput
    publishedVideos?: VideoUncheckedUpdateManyWithoutPublishedByNestedInput
    assignedVideos?: VideoUncheckedUpdateManyWithoutAssignedReviewerNestedInput
    videoReviews?: VideoReviewUncheckedUpdateManyWithoutReviewerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutLockedVideosInput = {
    update: XOR<UserUpdateWithoutLockedVideosInput, UserUncheckedUpdateWithoutLockedVideosInput>
    create: XOR<UserCreateWithoutLockedVideosInput, UserUncheckedCreateWithoutLockedVideosInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLockedVideosInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLockedVideosInput, UserUncheckedUpdateWithoutLockedVideosInput>
  }

  export type UserUpdateWithoutLockedVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTopics?: TopicUpdateManyWithoutAssignedDoctorNestedInput
    createdTopics?: TopicUpdateManyWithoutCreatedByNestedInput
    doctorPointers?: DoctorPointerUpdateManyWithoutDoctorNestedInput
    uploadedScripts?: ScriptUpdateManyWithoutUploadedByNestedInput
    lockedScripts?: ScriptUpdateManyWithoutLockedByNestedInput
    assignedScripts?: ScriptUpdateManyWithoutAssignedReviewerNestedInput
    scriptReviews?: ScriptReviewUpdateManyWithoutReviewerNestedInput
    uploadedVideos?: VideoUpdateManyWithoutUploadedByNestedInput
    publishedVideos?: VideoUpdateManyWithoutPublishedByNestedInput
    assignedVideos?: VideoUpdateManyWithoutAssignedReviewerNestedInput
    videoReviews?: VideoReviewUpdateManyWithoutReviewerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLockedVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTopics?: TopicUncheckedUpdateManyWithoutAssignedDoctorNestedInput
    createdTopics?: TopicUncheckedUpdateManyWithoutCreatedByNestedInput
    doctorPointers?: DoctorPointerUncheckedUpdateManyWithoutDoctorNestedInput
    uploadedScripts?: ScriptUncheckedUpdateManyWithoutUploadedByNestedInput
    lockedScripts?: ScriptUncheckedUpdateManyWithoutLockedByNestedInput
    assignedScripts?: ScriptUncheckedUpdateManyWithoutAssignedReviewerNestedInput
    scriptReviews?: ScriptReviewUncheckedUpdateManyWithoutReviewerNestedInput
    uploadedVideos?: VideoUncheckedUpdateManyWithoutUploadedByNestedInput
    publishedVideos?: VideoUncheckedUpdateManyWithoutPublishedByNestedInput
    assignedVideos?: VideoUncheckedUpdateManyWithoutAssignedReviewerNestedInput
    videoReviews?: VideoReviewUncheckedUpdateManyWithoutReviewerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutPublishedVideosInput = {
    update: XOR<UserUpdateWithoutPublishedVideosInput, UserUncheckedUpdateWithoutPublishedVideosInput>
    create: XOR<UserCreateWithoutPublishedVideosInput, UserUncheckedCreateWithoutPublishedVideosInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPublishedVideosInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPublishedVideosInput, UserUncheckedUpdateWithoutPublishedVideosInput>
  }

  export type UserUpdateWithoutPublishedVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTopics?: TopicUpdateManyWithoutAssignedDoctorNestedInput
    createdTopics?: TopicUpdateManyWithoutCreatedByNestedInput
    doctorPointers?: DoctorPointerUpdateManyWithoutDoctorNestedInput
    uploadedScripts?: ScriptUpdateManyWithoutUploadedByNestedInput
    lockedScripts?: ScriptUpdateManyWithoutLockedByNestedInput
    assignedScripts?: ScriptUpdateManyWithoutAssignedReviewerNestedInput
    scriptReviews?: ScriptReviewUpdateManyWithoutReviewerNestedInput
    uploadedVideos?: VideoUpdateManyWithoutUploadedByNestedInput
    lockedVideos?: VideoUpdateManyWithoutLockedByNestedInput
    assignedVideos?: VideoUpdateManyWithoutAssignedReviewerNestedInput
    videoReviews?: VideoReviewUpdateManyWithoutReviewerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPublishedVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTopics?: TopicUncheckedUpdateManyWithoutAssignedDoctorNestedInput
    createdTopics?: TopicUncheckedUpdateManyWithoutCreatedByNestedInput
    doctorPointers?: DoctorPointerUncheckedUpdateManyWithoutDoctorNestedInput
    uploadedScripts?: ScriptUncheckedUpdateManyWithoutUploadedByNestedInput
    lockedScripts?: ScriptUncheckedUpdateManyWithoutLockedByNestedInput
    assignedScripts?: ScriptUncheckedUpdateManyWithoutAssignedReviewerNestedInput
    scriptReviews?: ScriptReviewUncheckedUpdateManyWithoutReviewerNestedInput
    uploadedVideos?: VideoUncheckedUpdateManyWithoutUploadedByNestedInput
    lockedVideos?: VideoUncheckedUpdateManyWithoutLockedByNestedInput
    assignedVideos?: VideoUncheckedUpdateManyWithoutAssignedReviewerNestedInput
    videoReviews?: VideoReviewUncheckedUpdateManyWithoutReviewerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutAssignedVideosInput = {
    update: XOR<UserUpdateWithoutAssignedVideosInput, UserUncheckedUpdateWithoutAssignedVideosInput>
    create: XOR<UserCreateWithoutAssignedVideosInput, UserUncheckedCreateWithoutAssignedVideosInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedVideosInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedVideosInput, UserUncheckedUpdateWithoutAssignedVideosInput>
  }

  export type UserUpdateWithoutAssignedVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTopics?: TopicUpdateManyWithoutAssignedDoctorNestedInput
    createdTopics?: TopicUpdateManyWithoutCreatedByNestedInput
    doctorPointers?: DoctorPointerUpdateManyWithoutDoctorNestedInput
    uploadedScripts?: ScriptUpdateManyWithoutUploadedByNestedInput
    lockedScripts?: ScriptUpdateManyWithoutLockedByNestedInput
    assignedScripts?: ScriptUpdateManyWithoutAssignedReviewerNestedInput
    scriptReviews?: ScriptReviewUpdateManyWithoutReviewerNestedInput
    uploadedVideos?: VideoUpdateManyWithoutUploadedByNestedInput
    lockedVideos?: VideoUpdateManyWithoutLockedByNestedInput
    publishedVideos?: VideoUpdateManyWithoutPublishedByNestedInput
    videoReviews?: VideoReviewUpdateManyWithoutReviewerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTopics?: TopicUncheckedUpdateManyWithoutAssignedDoctorNestedInput
    createdTopics?: TopicUncheckedUpdateManyWithoutCreatedByNestedInput
    doctorPointers?: DoctorPointerUncheckedUpdateManyWithoutDoctorNestedInput
    uploadedScripts?: ScriptUncheckedUpdateManyWithoutUploadedByNestedInput
    lockedScripts?: ScriptUncheckedUpdateManyWithoutLockedByNestedInput
    assignedScripts?: ScriptUncheckedUpdateManyWithoutAssignedReviewerNestedInput
    scriptReviews?: ScriptReviewUncheckedUpdateManyWithoutReviewerNestedInput
    uploadedVideos?: VideoUncheckedUpdateManyWithoutUploadedByNestedInput
    lockedVideos?: VideoUncheckedUpdateManyWithoutLockedByNestedInput
    publishedVideos?: VideoUncheckedUpdateManyWithoutPublishedByNestedInput
    videoReviews?: VideoReviewUncheckedUpdateManyWithoutReviewerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VideoReviewUpsertWithWhereUniqueWithoutVideoInput = {
    where: VideoReviewWhereUniqueInput
    update: XOR<VideoReviewUpdateWithoutVideoInput, VideoReviewUncheckedUpdateWithoutVideoInput>
    create: XOR<VideoReviewCreateWithoutVideoInput, VideoReviewUncheckedCreateWithoutVideoInput>
  }

  export type VideoReviewUpdateWithWhereUniqueWithoutVideoInput = {
    where: VideoReviewWhereUniqueInput
    data: XOR<VideoReviewUpdateWithoutVideoInput, VideoReviewUncheckedUpdateWithoutVideoInput>
  }

  export type VideoReviewUpdateManyWithWhereWithoutVideoInput = {
    where: VideoReviewScalarWhereInput
    data: XOR<VideoReviewUpdateManyMutationInput, VideoReviewUncheckedUpdateManyWithoutVideoInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutVideoInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutVideoInput, CommentUncheckedUpdateWithoutVideoInput>
    create: XOR<CommentCreateWithoutVideoInput, CommentUncheckedCreateWithoutVideoInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutVideoInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutVideoInput, CommentUncheckedUpdateWithoutVideoInput>
  }

  export type CommentUpdateManyWithWhereWithoutVideoInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutVideoInput>
  }

  export type VideoAnalyticsUpsertWithoutVideoInput = {
    update: XOR<VideoAnalyticsUpdateWithoutVideoInput, VideoAnalyticsUncheckedUpdateWithoutVideoInput>
    create: XOR<VideoAnalyticsCreateWithoutVideoInput, VideoAnalyticsUncheckedCreateWithoutVideoInput>
    where?: VideoAnalyticsWhereInput
  }

  export type VideoAnalyticsUpdateToOneWithWhereWithoutVideoInput = {
    where?: VideoAnalyticsWhereInput
    data: XOR<VideoAnalyticsUpdateWithoutVideoInput, VideoAnalyticsUncheckedUpdateWithoutVideoInput>
  }

  export type VideoAnalyticsUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    uniqueViews?: IntFieldUpdateOperationsInput | number
    avgWatchTime?: FloatFieldUpdateOperationsInput | number
    ctr?: FloatFieldUpdateOperationsInput | number
    quizStarted?: IntFieldUpdateOperationsInput | number
    quizCompleted?: IntFieldUpdateOperationsInput | number
    consultClicked?: IntFieldUpdateOperationsInput | number
    consultCompleted?: IntFieldUpdateOperationsInput | number
    hookRate3s?: FloatFieldUpdateOperationsInput | number
    hookRate5s?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoAnalyticsUncheckedUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    uniqueViews?: IntFieldUpdateOperationsInput | number
    avgWatchTime?: FloatFieldUpdateOperationsInput | number
    ctr?: FloatFieldUpdateOperationsInput | number
    quizStarted?: IntFieldUpdateOperationsInput | number
    quizCompleted?: IntFieldUpdateOperationsInput | number
    consultClicked?: IntFieldUpdateOperationsInput | number
    consultCompleted?: IntFieldUpdateOperationsInput | number
    hookRate3s?: FloatFieldUpdateOperationsInput | number
    hookRate5s?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCreateWithoutReviewsInput = {
    id?: string
    title: string
    description?: string | null
    videoUrl: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: bigint | number | null
    doctorName: string
    specialty: string
    language: string
    city: string
    ctaType: $Enums.CTAType
    tags?: VideoCreatetagsInput | string[]
    transcript?: string | null
    transcriptUrl?: string | null
    summary?: string | null
    shortSummary?: string | null
    keyTakeaways?: VideoCreatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    relatedVideoIds?: VideoCreaterelatedVideoIdsInput | string[]
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    status?: $Enums.VideoStatus
    version?: number
    lockedAt?: Date | string | null
    publishedAt?: Date | string | null
    assignedAt?: Date | string | null
    deepLink?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    topic: TopicCreateNestedOneWithoutVideosInput
    script?: ScriptCreateNestedOneWithoutVideosInput
    uploadedBy?: UserCreateNestedOneWithoutUploadedVideosInput
    lockedBy?: UserCreateNestedOneWithoutLockedVideosInput
    publishedBy?: UserCreateNestedOneWithoutPublishedVideosInput
    assignedReviewer?: UserCreateNestedOneWithoutAssignedVideosInput
    comments?: CommentCreateNestedManyWithoutVideoInput
    analytics?: VideoAnalyticsCreateNestedOneWithoutVideoInput
  }

  export type VideoUncheckedCreateWithoutReviewsInput = {
    id?: string
    topicId: string
    scriptId?: string | null
    title: string
    description?: string | null
    videoUrl: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: bigint | number | null
    doctorName: string
    specialty: string
    language: string
    city: string
    ctaType: $Enums.CTAType
    tags?: VideoCreatetagsInput | string[]
    transcript?: string | null
    transcriptUrl?: string | null
    summary?: string | null
    shortSummary?: string | null
    keyTakeaways?: VideoCreatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    relatedVideoIds?: VideoCreaterelatedVideoIdsInput | string[]
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    status?: $Enums.VideoStatus
    version?: number
    uploadedById?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    publishedById?: string | null
    publishedAt?: Date | string | null
    assignedReviewerId?: string | null
    assignedAt?: Date | string | null
    deepLink?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutVideoInput
    analytics?: VideoAnalyticsUncheckedCreateNestedOneWithoutVideoInput
  }

  export type VideoCreateOrConnectWithoutReviewsInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutReviewsInput, VideoUncheckedCreateWithoutReviewsInput>
  }

  export type UserCreateWithoutVideoReviewsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    assignedTopics?: TopicCreateNestedManyWithoutAssignedDoctorInput
    createdTopics?: TopicCreateNestedManyWithoutCreatedByInput
    doctorPointers?: DoctorPointerCreateNestedManyWithoutDoctorInput
    uploadedScripts?: ScriptCreateNestedManyWithoutUploadedByInput
    lockedScripts?: ScriptCreateNestedManyWithoutLockedByInput
    assignedScripts?: ScriptCreateNestedManyWithoutAssignedReviewerInput
    scriptReviews?: ScriptReviewCreateNestedManyWithoutReviewerInput
    uploadedVideos?: VideoCreateNestedManyWithoutUploadedByInput
    lockedVideos?: VideoCreateNestedManyWithoutLockedByInput
    publishedVideos?: VideoCreateNestedManyWithoutPublishedByInput
    assignedVideos?: VideoCreateNestedManyWithoutAssignedReviewerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVideoReviewsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    assignedTopics?: TopicUncheckedCreateNestedManyWithoutAssignedDoctorInput
    createdTopics?: TopicUncheckedCreateNestedManyWithoutCreatedByInput
    doctorPointers?: DoctorPointerUncheckedCreateNestedManyWithoutDoctorInput
    uploadedScripts?: ScriptUncheckedCreateNestedManyWithoutUploadedByInput
    lockedScripts?: ScriptUncheckedCreateNestedManyWithoutLockedByInput
    assignedScripts?: ScriptUncheckedCreateNestedManyWithoutAssignedReviewerInput
    scriptReviews?: ScriptReviewUncheckedCreateNestedManyWithoutReviewerInput
    uploadedVideos?: VideoUncheckedCreateNestedManyWithoutUploadedByInput
    lockedVideos?: VideoUncheckedCreateNestedManyWithoutLockedByInput
    publishedVideos?: VideoUncheckedCreateNestedManyWithoutPublishedByInput
    assignedVideos?: VideoUncheckedCreateNestedManyWithoutAssignedReviewerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVideoReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVideoReviewsInput, UserUncheckedCreateWithoutVideoReviewsInput>
  }

  export type VideoUpsertWithoutReviewsInput = {
    update: XOR<VideoUpdateWithoutReviewsInput, VideoUncheckedUpdateWithoutReviewsInput>
    create: XOR<VideoCreateWithoutReviewsInput, VideoUncheckedCreateWithoutReviewsInput>
    where?: VideoWhereInput
  }

  export type VideoUpdateToOneWithWhereWithoutReviewsInput = {
    where?: VideoWhereInput
    data: XOR<VideoUpdateWithoutReviewsInput, VideoUncheckedUpdateWithoutReviewsInput>
  }

  export type VideoUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    doctorName?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    ctaType?: EnumCTATypeFieldUpdateOperationsInput | $Enums.CTAType
    tags?: VideoUpdatetagsInput | string[]
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    shortSummary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: VideoUpdatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relatedVideoIds?: VideoUpdaterelatedVideoIdsInput | string[]
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    version?: IntFieldUpdateOperationsInput | number
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: TopicUpdateOneRequiredWithoutVideosNestedInput
    script?: ScriptUpdateOneWithoutVideosNestedInput
    uploadedBy?: UserUpdateOneWithoutUploadedVideosNestedInput
    lockedBy?: UserUpdateOneWithoutLockedVideosNestedInput
    publishedBy?: UserUpdateOneWithoutPublishedVideosNestedInput
    assignedReviewer?: UserUpdateOneWithoutAssignedVideosNestedInput
    comments?: CommentUpdateManyWithoutVideoNestedInput
    analytics?: VideoAnalyticsUpdateOneWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    scriptId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    doctorName?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    ctaType?: EnumCTATypeFieldUpdateOperationsInput | $Enums.CTAType
    tags?: VideoUpdatetagsInput | string[]
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    shortSummary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: VideoUpdatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relatedVideoIds?: VideoUpdaterelatedVideoIdsInput | string[]
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    version?: IntFieldUpdateOperationsInput | number
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedById?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedReviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutVideoNestedInput
    analytics?: VideoAnalyticsUncheckedUpdateOneWithoutVideoNestedInput
  }

  export type UserUpsertWithoutVideoReviewsInput = {
    update: XOR<UserUpdateWithoutVideoReviewsInput, UserUncheckedUpdateWithoutVideoReviewsInput>
    create: XOR<UserCreateWithoutVideoReviewsInput, UserUncheckedCreateWithoutVideoReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVideoReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVideoReviewsInput, UserUncheckedUpdateWithoutVideoReviewsInput>
  }

  export type UserUpdateWithoutVideoReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTopics?: TopicUpdateManyWithoutAssignedDoctorNestedInput
    createdTopics?: TopicUpdateManyWithoutCreatedByNestedInput
    doctorPointers?: DoctorPointerUpdateManyWithoutDoctorNestedInput
    uploadedScripts?: ScriptUpdateManyWithoutUploadedByNestedInput
    lockedScripts?: ScriptUpdateManyWithoutLockedByNestedInput
    assignedScripts?: ScriptUpdateManyWithoutAssignedReviewerNestedInput
    scriptReviews?: ScriptReviewUpdateManyWithoutReviewerNestedInput
    uploadedVideos?: VideoUpdateManyWithoutUploadedByNestedInput
    lockedVideos?: VideoUpdateManyWithoutLockedByNestedInput
    publishedVideos?: VideoUpdateManyWithoutPublishedByNestedInput
    assignedVideos?: VideoUpdateManyWithoutAssignedReviewerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVideoReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTopics?: TopicUncheckedUpdateManyWithoutAssignedDoctorNestedInput
    createdTopics?: TopicUncheckedUpdateManyWithoutCreatedByNestedInput
    doctorPointers?: DoctorPointerUncheckedUpdateManyWithoutDoctorNestedInput
    uploadedScripts?: ScriptUncheckedUpdateManyWithoutUploadedByNestedInput
    lockedScripts?: ScriptUncheckedUpdateManyWithoutLockedByNestedInput
    assignedScripts?: ScriptUncheckedUpdateManyWithoutAssignedReviewerNestedInput
    scriptReviews?: ScriptReviewUncheckedUpdateManyWithoutReviewerNestedInput
    uploadedVideos?: VideoUncheckedUpdateManyWithoutUploadedByNestedInput
    lockedVideos?: VideoUncheckedUpdateManyWithoutLockedByNestedInput
    publishedVideos?: VideoUncheckedUpdateManyWithoutPublishedByNestedInput
    assignedVideos?: VideoUncheckedUpdateManyWithoutAssignedReviewerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ScriptCreateWithoutCommentsInput = {
    id?: string
    version?: number
    content: string
    status?: $Enums.ScriptStatus
    summary?: string | null
    tags?: ScriptCreatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    lockedAt?: Date | string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    topic: TopicCreateNestedOneWithoutScriptsInput
    uploadedBy?: UserCreateNestedOneWithoutUploadedScriptsInput
    lockedBy?: UserCreateNestedOneWithoutLockedScriptsInput
    assignedReviewer?: UserCreateNestedOneWithoutAssignedScriptsInput
    reviews?: ScriptReviewCreateNestedManyWithoutScriptInput
    videos?: VideoCreateNestedManyWithoutScriptInput
  }

  export type ScriptUncheckedCreateWithoutCommentsInput = {
    id?: string
    topicId: string
    version?: number
    content: string
    status?: $Enums.ScriptStatus
    summary?: string | null
    tags?: ScriptCreatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    uploadedById?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    assignedReviewerId?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ScriptReviewUncheckedCreateNestedManyWithoutScriptInput
    videos?: VideoUncheckedCreateNestedManyWithoutScriptInput
  }

  export type ScriptCreateOrConnectWithoutCommentsInput = {
    where: ScriptWhereUniqueInput
    create: XOR<ScriptCreateWithoutCommentsInput, ScriptUncheckedCreateWithoutCommentsInput>
  }

  export type VideoCreateWithoutCommentsInput = {
    id?: string
    title: string
    description?: string | null
    videoUrl: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: bigint | number | null
    doctorName: string
    specialty: string
    language: string
    city: string
    ctaType: $Enums.CTAType
    tags?: VideoCreatetagsInput | string[]
    transcript?: string | null
    transcriptUrl?: string | null
    summary?: string | null
    shortSummary?: string | null
    keyTakeaways?: VideoCreatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    relatedVideoIds?: VideoCreaterelatedVideoIdsInput | string[]
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    status?: $Enums.VideoStatus
    version?: number
    lockedAt?: Date | string | null
    publishedAt?: Date | string | null
    assignedAt?: Date | string | null
    deepLink?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    topic: TopicCreateNestedOneWithoutVideosInput
    script?: ScriptCreateNestedOneWithoutVideosInput
    uploadedBy?: UserCreateNestedOneWithoutUploadedVideosInput
    lockedBy?: UserCreateNestedOneWithoutLockedVideosInput
    publishedBy?: UserCreateNestedOneWithoutPublishedVideosInput
    assignedReviewer?: UserCreateNestedOneWithoutAssignedVideosInput
    reviews?: VideoReviewCreateNestedManyWithoutVideoInput
    analytics?: VideoAnalyticsCreateNestedOneWithoutVideoInput
  }

  export type VideoUncheckedCreateWithoutCommentsInput = {
    id?: string
    topicId: string
    scriptId?: string | null
    title: string
    description?: string | null
    videoUrl: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: bigint | number | null
    doctorName: string
    specialty: string
    language: string
    city: string
    ctaType: $Enums.CTAType
    tags?: VideoCreatetagsInput | string[]
    transcript?: string | null
    transcriptUrl?: string | null
    summary?: string | null
    shortSummary?: string | null
    keyTakeaways?: VideoCreatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    relatedVideoIds?: VideoCreaterelatedVideoIdsInput | string[]
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    status?: $Enums.VideoStatus
    version?: number
    uploadedById?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    publishedById?: string | null
    publishedAt?: Date | string | null
    assignedReviewerId?: string | null
    assignedAt?: Date | string | null
    deepLink?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: VideoReviewUncheckedCreateNestedManyWithoutVideoInput
    analytics?: VideoAnalyticsUncheckedCreateNestedOneWithoutVideoInput
  }

  export type VideoCreateOrConnectWithoutCommentsInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutCommentsInput, VideoUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    assignedTopics?: TopicCreateNestedManyWithoutAssignedDoctorInput
    createdTopics?: TopicCreateNestedManyWithoutCreatedByInput
    doctorPointers?: DoctorPointerCreateNestedManyWithoutDoctorInput
    uploadedScripts?: ScriptCreateNestedManyWithoutUploadedByInput
    lockedScripts?: ScriptCreateNestedManyWithoutLockedByInput
    assignedScripts?: ScriptCreateNestedManyWithoutAssignedReviewerInput
    scriptReviews?: ScriptReviewCreateNestedManyWithoutReviewerInput
    uploadedVideos?: VideoCreateNestedManyWithoutUploadedByInput
    lockedVideos?: VideoCreateNestedManyWithoutLockedByInput
    publishedVideos?: VideoCreateNestedManyWithoutPublishedByInput
    assignedVideos?: VideoCreateNestedManyWithoutAssignedReviewerInput
    videoReviews?: VideoReviewCreateNestedManyWithoutReviewerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    assignedTopics?: TopicUncheckedCreateNestedManyWithoutAssignedDoctorInput
    createdTopics?: TopicUncheckedCreateNestedManyWithoutCreatedByInput
    doctorPointers?: DoctorPointerUncheckedCreateNestedManyWithoutDoctorInput
    uploadedScripts?: ScriptUncheckedCreateNestedManyWithoutUploadedByInput
    lockedScripts?: ScriptUncheckedCreateNestedManyWithoutLockedByInput
    assignedScripts?: ScriptUncheckedCreateNestedManyWithoutAssignedReviewerInput
    scriptReviews?: ScriptReviewUncheckedCreateNestedManyWithoutReviewerInput
    uploadedVideos?: VideoUncheckedCreateNestedManyWithoutUploadedByInput
    lockedVideos?: VideoUncheckedCreateNestedManyWithoutLockedByInput
    publishedVideos?: VideoUncheckedCreateNestedManyWithoutPublishedByInput
    assignedVideos?: VideoUncheckedCreateNestedManyWithoutAssignedReviewerInput
    videoReviews?: VideoReviewUncheckedCreateNestedManyWithoutReviewerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type ScriptUpsertWithoutCommentsInput = {
    update: XOR<ScriptUpdateWithoutCommentsInput, ScriptUncheckedUpdateWithoutCommentsInput>
    create: XOR<ScriptCreateWithoutCommentsInput, ScriptUncheckedCreateWithoutCommentsInput>
    where?: ScriptWhereInput
  }

  export type ScriptUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ScriptWhereInput
    data: XOR<ScriptUpdateWithoutCommentsInput, ScriptUncheckedUpdateWithoutCommentsInput>
  }

  export type ScriptUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumScriptStatusFieldUpdateOperationsInput | $Enums.ScriptStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ScriptUpdatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: TopicUpdateOneRequiredWithoutScriptsNestedInput
    uploadedBy?: UserUpdateOneWithoutUploadedScriptsNestedInput
    lockedBy?: UserUpdateOneWithoutLockedScriptsNestedInput
    assignedReviewer?: UserUpdateOneWithoutAssignedScriptsNestedInput
    reviews?: ScriptReviewUpdateManyWithoutScriptNestedInput
    videos?: VideoUpdateManyWithoutScriptNestedInput
  }

  export type ScriptUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumScriptStatusFieldUpdateOperationsInput | $Enums.ScriptStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ScriptUpdatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedReviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ScriptReviewUncheckedUpdateManyWithoutScriptNestedInput
    videos?: VideoUncheckedUpdateManyWithoutScriptNestedInput
  }

  export type VideoUpsertWithoutCommentsInput = {
    update: XOR<VideoUpdateWithoutCommentsInput, VideoUncheckedUpdateWithoutCommentsInput>
    create: XOR<VideoCreateWithoutCommentsInput, VideoUncheckedCreateWithoutCommentsInput>
    where?: VideoWhereInput
  }

  export type VideoUpdateToOneWithWhereWithoutCommentsInput = {
    where?: VideoWhereInput
    data: XOR<VideoUpdateWithoutCommentsInput, VideoUncheckedUpdateWithoutCommentsInput>
  }

  export type VideoUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    doctorName?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    ctaType?: EnumCTATypeFieldUpdateOperationsInput | $Enums.CTAType
    tags?: VideoUpdatetagsInput | string[]
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    shortSummary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: VideoUpdatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relatedVideoIds?: VideoUpdaterelatedVideoIdsInput | string[]
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    version?: IntFieldUpdateOperationsInput | number
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: TopicUpdateOneRequiredWithoutVideosNestedInput
    script?: ScriptUpdateOneWithoutVideosNestedInput
    uploadedBy?: UserUpdateOneWithoutUploadedVideosNestedInput
    lockedBy?: UserUpdateOneWithoutLockedVideosNestedInput
    publishedBy?: UserUpdateOneWithoutPublishedVideosNestedInput
    assignedReviewer?: UserUpdateOneWithoutAssignedVideosNestedInput
    reviews?: VideoReviewUpdateManyWithoutVideoNestedInput
    analytics?: VideoAnalyticsUpdateOneWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    scriptId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    doctorName?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    ctaType?: EnumCTATypeFieldUpdateOperationsInput | $Enums.CTAType
    tags?: VideoUpdatetagsInput | string[]
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    shortSummary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: VideoUpdatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relatedVideoIds?: VideoUpdaterelatedVideoIdsInput | string[]
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    version?: IntFieldUpdateOperationsInput | number
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedById?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedReviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: VideoReviewUncheckedUpdateManyWithoutVideoNestedInput
    analytics?: VideoAnalyticsUncheckedUpdateOneWithoutVideoNestedInput
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTopics?: TopicUpdateManyWithoutAssignedDoctorNestedInput
    createdTopics?: TopicUpdateManyWithoutCreatedByNestedInput
    doctorPointers?: DoctorPointerUpdateManyWithoutDoctorNestedInput
    uploadedScripts?: ScriptUpdateManyWithoutUploadedByNestedInput
    lockedScripts?: ScriptUpdateManyWithoutLockedByNestedInput
    assignedScripts?: ScriptUpdateManyWithoutAssignedReviewerNestedInput
    scriptReviews?: ScriptReviewUpdateManyWithoutReviewerNestedInput
    uploadedVideos?: VideoUpdateManyWithoutUploadedByNestedInput
    lockedVideos?: VideoUpdateManyWithoutLockedByNestedInput
    publishedVideos?: VideoUpdateManyWithoutPublishedByNestedInput
    assignedVideos?: VideoUpdateManyWithoutAssignedReviewerNestedInput
    videoReviews?: VideoReviewUpdateManyWithoutReviewerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTopics?: TopicUncheckedUpdateManyWithoutAssignedDoctorNestedInput
    createdTopics?: TopicUncheckedUpdateManyWithoutCreatedByNestedInput
    doctorPointers?: DoctorPointerUncheckedUpdateManyWithoutDoctorNestedInput
    uploadedScripts?: ScriptUncheckedUpdateManyWithoutUploadedByNestedInput
    lockedScripts?: ScriptUncheckedUpdateManyWithoutLockedByNestedInput
    assignedScripts?: ScriptUncheckedUpdateManyWithoutAssignedReviewerNestedInput
    scriptReviews?: ScriptReviewUncheckedUpdateManyWithoutReviewerNestedInput
    uploadedVideos?: VideoUncheckedUpdateManyWithoutUploadedByNestedInput
    lockedVideos?: VideoUncheckedUpdateManyWithoutLockedByNestedInput
    publishedVideos?: VideoUncheckedUpdateManyWithoutPublishedByNestedInput
    assignedVideos?: VideoUncheckedUpdateManyWithoutAssignedReviewerNestedInput
    videoReviews?: VideoReviewUncheckedUpdateManyWithoutReviewerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    assignedTopics?: TopicCreateNestedManyWithoutAssignedDoctorInput
    createdTopics?: TopicCreateNestedManyWithoutCreatedByInput
    doctorPointers?: DoctorPointerCreateNestedManyWithoutDoctorInput
    uploadedScripts?: ScriptCreateNestedManyWithoutUploadedByInput
    lockedScripts?: ScriptCreateNestedManyWithoutLockedByInput
    assignedScripts?: ScriptCreateNestedManyWithoutAssignedReviewerInput
    scriptReviews?: ScriptReviewCreateNestedManyWithoutReviewerInput
    uploadedVideos?: VideoCreateNestedManyWithoutUploadedByInput
    lockedVideos?: VideoCreateNestedManyWithoutLockedByInput
    publishedVideos?: VideoCreateNestedManyWithoutPublishedByInput
    assignedVideos?: VideoCreateNestedManyWithoutAssignedReviewerInput
    videoReviews?: VideoReviewCreateNestedManyWithoutReviewerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    assignedTopics?: TopicUncheckedCreateNestedManyWithoutAssignedDoctorInput
    createdTopics?: TopicUncheckedCreateNestedManyWithoutCreatedByInput
    doctorPointers?: DoctorPointerUncheckedCreateNestedManyWithoutDoctorInput
    uploadedScripts?: ScriptUncheckedCreateNestedManyWithoutUploadedByInput
    lockedScripts?: ScriptUncheckedCreateNestedManyWithoutLockedByInput
    assignedScripts?: ScriptUncheckedCreateNestedManyWithoutAssignedReviewerInput
    scriptReviews?: ScriptReviewUncheckedCreateNestedManyWithoutReviewerInput
    uploadedVideos?: VideoUncheckedCreateNestedManyWithoutUploadedByInput
    lockedVideos?: VideoUncheckedCreateNestedManyWithoutLockedByInput
    publishedVideos?: VideoUncheckedCreateNestedManyWithoutPublishedByInput
    assignedVideos?: VideoUncheckedCreateNestedManyWithoutAssignedReviewerInput
    videoReviews?: VideoReviewUncheckedCreateNestedManyWithoutReviewerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTopics?: TopicUpdateManyWithoutAssignedDoctorNestedInput
    createdTopics?: TopicUpdateManyWithoutCreatedByNestedInput
    doctorPointers?: DoctorPointerUpdateManyWithoutDoctorNestedInput
    uploadedScripts?: ScriptUpdateManyWithoutUploadedByNestedInput
    lockedScripts?: ScriptUpdateManyWithoutLockedByNestedInput
    assignedScripts?: ScriptUpdateManyWithoutAssignedReviewerNestedInput
    scriptReviews?: ScriptReviewUpdateManyWithoutReviewerNestedInput
    uploadedVideos?: VideoUpdateManyWithoutUploadedByNestedInput
    lockedVideos?: VideoUpdateManyWithoutLockedByNestedInput
    publishedVideos?: VideoUpdateManyWithoutPublishedByNestedInput
    assignedVideos?: VideoUpdateManyWithoutAssignedReviewerNestedInput
    videoReviews?: VideoReviewUpdateManyWithoutReviewerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTopics?: TopicUncheckedUpdateManyWithoutAssignedDoctorNestedInput
    createdTopics?: TopicUncheckedUpdateManyWithoutCreatedByNestedInput
    doctorPointers?: DoctorPointerUncheckedUpdateManyWithoutDoctorNestedInput
    uploadedScripts?: ScriptUncheckedUpdateManyWithoutUploadedByNestedInput
    lockedScripts?: ScriptUncheckedUpdateManyWithoutLockedByNestedInput
    assignedScripts?: ScriptUncheckedUpdateManyWithoutAssignedReviewerNestedInput
    scriptReviews?: ScriptReviewUncheckedUpdateManyWithoutReviewerNestedInput
    uploadedVideos?: VideoUncheckedUpdateManyWithoutUploadedByNestedInput
    lockedVideos?: VideoUncheckedUpdateManyWithoutLockedByNestedInput
    publishedVideos?: VideoUncheckedUpdateManyWithoutPublishedByNestedInput
    assignedVideos?: VideoUncheckedUpdateManyWithoutAssignedReviewerNestedInput
    videoReviews?: VideoReviewUncheckedUpdateManyWithoutReviewerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    assignedTopics?: TopicCreateNestedManyWithoutAssignedDoctorInput
    createdTopics?: TopicCreateNestedManyWithoutCreatedByInput
    doctorPointers?: DoctorPointerCreateNestedManyWithoutDoctorInput
    uploadedScripts?: ScriptCreateNestedManyWithoutUploadedByInput
    lockedScripts?: ScriptCreateNestedManyWithoutLockedByInput
    assignedScripts?: ScriptCreateNestedManyWithoutAssignedReviewerInput
    scriptReviews?: ScriptReviewCreateNestedManyWithoutReviewerInput
    uploadedVideos?: VideoCreateNestedManyWithoutUploadedByInput
    lockedVideos?: VideoCreateNestedManyWithoutLockedByInput
    publishedVideos?: VideoCreateNestedManyWithoutPublishedByInput
    assignedVideos?: VideoCreateNestedManyWithoutAssignedReviewerInput
    videoReviews?: VideoReviewCreateNestedManyWithoutReviewerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    specialty?: string | null
    city?: string | null
    googleId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    assignedTopics?: TopicUncheckedCreateNestedManyWithoutAssignedDoctorInput
    createdTopics?: TopicUncheckedCreateNestedManyWithoutCreatedByInput
    doctorPointers?: DoctorPointerUncheckedCreateNestedManyWithoutDoctorInput
    uploadedScripts?: ScriptUncheckedCreateNestedManyWithoutUploadedByInput
    lockedScripts?: ScriptUncheckedCreateNestedManyWithoutLockedByInput
    assignedScripts?: ScriptUncheckedCreateNestedManyWithoutAssignedReviewerInput
    scriptReviews?: ScriptReviewUncheckedCreateNestedManyWithoutReviewerInput
    uploadedVideos?: VideoUncheckedCreateNestedManyWithoutUploadedByInput
    lockedVideos?: VideoUncheckedCreateNestedManyWithoutLockedByInput
    publishedVideos?: VideoUncheckedCreateNestedManyWithoutPublishedByInput
    assignedVideos?: VideoUncheckedCreateNestedManyWithoutAssignedReviewerInput
    videoReviews?: VideoReviewUncheckedCreateNestedManyWithoutReviewerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTopics?: TopicUpdateManyWithoutAssignedDoctorNestedInput
    createdTopics?: TopicUpdateManyWithoutCreatedByNestedInput
    doctorPointers?: DoctorPointerUpdateManyWithoutDoctorNestedInput
    uploadedScripts?: ScriptUpdateManyWithoutUploadedByNestedInput
    lockedScripts?: ScriptUpdateManyWithoutLockedByNestedInput
    assignedScripts?: ScriptUpdateManyWithoutAssignedReviewerNestedInput
    scriptReviews?: ScriptReviewUpdateManyWithoutReviewerNestedInput
    uploadedVideos?: VideoUpdateManyWithoutUploadedByNestedInput
    lockedVideos?: VideoUpdateManyWithoutLockedByNestedInput
    publishedVideos?: VideoUpdateManyWithoutPublishedByNestedInput
    assignedVideos?: VideoUpdateManyWithoutAssignedReviewerNestedInput
    videoReviews?: VideoReviewUpdateManyWithoutReviewerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTopics?: TopicUncheckedUpdateManyWithoutAssignedDoctorNestedInput
    createdTopics?: TopicUncheckedUpdateManyWithoutCreatedByNestedInput
    doctorPointers?: DoctorPointerUncheckedUpdateManyWithoutDoctorNestedInput
    uploadedScripts?: ScriptUncheckedUpdateManyWithoutUploadedByNestedInput
    lockedScripts?: ScriptUncheckedUpdateManyWithoutLockedByNestedInput
    assignedScripts?: ScriptUncheckedUpdateManyWithoutAssignedReviewerNestedInput
    scriptReviews?: ScriptReviewUncheckedUpdateManyWithoutReviewerNestedInput
    uploadedVideos?: VideoUncheckedUpdateManyWithoutUploadedByNestedInput
    lockedVideos?: VideoUncheckedUpdateManyWithoutLockedByNestedInput
    publishedVideos?: VideoUncheckedUpdateManyWithoutPublishedByNestedInput
    assignedVideos?: VideoUncheckedUpdateManyWithoutAssignedReviewerNestedInput
    videoReviews?: VideoReviewUncheckedUpdateManyWithoutReviewerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VideoCreateWithoutAnalyticsInput = {
    id?: string
    title: string
    description?: string | null
    videoUrl: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: bigint | number | null
    doctorName: string
    specialty: string
    language: string
    city: string
    ctaType: $Enums.CTAType
    tags?: VideoCreatetagsInput | string[]
    transcript?: string | null
    transcriptUrl?: string | null
    summary?: string | null
    shortSummary?: string | null
    keyTakeaways?: VideoCreatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    relatedVideoIds?: VideoCreaterelatedVideoIdsInput | string[]
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    status?: $Enums.VideoStatus
    version?: number
    lockedAt?: Date | string | null
    publishedAt?: Date | string | null
    assignedAt?: Date | string | null
    deepLink?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    topic: TopicCreateNestedOneWithoutVideosInput
    script?: ScriptCreateNestedOneWithoutVideosInput
    uploadedBy?: UserCreateNestedOneWithoutUploadedVideosInput
    lockedBy?: UserCreateNestedOneWithoutLockedVideosInput
    publishedBy?: UserCreateNestedOneWithoutPublishedVideosInput
    assignedReviewer?: UserCreateNestedOneWithoutAssignedVideosInput
    reviews?: VideoReviewCreateNestedManyWithoutVideoInput
    comments?: CommentCreateNestedManyWithoutVideoInput
  }

  export type VideoUncheckedCreateWithoutAnalyticsInput = {
    id?: string
    topicId: string
    scriptId?: string | null
    title: string
    description?: string | null
    videoUrl: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: bigint | number | null
    doctorName: string
    specialty: string
    language: string
    city: string
    ctaType: $Enums.CTAType
    tags?: VideoCreatetagsInput | string[]
    transcript?: string | null
    transcriptUrl?: string | null
    summary?: string | null
    shortSummary?: string | null
    keyTakeaways?: VideoCreatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    relatedVideoIds?: VideoCreaterelatedVideoIdsInput | string[]
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    status?: $Enums.VideoStatus
    version?: number
    uploadedById?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    publishedById?: string | null
    publishedAt?: Date | string | null
    assignedReviewerId?: string | null
    assignedAt?: Date | string | null
    deepLink?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: VideoReviewUncheckedCreateNestedManyWithoutVideoInput
    comments?: CommentUncheckedCreateNestedManyWithoutVideoInput
  }

  export type VideoCreateOrConnectWithoutAnalyticsInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutAnalyticsInput, VideoUncheckedCreateWithoutAnalyticsInput>
  }

  export type VideoUpsertWithoutAnalyticsInput = {
    update: XOR<VideoUpdateWithoutAnalyticsInput, VideoUncheckedUpdateWithoutAnalyticsInput>
    create: XOR<VideoCreateWithoutAnalyticsInput, VideoUncheckedCreateWithoutAnalyticsInput>
    where?: VideoWhereInput
  }

  export type VideoUpdateToOneWithWhereWithoutAnalyticsInput = {
    where?: VideoWhereInput
    data: XOR<VideoUpdateWithoutAnalyticsInput, VideoUncheckedUpdateWithoutAnalyticsInput>
  }

  export type VideoUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    doctorName?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    ctaType?: EnumCTATypeFieldUpdateOperationsInput | $Enums.CTAType
    tags?: VideoUpdatetagsInput | string[]
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    shortSummary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: VideoUpdatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relatedVideoIds?: VideoUpdaterelatedVideoIdsInput | string[]
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    version?: IntFieldUpdateOperationsInput | number
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: TopicUpdateOneRequiredWithoutVideosNestedInput
    script?: ScriptUpdateOneWithoutVideosNestedInput
    uploadedBy?: UserUpdateOneWithoutUploadedVideosNestedInput
    lockedBy?: UserUpdateOneWithoutLockedVideosNestedInput
    publishedBy?: UserUpdateOneWithoutPublishedVideosNestedInput
    assignedReviewer?: UserUpdateOneWithoutAssignedVideosNestedInput
    reviews?: VideoReviewUpdateManyWithoutVideoNestedInput
    comments?: CommentUpdateManyWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    scriptId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    doctorName?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    ctaType?: EnumCTATypeFieldUpdateOperationsInput | $Enums.CTAType
    tags?: VideoUpdatetagsInput | string[]
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    shortSummary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: VideoUpdatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relatedVideoIds?: VideoUpdaterelatedVideoIdsInput | string[]
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    version?: IntFieldUpdateOperationsInput | number
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedById?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedReviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: VideoReviewUncheckedUpdateManyWithoutVideoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type TopicCreateManyAssignedDoctorInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TopicStatus
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TopicCreateManyCreatedByInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TopicStatus
    assignedDoctorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DoctorPointerCreateManyDoctorInput = {
    id?: string
    topicId: string
    notes?: string | null
    fileUrl?: string | null
    fileType?: string | null
    createdAt?: Date | string
  }

  export type ScriptCreateManyUploadedByInput = {
    id?: string
    topicId: string
    version?: number
    content: string
    status?: $Enums.ScriptStatus
    summary?: string | null
    tags?: ScriptCreatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    assignedReviewerId?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScriptCreateManyLockedByInput = {
    id?: string
    topicId: string
    version?: number
    content: string
    status?: $Enums.ScriptStatus
    summary?: string | null
    tags?: ScriptCreatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    uploadedById?: string | null
    lockedAt?: Date | string | null
    assignedReviewerId?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScriptCreateManyAssignedReviewerInput = {
    id?: string
    topicId: string
    version?: number
    content: string
    status?: $Enums.ScriptStatus
    summary?: string | null
    tags?: ScriptCreatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    uploadedById?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScriptReviewCreateManyReviewerInput = {
    id?: string
    scriptId: string
    reviewerType: $Enums.UserRole
    decision?: $Enums.ReviewDecision
    comments?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type VideoCreateManyUploadedByInput = {
    id?: string
    topicId: string
    scriptId?: string | null
    title: string
    description?: string | null
    videoUrl: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: bigint | number | null
    doctorName: string
    specialty: string
    language: string
    city: string
    ctaType: $Enums.CTAType
    tags?: VideoCreatetagsInput | string[]
    transcript?: string | null
    transcriptUrl?: string | null
    summary?: string | null
    shortSummary?: string | null
    keyTakeaways?: VideoCreatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    relatedVideoIds?: VideoCreaterelatedVideoIdsInput | string[]
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    status?: $Enums.VideoStatus
    version?: number
    lockedById?: string | null
    lockedAt?: Date | string | null
    publishedById?: string | null
    publishedAt?: Date | string | null
    assignedReviewerId?: string | null
    assignedAt?: Date | string | null
    deepLink?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCreateManyLockedByInput = {
    id?: string
    topicId: string
    scriptId?: string | null
    title: string
    description?: string | null
    videoUrl: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: bigint | number | null
    doctorName: string
    specialty: string
    language: string
    city: string
    ctaType: $Enums.CTAType
    tags?: VideoCreatetagsInput | string[]
    transcript?: string | null
    transcriptUrl?: string | null
    summary?: string | null
    shortSummary?: string | null
    keyTakeaways?: VideoCreatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    relatedVideoIds?: VideoCreaterelatedVideoIdsInput | string[]
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    status?: $Enums.VideoStatus
    version?: number
    uploadedById?: string | null
    lockedAt?: Date | string | null
    publishedById?: string | null
    publishedAt?: Date | string | null
    assignedReviewerId?: string | null
    assignedAt?: Date | string | null
    deepLink?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCreateManyPublishedByInput = {
    id?: string
    topicId: string
    scriptId?: string | null
    title: string
    description?: string | null
    videoUrl: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: bigint | number | null
    doctorName: string
    specialty: string
    language: string
    city: string
    ctaType: $Enums.CTAType
    tags?: VideoCreatetagsInput | string[]
    transcript?: string | null
    transcriptUrl?: string | null
    summary?: string | null
    shortSummary?: string | null
    keyTakeaways?: VideoCreatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    relatedVideoIds?: VideoCreaterelatedVideoIdsInput | string[]
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    status?: $Enums.VideoStatus
    version?: number
    uploadedById?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    publishedAt?: Date | string | null
    assignedReviewerId?: string | null
    assignedAt?: Date | string | null
    deepLink?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCreateManyAssignedReviewerInput = {
    id?: string
    topicId: string
    scriptId?: string | null
    title: string
    description?: string | null
    videoUrl: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: bigint | number | null
    doctorName: string
    specialty: string
    language: string
    city: string
    ctaType: $Enums.CTAType
    tags?: VideoCreatetagsInput | string[]
    transcript?: string | null
    transcriptUrl?: string | null
    summary?: string | null
    shortSummary?: string | null
    keyTakeaways?: VideoCreatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    relatedVideoIds?: VideoCreaterelatedVideoIdsInput | string[]
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    status?: $Enums.VideoStatus
    version?: number
    uploadedById?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    publishedById?: string | null
    publishedAt?: Date | string | null
    assignedAt?: Date | string | null
    deepLink?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoReviewCreateManyReviewerInput = {
    id?: string
    videoId: string
    reviewerType: $Enums.UserRole
    decision?: $Enums.ReviewDecision
    comments?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type CommentCreateManyAuthorInput = {
    id?: string
    scriptId?: string | null
    videoId?: string | null
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type?: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type TopicUpdateWithoutAssignedDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedTopicsNestedInput
    doctorPointers?: DoctorPointerUpdateManyWithoutTopicNestedInput
    scripts?: ScriptUpdateManyWithoutTopicNestedInput
    videos?: VideoUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateWithoutAssignedDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorPointers?: DoctorPointerUncheckedUpdateManyWithoutTopicNestedInput
    scripts?: ScriptUncheckedUpdateManyWithoutTopicNestedInput
    videos?: VideoUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateManyWithoutAssignedDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedDoctor?: UserUpdateOneRequiredWithoutAssignedTopicsNestedInput
    doctorPointers?: DoctorPointerUpdateManyWithoutTopicNestedInput
    scripts?: ScriptUpdateManyWithoutTopicNestedInput
    videos?: VideoUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    assignedDoctorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorPointers?: DoctorPointerUncheckedUpdateManyWithoutTopicNestedInput
    scripts?: ScriptUncheckedUpdateManyWithoutTopicNestedInput
    videos?: VideoUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    assignedDoctorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorPointerUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: TopicUpdateOneRequiredWithoutDoctorPointersNestedInput
  }

  export type DoctorPointerUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorPointerUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScriptUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumScriptStatusFieldUpdateOperationsInput | $Enums.ScriptStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ScriptUpdatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: TopicUpdateOneRequiredWithoutScriptsNestedInput
    lockedBy?: UserUpdateOneWithoutLockedScriptsNestedInput
    assignedReviewer?: UserUpdateOneWithoutAssignedScriptsNestedInput
    reviews?: ScriptReviewUpdateManyWithoutScriptNestedInput
    comments?: CommentUpdateManyWithoutScriptNestedInput
    videos?: VideoUpdateManyWithoutScriptNestedInput
  }

  export type ScriptUncheckedUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumScriptStatusFieldUpdateOperationsInput | $Enums.ScriptStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ScriptUpdatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedReviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ScriptReviewUncheckedUpdateManyWithoutScriptNestedInput
    comments?: CommentUncheckedUpdateManyWithoutScriptNestedInput
    videos?: VideoUncheckedUpdateManyWithoutScriptNestedInput
  }

  export type ScriptUncheckedUpdateManyWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumScriptStatusFieldUpdateOperationsInput | $Enums.ScriptStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ScriptUpdatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedReviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScriptUpdateWithoutLockedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumScriptStatusFieldUpdateOperationsInput | $Enums.ScriptStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ScriptUpdatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: TopicUpdateOneRequiredWithoutScriptsNestedInput
    uploadedBy?: UserUpdateOneWithoutUploadedScriptsNestedInput
    assignedReviewer?: UserUpdateOneWithoutAssignedScriptsNestedInput
    reviews?: ScriptReviewUpdateManyWithoutScriptNestedInput
    comments?: CommentUpdateManyWithoutScriptNestedInput
    videos?: VideoUpdateManyWithoutScriptNestedInput
  }

  export type ScriptUncheckedUpdateWithoutLockedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumScriptStatusFieldUpdateOperationsInput | $Enums.ScriptStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ScriptUpdatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedReviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ScriptReviewUncheckedUpdateManyWithoutScriptNestedInput
    comments?: CommentUncheckedUpdateManyWithoutScriptNestedInput
    videos?: VideoUncheckedUpdateManyWithoutScriptNestedInput
  }

  export type ScriptUncheckedUpdateManyWithoutLockedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumScriptStatusFieldUpdateOperationsInput | $Enums.ScriptStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ScriptUpdatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedReviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScriptUpdateWithoutAssignedReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumScriptStatusFieldUpdateOperationsInput | $Enums.ScriptStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ScriptUpdatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: TopicUpdateOneRequiredWithoutScriptsNestedInput
    uploadedBy?: UserUpdateOneWithoutUploadedScriptsNestedInput
    lockedBy?: UserUpdateOneWithoutLockedScriptsNestedInput
    reviews?: ScriptReviewUpdateManyWithoutScriptNestedInput
    comments?: CommentUpdateManyWithoutScriptNestedInput
    videos?: VideoUpdateManyWithoutScriptNestedInput
  }

  export type ScriptUncheckedUpdateWithoutAssignedReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumScriptStatusFieldUpdateOperationsInput | $Enums.ScriptStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ScriptUpdatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ScriptReviewUncheckedUpdateManyWithoutScriptNestedInput
    comments?: CommentUncheckedUpdateManyWithoutScriptNestedInput
    videos?: VideoUncheckedUpdateManyWithoutScriptNestedInput
  }

  export type ScriptUncheckedUpdateManyWithoutAssignedReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumScriptStatusFieldUpdateOperationsInput | $Enums.ScriptStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ScriptUpdatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScriptReviewUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerType?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    decision?: EnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    script?: ScriptUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ScriptReviewUncheckedUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    scriptId?: StringFieldUpdateOperationsInput | string
    reviewerType?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    decision?: EnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScriptReviewUncheckedUpdateManyWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    scriptId?: StringFieldUpdateOperationsInput | string
    reviewerType?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    decision?: EnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    doctorName?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    ctaType?: EnumCTATypeFieldUpdateOperationsInput | $Enums.CTAType
    tags?: VideoUpdatetagsInput | string[]
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    shortSummary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: VideoUpdatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relatedVideoIds?: VideoUpdaterelatedVideoIdsInput | string[]
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    version?: IntFieldUpdateOperationsInput | number
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: TopicUpdateOneRequiredWithoutVideosNestedInput
    script?: ScriptUpdateOneWithoutVideosNestedInput
    lockedBy?: UserUpdateOneWithoutLockedVideosNestedInput
    publishedBy?: UserUpdateOneWithoutPublishedVideosNestedInput
    assignedReviewer?: UserUpdateOneWithoutAssignedVideosNestedInput
    reviews?: VideoReviewUpdateManyWithoutVideoNestedInput
    comments?: CommentUpdateManyWithoutVideoNestedInput
    analytics?: VideoAnalyticsUpdateOneWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    scriptId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    doctorName?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    ctaType?: EnumCTATypeFieldUpdateOperationsInput | $Enums.CTAType
    tags?: VideoUpdatetagsInput | string[]
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    shortSummary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: VideoUpdatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relatedVideoIds?: VideoUpdaterelatedVideoIdsInput | string[]
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    version?: IntFieldUpdateOperationsInput | number
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedById?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedReviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: VideoReviewUncheckedUpdateManyWithoutVideoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutVideoNestedInput
    analytics?: VideoAnalyticsUncheckedUpdateOneWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateManyWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    scriptId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    doctorName?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    ctaType?: EnumCTATypeFieldUpdateOperationsInput | $Enums.CTAType
    tags?: VideoUpdatetagsInput | string[]
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    shortSummary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: VideoUpdatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relatedVideoIds?: VideoUpdaterelatedVideoIdsInput | string[]
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    version?: IntFieldUpdateOperationsInput | number
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedById?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedReviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUpdateWithoutLockedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    doctorName?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    ctaType?: EnumCTATypeFieldUpdateOperationsInput | $Enums.CTAType
    tags?: VideoUpdatetagsInput | string[]
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    shortSummary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: VideoUpdatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relatedVideoIds?: VideoUpdaterelatedVideoIdsInput | string[]
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    version?: IntFieldUpdateOperationsInput | number
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: TopicUpdateOneRequiredWithoutVideosNestedInput
    script?: ScriptUpdateOneWithoutVideosNestedInput
    uploadedBy?: UserUpdateOneWithoutUploadedVideosNestedInput
    publishedBy?: UserUpdateOneWithoutPublishedVideosNestedInput
    assignedReviewer?: UserUpdateOneWithoutAssignedVideosNestedInput
    reviews?: VideoReviewUpdateManyWithoutVideoNestedInput
    comments?: CommentUpdateManyWithoutVideoNestedInput
    analytics?: VideoAnalyticsUpdateOneWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateWithoutLockedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    scriptId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    doctorName?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    ctaType?: EnumCTATypeFieldUpdateOperationsInput | $Enums.CTAType
    tags?: VideoUpdatetagsInput | string[]
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    shortSummary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: VideoUpdatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relatedVideoIds?: VideoUpdaterelatedVideoIdsInput | string[]
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    version?: IntFieldUpdateOperationsInput | number
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedById?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedReviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: VideoReviewUncheckedUpdateManyWithoutVideoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutVideoNestedInput
    analytics?: VideoAnalyticsUncheckedUpdateOneWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateManyWithoutLockedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    scriptId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    doctorName?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    ctaType?: EnumCTATypeFieldUpdateOperationsInput | $Enums.CTAType
    tags?: VideoUpdatetagsInput | string[]
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    shortSummary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: VideoUpdatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relatedVideoIds?: VideoUpdaterelatedVideoIdsInput | string[]
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    version?: IntFieldUpdateOperationsInput | number
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedById?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedReviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUpdateWithoutPublishedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    doctorName?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    ctaType?: EnumCTATypeFieldUpdateOperationsInput | $Enums.CTAType
    tags?: VideoUpdatetagsInput | string[]
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    shortSummary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: VideoUpdatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relatedVideoIds?: VideoUpdaterelatedVideoIdsInput | string[]
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    version?: IntFieldUpdateOperationsInput | number
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: TopicUpdateOneRequiredWithoutVideosNestedInput
    script?: ScriptUpdateOneWithoutVideosNestedInput
    uploadedBy?: UserUpdateOneWithoutUploadedVideosNestedInput
    lockedBy?: UserUpdateOneWithoutLockedVideosNestedInput
    assignedReviewer?: UserUpdateOneWithoutAssignedVideosNestedInput
    reviews?: VideoReviewUpdateManyWithoutVideoNestedInput
    comments?: CommentUpdateManyWithoutVideoNestedInput
    analytics?: VideoAnalyticsUpdateOneWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateWithoutPublishedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    scriptId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    doctorName?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    ctaType?: EnumCTATypeFieldUpdateOperationsInput | $Enums.CTAType
    tags?: VideoUpdatetagsInput | string[]
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    shortSummary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: VideoUpdatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relatedVideoIds?: VideoUpdaterelatedVideoIdsInput | string[]
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    version?: IntFieldUpdateOperationsInput | number
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedReviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: VideoReviewUncheckedUpdateManyWithoutVideoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutVideoNestedInput
    analytics?: VideoAnalyticsUncheckedUpdateOneWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateManyWithoutPublishedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    scriptId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    doctorName?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    ctaType?: EnumCTATypeFieldUpdateOperationsInput | $Enums.CTAType
    tags?: VideoUpdatetagsInput | string[]
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    shortSummary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: VideoUpdatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relatedVideoIds?: VideoUpdaterelatedVideoIdsInput | string[]
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    version?: IntFieldUpdateOperationsInput | number
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedReviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUpdateWithoutAssignedReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    doctorName?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    ctaType?: EnumCTATypeFieldUpdateOperationsInput | $Enums.CTAType
    tags?: VideoUpdatetagsInput | string[]
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    shortSummary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: VideoUpdatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relatedVideoIds?: VideoUpdaterelatedVideoIdsInput | string[]
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    version?: IntFieldUpdateOperationsInput | number
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: TopicUpdateOneRequiredWithoutVideosNestedInput
    script?: ScriptUpdateOneWithoutVideosNestedInput
    uploadedBy?: UserUpdateOneWithoutUploadedVideosNestedInput
    lockedBy?: UserUpdateOneWithoutLockedVideosNestedInput
    publishedBy?: UserUpdateOneWithoutPublishedVideosNestedInput
    reviews?: VideoReviewUpdateManyWithoutVideoNestedInput
    comments?: CommentUpdateManyWithoutVideoNestedInput
    analytics?: VideoAnalyticsUpdateOneWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateWithoutAssignedReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    scriptId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    doctorName?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    ctaType?: EnumCTATypeFieldUpdateOperationsInput | $Enums.CTAType
    tags?: VideoUpdatetagsInput | string[]
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    shortSummary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: VideoUpdatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relatedVideoIds?: VideoUpdaterelatedVideoIdsInput | string[]
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    version?: IntFieldUpdateOperationsInput | number
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedById?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: VideoReviewUncheckedUpdateManyWithoutVideoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutVideoNestedInput
    analytics?: VideoAnalyticsUncheckedUpdateOneWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateManyWithoutAssignedReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    scriptId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    doctorName?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    ctaType?: EnumCTATypeFieldUpdateOperationsInput | $Enums.CTAType
    tags?: VideoUpdatetagsInput | string[]
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    shortSummary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: VideoUpdatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relatedVideoIds?: VideoUpdaterelatedVideoIdsInput | string[]
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    version?: IntFieldUpdateOperationsInput | number
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedById?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoReviewUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerType?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    decision?: EnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    video?: VideoUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type VideoReviewUncheckedUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    reviewerType?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    decision?: EnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoReviewUncheckedUpdateManyWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    reviewerType?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    decision?: EnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    script?: ScriptUpdateOneWithoutCommentsNestedInput
    video?: VideoUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    scriptId?: NullableStringFieldUpdateOperationsInput | string | null
    videoId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    scriptId?: NullableStringFieldUpdateOperationsInput | string | null
    videoId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorPointerCreateManyTopicInput = {
    id?: string
    doctorId: string
    notes?: string | null
    fileUrl?: string | null
    fileType?: string | null
    createdAt?: Date | string
  }

  export type ScriptCreateManyTopicInput = {
    id?: string
    version?: number
    content: string
    status?: $Enums.ScriptStatus
    summary?: string | null
    tags?: ScriptCreatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    uploadedById?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    assignedReviewerId?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCreateManyTopicInput = {
    id?: string
    scriptId?: string | null
    title: string
    description?: string | null
    videoUrl: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: bigint | number | null
    doctorName: string
    specialty: string
    language: string
    city: string
    ctaType: $Enums.CTAType
    tags?: VideoCreatetagsInput | string[]
    transcript?: string | null
    transcriptUrl?: string | null
    summary?: string | null
    shortSummary?: string | null
    keyTakeaways?: VideoCreatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    relatedVideoIds?: VideoCreaterelatedVideoIdsInput | string[]
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    status?: $Enums.VideoStatus
    version?: number
    uploadedById?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    publishedById?: string | null
    publishedAt?: Date | string | null
    assignedReviewerId?: string | null
    assignedAt?: Date | string | null
    deepLink?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DoctorPointerUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: UserUpdateOneRequiredWithoutDoctorPointersNestedInput
  }

  export type DoctorPointerUncheckedUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorPointerUncheckedUpdateManyWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScriptUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumScriptStatusFieldUpdateOperationsInput | $Enums.ScriptStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ScriptUpdatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: UserUpdateOneWithoutUploadedScriptsNestedInput
    lockedBy?: UserUpdateOneWithoutLockedScriptsNestedInput
    assignedReviewer?: UserUpdateOneWithoutAssignedScriptsNestedInput
    reviews?: ScriptReviewUpdateManyWithoutScriptNestedInput
    comments?: CommentUpdateManyWithoutScriptNestedInput
    videos?: VideoUpdateManyWithoutScriptNestedInput
  }

  export type ScriptUncheckedUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumScriptStatusFieldUpdateOperationsInput | $Enums.ScriptStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ScriptUpdatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedReviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ScriptReviewUncheckedUpdateManyWithoutScriptNestedInput
    comments?: CommentUncheckedUpdateManyWithoutScriptNestedInput
    videos?: VideoUncheckedUpdateManyWithoutScriptNestedInput
  }

  export type ScriptUncheckedUpdateManyWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumScriptStatusFieldUpdateOperationsInput | $Enums.ScriptStatus
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ScriptUpdatetagsInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedReviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    doctorName?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    ctaType?: EnumCTATypeFieldUpdateOperationsInput | $Enums.CTAType
    tags?: VideoUpdatetagsInput | string[]
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    shortSummary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: VideoUpdatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relatedVideoIds?: VideoUpdaterelatedVideoIdsInput | string[]
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    version?: IntFieldUpdateOperationsInput | number
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    script?: ScriptUpdateOneWithoutVideosNestedInput
    uploadedBy?: UserUpdateOneWithoutUploadedVideosNestedInput
    lockedBy?: UserUpdateOneWithoutLockedVideosNestedInput
    publishedBy?: UserUpdateOneWithoutPublishedVideosNestedInput
    assignedReviewer?: UserUpdateOneWithoutAssignedVideosNestedInput
    reviews?: VideoReviewUpdateManyWithoutVideoNestedInput
    comments?: CommentUpdateManyWithoutVideoNestedInput
    analytics?: VideoAnalyticsUpdateOneWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    scriptId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    doctorName?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    ctaType?: EnumCTATypeFieldUpdateOperationsInput | $Enums.CTAType
    tags?: VideoUpdatetagsInput | string[]
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    shortSummary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: VideoUpdatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relatedVideoIds?: VideoUpdaterelatedVideoIdsInput | string[]
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    version?: IntFieldUpdateOperationsInput | number
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedById?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedReviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: VideoReviewUncheckedUpdateManyWithoutVideoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutVideoNestedInput
    analytics?: VideoAnalyticsUncheckedUpdateOneWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateManyWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    scriptId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    doctorName?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    ctaType?: EnumCTATypeFieldUpdateOperationsInput | $Enums.CTAType
    tags?: VideoUpdatetagsInput | string[]
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    shortSummary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: VideoUpdatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relatedVideoIds?: VideoUpdaterelatedVideoIdsInput | string[]
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    version?: IntFieldUpdateOperationsInput | number
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedById?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedReviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScriptReviewCreateManyScriptInput = {
    id?: string
    reviewerId: string
    reviewerType: $Enums.UserRole
    decision?: $Enums.ReviewDecision
    comments?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type CommentCreateManyScriptInput = {
    id?: string
    videoId?: string | null
    authorId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCreateManyScriptInput = {
    id?: string
    topicId: string
    title: string
    description?: string | null
    videoUrl: string
    thumbnailUrl?: string | null
    duration?: number | null
    fileSize?: bigint | number | null
    doctorName: string
    specialty: string
    language: string
    city: string
    ctaType: $Enums.CTAType
    tags?: VideoCreatetagsInput | string[]
    transcript?: string | null
    transcriptUrl?: string | null
    summary?: string | null
    shortSummary?: string | null
    keyTakeaways?: VideoCreatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: number | null
    relatedVideoIds?: VideoCreaterelatedVideoIdsInput | string[]
    aiProcessedAt?: Date | string | null
    aiProcessingStatus?: string | null
    status?: $Enums.VideoStatus
    version?: number
    uploadedById?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    publishedById?: string | null
    publishedAt?: Date | string | null
    assignedReviewerId?: string | null
    assignedAt?: Date | string | null
    deepLink?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScriptReviewUpdateWithoutScriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerType?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    decision?: EnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewer?: UserUpdateOneRequiredWithoutScriptReviewsNestedInput
  }

  export type ScriptReviewUncheckedUpdateWithoutScriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    reviewerType?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    decision?: EnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScriptReviewUncheckedUpdateManyWithoutScriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    reviewerType?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    decision?: EnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutScriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    video?: VideoUpdateOneWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutScriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutScriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUpdateWithoutScriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    doctorName?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    ctaType?: EnumCTATypeFieldUpdateOperationsInput | $Enums.CTAType
    tags?: VideoUpdatetagsInput | string[]
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    shortSummary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: VideoUpdatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relatedVideoIds?: VideoUpdaterelatedVideoIdsInput | string[]
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    version?: IntFieldUpdateOperationsInput | number
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: TopicUpdateOneRequiredWithoutVideosNestedInput
    uploadedBy?: UserUpdateOneWithoutUploadedVideosNestedInput
    lockedBy?: UserUpdateOneWithoutLockedVideosNestedInput
    publishedBy?: UserUpdateOneWithoutPublishedVideosNestedInput
    assignedReviewer?: UserUpdateOneWithoutAssignedVideosNestedInput
    reviews?: VideoReviewUpdateManyWithoutVideoNestedInput
    comments?: CommentUpdateManyWithoutVideoNestedInput
    analytics?: VideoAnalyticsUpdateOneWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateWithoutScriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    doctorName?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    ctaType?: EnumCTATypeFieldUpdateOperationsInput | $Enums.CTAType
    tags?: VideoUpdatetagsInput | string[]
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    shortSummary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: VideoUpdatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relatedVideoIds?: VideoUpdaterelatedVideoIdsInput | string[]
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    version?: IntFieldUpdateOperationsInput | number
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedById?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedReviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: VideoReviewUncheckedUpdateManyWithoutVideoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutVideoNestedInput
    analytics?: VideoAnalyticsUncheckedUpdateOneWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateManyWithoutScriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    doctorName?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    ctaType?: EnumCTATypeFieldUpdateOperationsInput | $Enums.CTAType
    tags?: VideoUpdatetagsInput | string[]
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    shortSummary?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaways?: VideoUpdatekeyTakeawaysInput | string[]
    entities?: NullableJsonNullValueInput | InputJsonValue
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relatedVideoIds?: VideoUpdaterelatedVideoIdsInput | string[]
    aiProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiProcessingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVideoStatusFieldUpdateOperationsInput | $Enums.VideoStatus
    version?: IntFieldUpdateOperationsInput | number
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedById?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedReviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoReviewCreateManyVideoInput = {
    id?: string
    reviewerId: string
    reviewerType: $Enums.UserRole
    decision?: $Enums.ReviewDecision
    comments?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type CommentCreateManyVideoInput = {
    id?: string
    scriptId?: string | null
    authorId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoReviewUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerType?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    decision?: EnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewer?: UserUpdateOneRequiredWithoutVideoReviewsNestedInput
  }

  export type VideoReviewUncheckedUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    reviewerType?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    decision?: EnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoReviewUncheckedUpdateManyWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    reviewerType?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    decision?: EnumReviewDecisionFieldUpdateOperationsInput | $Enums.ReviewDecision
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    script?: ScriptUpdateOneWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    scriptId?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    scriptId?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TopicCountOutputTypeDefaultArgs instead
     */
    export type TopicCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TopicCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScriptCountOutputTypeDefaultArgs instead
     */
    export type ScriptCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScriptCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VideoCountOutputTypeDefaultArgs instead
     */
    export type VideoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VideoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TopicDefaultArgs instead
     */
    export type TopicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TopicDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DoctorPointerDefaultArgs instead
     */
    export type DoctorPointerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DoctorPointerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScriptDefaultArgs instead
     */
    export type ScriptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScriptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScriptReviewDefaultArgs instead
     */
    export type ScriptReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScriptReviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VideoDefaultArgs instead
     */
    export type VideoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VideoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VideoReviewDefaultArgs instead
     */
    export type VideoReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VideoReviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentDefaultArgs instead
     */
    export type CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VideoAnalyticsDefaultArgs instead
     */
    export type VideoAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VideoAnalyticsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}